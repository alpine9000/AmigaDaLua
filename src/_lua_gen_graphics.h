#define _lua_gen_pushTagItem(l, o) amiga_push_type(l, o, "TagItem")

#define _lua_gen_checkTagItem(l, i) amiga_check_type(l, i,  "TagItem")

#define _lua_gen_pushRectangle(l, o) amiga_push_type(l, o, "Rectangle")

#define _lua_gen_checkRectangle(l, i) amiga_check_type(l, i,  "Rectangle")

#define _lua_gen_pushPoint(l, o) amiga_push_type(l, o, "Point")

#define _lua_gen_checkPoint(l, i) amiga_check_type(l, i,  "Point")

#define _lua_gen_pushBitMap(l, o) amiga_push_type(l, o, "BitMap")

#define _lua_gen_checkBitMap(l, i) amiga_check_type(l, i,  "BitMap")

#define _lua_gen_pushExtendedNode(l, o) amiga_push_type(l, o, "ExtendedNode")

#define _lua_gen_checkExtendedNode(l, i) amiga_check_type(l, i,  "ExtendedNode")

#define _lua_gen_pushCopIns(l, o) amiga_push_type(l, o, "CopIns")

#define _lua_gen_checkCopIns(l, i) amiga_check_type(l, i,  "CopIns")

#define _lua_gen_pushcprlist(l, o) amiga_push_type(l, o, "cprlist")

#define _lua_gen_checkcprlist(l, i) amiga_check_type(l, i,  "cprlist")

#define _lua_gen_pushCopList(l, o) amiga_push_type(l, o, "CopList")

#define _lua_gen_checkCopList(l, i) amiga_check_type(l, i,  "CopList")

#define _lua_gen_pushcopinit(l, o) amiga_push_type(l, o, "copinit")

#define _lua_gen_checkcopinit(l, i) amiga_check_type(l, i,  "copinit")

#define _lua_gen_pushView(l, o) amiga_push_type(l, o, "View")

#define _lua_gen_checkView(l, i) amiga_check_type(l, i,  "View")

#define _lua_gen_pushViewPort(l, o) amiga_push_type(l, o, "ViewPort")

#define _lua_gen_checkViewPort(l, i) amiga_check_type(l, i,  "ViewPort")

#define _lua_gen_pushViewPortExtra(l, o) amiga_push_type(l, o, "ViewPortExtra")

#define _lua_gen_checkViewPortExtra(l, i) amiga_check_type(l, i,  "ViewPortExtra")

#define _lua_gen_pushColorMap(l, o) amiga_push_type(l, o, "ColorMap")

#define _lua_gen_checkColorMap(l, i) amiga_check_type(l, i,  "ColorMap")

#define _lua_gen_pushPaletteExtra(l, o) amiga_push_type(l, o, "PaletteExtra")

#define _lua_gen_checkPaletteExtra(l, i) amiga_check_type(l, i,  "PaletteExtra")

#define _lua_gen_pushDBufInfo(l, o) amiga_push_type(l, o, "DBufInfo")

#define _lua_gen_checkDBufInfo(l, i) amiga_check_type(l, i,  "DBufInfo")

#define _lua_gen_pushMonitorSpec(l, o) amiga_push_type(l, o, "MonitorSpec")

#define _lua_gen_checkMonitorSpec(l, i) amiga_check_type(l, i,  "MonitorSpec")

#define _lua_gen_pushAnalogSignalInterval(l, o) amiga_push_type(l, o, "AnalogSignalInterval")

#define _lua_gen_checkAnalogSignalInterval(l, i) amiga_check_type(l, i,  "AnalogSignalInterval")

#define _lua_gen_pushSpecialMonitor(l, o) amiga_push_type(l, o, "SpecialMonitor")

#define _lua_gen_checkSpecialMonitor(l, i) amiga_check_type(l, i,  "SpecialMonitor")

#define _lua_gen_pushAnimOb(l, o) amiga_push_type(l, o, "AnimOb")

#define _lua_gen_checkAnimOb(l, i) amiga_check_type(l, i,  "AnimOb")

#define _lua_gen_pushAreaInfo(l, o) amiga_push_type(l, o, "AreaInfo")

#define _lua_gen_checkAreaInfo(l, i) amiga_check_type(l, i,  "AreaInfo")

#define _lua_gen_pushBitScaleArgs(l, o) amiga_push_type(l, o, "BitScaleArgs")

#define _lua_gen_checkBitScaleArgs(l, i) amiga_check_type(l, i,  "BitScaleArgs")

#define _lua_gen_pushBob(l, o) amiga_push_type(l, o, "Bob")

#define _lua_gen_checkBob(l, i) amiga_check_type(l, i,  "Bob")

#define _lua_gen_pushGelsInfo(l, o) amiga_push_type(l, o, "GelsInfo")

#define _lua_gen_checkGelsInfo(l, i) amiga_check_type(l, i,  "GelsInfo")

#define _lua_gen_pushLayer(l, o) amiga_push_type(l, o, "Layer")

#define _lua_gen_checkLayer(l, i) amiga_check_type(l, i,  "Layer")

#define _lua_gen_pushRastPort(l, o) amiga_push_type(l, o, "RastPort")

#define _lua_gen_checkRastPort(l, i) amiga_check_type(l, i,  "RastPort")

#define _lua_gen_pushRegion(l, o) amiga_push_type(l, o, "Region")

#define _lua_gen_checkRegion(l, i) amiga_check_type(l, i,  "Region")

#define _lua_gen_pushSimpleSprite(l, o) amiga_push_type(l, o, "SimpleSprite")

#define _lua_gen_checkSimpleSprite(l, i) amiga_check_type(l, i,  "SimpleSprite")

#define _lua_gen_pushTextAttr(l, o) amiga_push_type(l, o, "TextAttr")

#define _lua_gen_checkTextAttr(l, i) amiga_check_type(l, i,  "TextAttr")

#define _lua_gen_pushTextFont(l, o) amiga_push_type(l, o, "TextFont")

#define _lua_gen_checkTextFont(l, i) amiga_check_type(l, i,  "TextFont")

#define _lua_gen_pushVSprite(l, o) amiga_push_type(l, o, "VSprite")

#define _lua_gen_checkVSprite(l, i) amiga_check_type(l, i,  "VSprite")

#define _lua_gen_pushbltnode(l, o) amiga_push_type(l, o, "bltnode")

#define _lua_gen_checkbltnode(l, i) amiga_check_type(l, i,  "bltnode")

#define _lua_gen_pushAnimComp(l, o) amiga_push_type(l, o, "AnimComp")

#define _lua_gen_checkAnimComp(l, i) amiga_check_type(l, i,  "AnimComp")

#define _lua_gen_pushDBufPacket(l, o) amiga_push_type(l, o, "DBufPacket")

#define _lua_gen_checkDBufPacket(l, i) amiga_check_type(l, i,  "DBufPacket")

#define _lua_gen_pushcollTable(l, o) amiga_push_type(l, o, "collTable")

#define _lua_gen_checkcollTable(l, i) amiga_check_type(l, i,  "collTable")

#define _lua_gen_pushTmpRas(l, o) amiga_push_type(l, o, "TmpRas")

#define _lua_gen_checkTmpRas(l, i) amiga_check_type(l, i,  "TmpRas")

#define _lua_gen_pushRegionRectangle(l, o) amiga_push_type(l, o, "RegionRectangle")

#define _lua_gen_checkRegionRectangle(l, i) amiga_check_type(l, i,  "RegionRectangle")

#define _lua_gen_pushExtSprite(l, o) amiga_push_type(l, o, "ExtSprite")

#define _lua_gen_checkExtSprite(l, i) amiga_check_type(l, i,  "ExtSprite")

static int
_lua_gen_TagItem_newindex(lua_State *L)
{
  struct TagItem *obj = *(struct TagItem **)luaL_checkudata(L, 1, "TagItem");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  // Unsupported type ti_Tag Tag
  if (strcmp(key, "ti_Tag") == 0) {
    return luaL_error(L, "Unsupported type Tag for field ti_Tag");
  }
  if (strcmp(key, "ti_Data") == 0) {
    obj->ti_Data = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_TagItem_constructor(lua_State *L)
{
  // Allocate pointer-to-struct TagItem in userdata
  struct TagItem **objp = lua_newuserdata(L, sizeof(struct TagItem *));
  *objp = malloc(sizeof(struct TagItem));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct TagItem));

  // Set metatable
  luaL_getmetatable(L, "TagItem");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_TagItem_index(lua_State *L)
{
  struct TagItem *obj = *(struct TagItem **)luaL_checkudata(L, 1, "TagItem");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  // Unsupported ti_Tag Tag
  if (strcmp(key, "ti_Tag") == 0) {
    return luaL_error(L, "Unsupported type Tag for field ti_Tag");
  }
  if (strcmp(key, "ti_Data") == 0) {
    lua_pushinteger(L, obj->ti_Data);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct TagItem));
    return 1;
}

  return 0;
}

static void
_lua_gen_TagItem_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "ti_Data");
  lua_rawseti(L, -2, 1);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_TagItem(lua_State *L) {
  if (luaL_newmetatable(L, "TagItem")) {
    lua_pushcfunction(L, _lua_gen_TagItem_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_TagItem_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_TagItem_constructor);
    lua_setglobal(L, "TagItem");
    _lua_gen_TagItem_install_keys(L);
    lua_pushstring(L, "TagItem");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_Rectangle_newindex(lua_State *L)
{
  struct Rectangle *obj = *(struct Rectangle **)luaL_checkudata(L, 1, "Rectangle");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "MinX") == 0) {
    obj->MinX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "MinY") == 0) {
    obj->MinY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "MaxX") == 0) {
    obj->MaxX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "MaxY") == 0) {
    obj->MaxY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_Rectangle_constructor(lua_State *L)
{
  // Allocate pointer-to-struct Rectangle in userdata
  struct Rectangle **objp = lua_newuserdata(L, sizeof(struct Rectangle *));
  *objp = malloc(sizeof(struct Rectangle));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct Rectangle));

  // Set metatable
  luaL_getmetatable(L, "Rectangle");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_Rectangle_index(lua_State *L)
{
  struct Rectangle *obj = *(struct Rectangle **)luaL_checkudata(L, 1, "Rectangle");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "MinX") == 0) {
    lua_pushinteger(L, obj->MinX);
    return 1;
  }
  if (strcmp(key, "MinY") == 0) {
    lua_pushinteger(L, obj->MinY);
    return 1;
  }
  if (strcmp(key, "MaxX") == 0) {
    lua_pushinteger(L, obj->MaxX);
    return 1;
  }
  if (strcmp(key, "MaxY") == 0) {
    lua_pushinteger(L, obj->MaxY);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct Rectangle));
    return 1;
}

  return 0;
}

static void
_lua_gen_Rectangle_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "MinX");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "MinY");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "MaxX");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "MaxY");
  lua_rawseti(L, -2, 4);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_Rectangle(lua_State *L) {
  if (luaL_newmetatable(L, "Rectangle")) {
    lua_pushcfunction(L, _lua_gen_Rectangle_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_Rectangle_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_Rectangle_constructor);
    lua_setglobal(L, "Rectangle");
    _lua_gen_Rectangle_install_keys(L);
    lua_pushstring(L, "Rectangle");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_Point_newindex(lua_State *L)
{
  Point *obj = *(Point **)luaL_checkudata(L, 1, "Point");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "x") == 0) {
    obj->x = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "y") == 0) {
    obj->y = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_Point_constructor(lua_State *L)
{
  // Allocate pointer-to-Point in userdata
  Point **objp = lua_newuserdata(L, sizeof(Point *));
  *objp = malloc(sizeof(Point));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(Point));

  // Set metatable
  luaL_getmetatable(L, "Point");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_Point_index(lua_State *L)
{
  Point *obj = *(Point **)luaL_checkudata(L, 1, "Point");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "x") == 0) {
    lua_pushinteger(L, obj->x);
    return 1;
  }
  if (strcmp(key, "y") == 0) {
    lua_pushinteger(L, obj->y);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(Point));
    return 1;
}

  return 0;
}

static void
_lua_gen_Point_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "x");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "y");
  lua_rawseti(L, -2, 2);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_Point(lua_State *L) {
  if (luaL_newmetatable(L, "Point")) {
    lua_pushcfunction(L, _lua_gen_Point_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_Point_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_Point_constructor);
    lua_setglobal(L, "Point");
    _lua_gen_Point_install_keys(L);
    lua_pushstring(L, "Point");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

typedef struct {
  PLANEPTR* data;
  uint16_t count;
} lua_gen_wrapped_PLANEPTR_array_data_t;

static int _lua_gen_wrapped_PLANEPTR_array_ptr_method(lua_State* L) {
    lua_gen_wrapped_PLANEPTR_array_data_t* wrapper = luaL_checkudata(L, 1, "PLANEPTR_array_proxy");
    int index = luaL_checkinteger(L, 2);
    void* ptr = &wrapper->data[index - 1];
    lua_pushlightuserdata(L, ptr);
    return 1;
}
static int
_lua_gen_wrapped_PLANEPTR_array_index(lua_State* L)
{
  lua_gen_wrapped_PLANEPTR_array_data_t* wrapper = luaL_checkudata(L, 1, "PLANEPTR_array_proxy");
  if (lua_isinteger(L, 2)) {
    int index = lua_tointeger(L, 2);
    if (index < 1 || index > wrapper->count)
      return luaL_error(L, "index out of range (1..%d)", wrapper->count);
    lua_pushlightuserdata(L, wrapper->data[index - 1]);
    return 1;
  }

  // Not a numeric key? Try methods
  lua_getmetatable(L, 1);
  lua_getfield(L, -1, "__methods");
  lua_pushvalue(L, 2);
  lua_gettable(L, -2);
  return 1;
}

static int
_lua_gen_wrapped_PLANEPTR_array_newindex(lua_State* L)
{
  lua_gen_wrapped_PLANEPTR_array_data_t* wrapper = luaL_checkudata(L, 1, "PLANEPTR_array_proxy");
  if (!lua_isinteger(L, 2))
    return luaL_error(L, "only integer indices allowed");
  int index = lua_tointeger(L, 2);
  if (index < 1 || index > wrapper->count)
    return luaL_error(L, "index out of range (1..%d)", wrapper->count);
  PLANEPTR value = lua_touserdata(L,  3);
  wrapper->data[index - 1] = value;
  return 0;
}

static void
_lua_gen_push_PLANEPTR_array_proxy(lua_State *L,  PLANEPTR *array, int count)
{

  lua_gen_wrapped_PLANEPTR_array_data_t* wrapper = lua_newuserdata(L, sizeof(lua_gen_wrapped_PLANEPTR_array_data_t));
  wrapper->data = array;
  wrapper->count = count;

  if (luaL_newmetatable(L, "PLANEPTR_array_proxy")) {
    // Create method table
    lua_newtable(L);
    lua_pushcfunction(L, _lua_gen_wrapped_PLANEPTR_array_ptr_method);
    lua_setfield(L, -2, "ptr");
    lua_setfield(L, -2, "__methods");

    // __index handles both numeric and method lookup
    lua_pushcfunction(L, _lua_gen_wrapped_PLANEPTR_array_index);
    lua_setfield(L, -2, "__index");

    // __newindex for writing
    lua_pushcfunction(L, _lua_gen_wrapped_PLANEPTR_array_newindex);
    lua_setfield(L, -2, "__newindex");
  }

  lua_setmetatable(L, -2);  // assign to userdata

}
static int
_lua_gen_BitMap_newindex(lua_State *L)
{
  struct BitMap *obj = *(struct BitMap **)luaL_checkudata(L, 1, "BitMap");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "BytesPerRow") == 0) {
    obj->BytesPerRow = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Rows") == 0) {
    obj->Rows = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Flags") == 0) {
    obj->Flags = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Depth") == 0) {
    obj->Depth = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "pad") == 0) {
    obj->pad = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // Planes[8] proxied via the index
  return 0;
}


static int
_lua_BitMap_constructor(lua_State *L)
{
  // Allocate pointer-to-struct BitMap in userdata
  struct BitMap **objp = lua_newuserdata(L, sizeof(struct BitMap *));
  *objp = malloc(sizeof(struct BitMap));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct BitMap));

  // Set metatable
  luaL_getmetatable(L, "BitMap");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_BitMap_index(lua_State *L)
{
  struct BitMap *obj = *(struct BitMap **)luaL_checkudata(L, 1, "BitMap");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "BytesPerRow") == 0) {
    lua_pushinteger(L, obj->BytesPerRow);
    return 1;
  }
  if (strcmp(key, "Rows") == 0) {
    lua_pushinteger(L, obj->Rows);
    return 1;
  }
  if (strcmp(key, "Flags") == 0) {
    lua_pushinteger(L, obj->Flags);
    return 1;
  }
  if (strcmp(key, "Depth") == 0) {
    lua_pushinteger(L, obj->Depth);
    return 1;
  }
  if (strcmp(key, "pad") == 0) {
    lua_pushinteger(L, obj->pad);
    return 1;
  }
  if (strcmp(key, "Planes") == 0) {
    _lua_gen_push_PLANEPTR_array_proxy(L, obj->Planes, 8);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct BitMap));
    return 1;
}

  return 0;
}

static void
_lua_gen_BitMap_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "BytesPerRow");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "Rows");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "Flags");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "Depth");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "pad");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "Planes");
  lua_rawseti(L, -2, 6);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_BitMap(lua_State *L) {
  if (luaL_newmetatable(L, "BitMap")) {
    lua_pushcfunction(L, _lua_gen_BitMap_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_BitMap_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_BitMap_constructor);
    lua_setglobal(L, "BitMap");
    _lua_gen_BitMap_install_keys(L);
    lua_pushstring(L, "BitMap");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_ExtendedNode_newindex(lua_State *L)
{
  struct ExtendedNode *obj = *(struct ExtendedNode **)luaL_checkudata(L, 1, "ExtendedNode");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  // Unsupported type xln_Succ struct Node
  if (strcmp(key, "xln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field xln_Succ");
  }
  // Unsupported type xln_Pred struct Node
  if (strcmp(key, "xln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field xln_Pred");
  }
  if (strcmp(key, "xln_Type") == 0) {
    obj->xln_Type = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "xln_Pri") == 0) {
    obj->xln_Pri = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "xln_Name") == 0) {
    obj->xln_Name = (char *)luaL_checkstring(L, 3);
    return 0;
  }
  if (strcmp(key, "xln_Subsystem") == 0) {
    obj->xln_Subsystem = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "xln_Subtype") == 0) {
    obj->xln_Subtype = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type xln_Library struct GfxBase
  if (strcmp(key, "xln_Library") == 0) {
    return luaL_error(L, "Unsupported type struct GfxBase for field xln_Library");
  }
  // Unsupported type xln_Init LONG ()(struct ExtendedNode , UWORD)
  if (strcmp(key, "xln_Init") == 0) {
    return luaL_error(L, "Unsupported type LONG ()(struct ExtendedNode , UWORD) for field xln_Init");
  }
  return 0;
}


static int
_lua_ExtendedNode_constructor(lua_State *L)
{
  // Allocate pointer-to-struct ExtendedNode in userdata
  struct ExtendedNode **objp = lua_newuserdata(L, sizeof(struct ExtendedNode *));
  *objp = malloc(sizeof(struct ExtendedNode));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct ExtendedNode));

  // Set metatable
  luaL_getmetatable(L, "ExtendedNode");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_ExtendedNode_index(lua_State *L)
{
  struct ExtendedNode *obj = *(struct ExtendedNode **)luaL_checkudata(L, 1, "ExtendedNode");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  // Unsupported xln_Succ struct Node *
  if (strcmp(key, "xln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field xln_Succ");
  }
  // Unsupported xln_Pred struct Node *
  if (strcmp(key, "xln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field xln_Pred");
  }
  if (strcmp(key, "xln_Type") == 0) {
    lua_pushinteger(L, obj->xln_Type);
    return 1;
  }
  if (strcmp(key, "xln_Pri") == 0) {
    lua_pushinteger(L, obj->xln_Pri);
    return 1;
  }
  if (strcmp(key, "xln_Name") == 0) {
    lua_pushstring(L, obj->xln_Name);
    return 1;
  }
  if (strcmp(key, "xln_Subsystem") == 0) {
    lua_pushinteger(L, obj->xln_Subsystem);
    return 1;
  }
  if (strcmp(key, "xln_Subtype") == 0) {
    lua_pushinteger(L, obj->xln_Subtype);
    return 1;
  }
  // Unsupported xln_Library struct GfxBase *
  if (strcmp(key, "xln_Library") == 0) {
    return luaL_error(L, "Unsupported type struct GfxBase * for field xln_Library");
  }
  // Unsupported xln_Init LONG (*)(struct ExtendedNode *, UWORD)
  if (strcmp(key, "xln_Init") == 0) {
    return luaL_error(L, "Unsupported type LONG (*)(struct ExtendedNode *, UWORD) for field xln_Init");
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct ExtendedNode));
    return 1;
}

  return 0;
}

static void
_lua_gen_ExtendedNode_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "xln_Type");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "xln_Pri");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "xln_Name");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "xln_Subsystem");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "xln_Subtype");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "xln_Init");
  lua_rawseti(L, -2, 6);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_ExtendedNode(lua_State *L) {
  if (luaL_newmetatable(L, "ExtendedNode")) {
    lua_pushcfunction(L, _lua_gen_ExtendedNode_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_ExtendedNode_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_ExtendedNode_constructor);
    lua_setglobal(L, "ExtendedNode");
    _lua_gen_ExtendedNode_install_keys(L);
    lua_pushstring(L, "ExtendedNode");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_CopIns_newindex(lua_State *L)
{
  struct CopIns *obj = *(struct CopIns **)luaL_checkudata(L, 1, "CopIns");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "OpCode") == 0) {
    obj->OpCode = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "u3.nxtlist") == 0) {
    // finder 1
    //obj->u3.nxtlist = *(struct CopList **)luaL_checkudata(L, 3, "CopList");
    obj->u3.nxtlist = (struct CopList *)_lua_gen_checkCopList(L, 3);
    return 0;
  }
  if (strcmp(key, "u3.u4.u1.VWaitPos") == 0) {
    obj->u3.u4.u1.VWaitPos = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "u3.u4.u1.DestAddr") == 0) {
    obj->u3.u4.u1.DestAddr = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "u3.u4.u2.HWaitPos") == 0) {
    obj->u3.u4.u2.HWaitPos = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "u3.u4.u2.DestData") == 0) {
    obj->u3.u4.u2.DestData = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type u3 unnamed union
  if (strcmp(key, "u3") == 0) {
    return luaL_error(L, "Unsupported type unnamed union for field u3");
  }
  return 0;
}


static int
_lua_CopIns_constructor(lua_State *L)
{
  // Allocate pointer-to-struct CopIns in userdata
  struct CopIns **objp = lua_newuserdata(L, sizeof(struct CopIns *));
  *objp = malloc(sizeof(struct CopIns));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct CopIns));

  // Set metatable
  luaL_getmetatable(L, "CopIns");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_CopIns_index(lua_State *L)
{
  struct CopIns *obj = *(struct CopIns **)luaL_checkudata(L, 1, "CopIns");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "OpCode") == 0) {
    lua_pushinteger(L, obj->OpCode);
    return 1;
  }
  if (strcmp(key, "u3.nxtlist") == 0) {
    struct CopList **ud = (struct CopList **)lua_newuserdata(L, sizeof(struct CopList *));
    *ud = (struct CopList*)obj->u3.nxtlist;
    luaL_getmetatable(L, "CopList");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "u3.u4.u1.VWaitPos") == 0) {
    lua_pushinteger(L, obj->u3.u4.u1.VWaitPos);
    return 1;
  }
  if (strcmp(key, "u3.u4.u1.DestAddr") == 0) {
    lua_pushinteger(L, obj->u3.u4.u1.DestAddr);
    return 1;
  }
  if (strcmp(key, "u3.u4.u2.HWaitPos") == 0) {
    lua_pushinteger(L, obj->u3.u4.u2.HWaitPos);
    return 1;
  }
  if (strcmp(key, "u3.u4.u2.DestData") == 0) {
    lua_pushinteger(L, obj->u3.u4.u2.DestData);
    return 1;
  }
  // Unsupported u3 unnamed union
  if (strcmp(key, "u3") == 0) {
    return luaL_error(L, "Unsupported type unnamed union for field u3");
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct CopIns));
    return 1;
}

  return 0;
}

static void
_lua_gen_CopIns_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "OpCode");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "u3.u4.u1.VWaitPos");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "u3.u4.u1.DestAddr");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "u3.u4.u2.HWaitPos");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "u3.u4.u2.DestData");
  lua_rawseti(L, -2, 5);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_CopIns(lua_State *L) {
  if (luaL_newmetatable(L, "CopIns")) {
    lua_pushcfunction(L, _lua_gen_CopIns_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_CopIns_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_CopIns_constructor);
    lua_setglobal(L, "CopIns");
    _lua_gen_CopIns_install_keys(L);
    lua_pushstring(L, "CopIns");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_CopList_newindex(lua_State *L)
{
  struct CopList *obj = *(struct CopList **)luaL_checkudata(L, 1, "CopList");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "Next") == 0) {
    // finder 1
    //obj->Next = *(struct CopList **)luaL_checkudata(L, 3, "CopList");
    obj->Next = (struct CopList *)_lua_gen_checkCopList(L, 3);
    return 0;
  }
  if (strcmp(key, "_CopList") == 0) {
    // finder 1
    //obj->_CopList = *(struct CopList **)luaL_checkudata(L, 3, "CopList");
    obj->_CopList = (struct CopList *)_lua_gen_checkCopList(L, 3);
    return 0;
  }
  if (strcmp(key, "_ViewPort") == 0) {
    // finder 1
    //obj->_ViewPort = *(struct ViewPort **)luaL_checkudata(L, 3, "ViewPort");
    obj->_ViewPort = (struct ViewPort *)_lua_gen_checkViewPort(L, 3);
    return 0;
  }
  if (strcmp(key, "CopIns") == 0) {
    // finder 1
    //obj->CopIns = *(struct CopIns **)luaL_checkudata(L, 3, "CopIns");
    obj->CopIns = (struct CopIns *)_lua_gen_checkCopIns(L, 3);
    return 0;
  }
  if (strcmp(key, "CopPtr") == 0) {
    // finder 1
    //obj->CopPtr = *(struct CopIns **)luaL_checkudata(L, 3, "CopIns");
    obj->CopPtr = (struct CopIns *)_lua_gen_checkCopIns(L, 3);
    return 0;
  }
  if (strcmp(key, "CopLStart") == 0) {
    obj->CopLStart = (UWORD *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "CopSStart") == 0) {
    obj->CopSStart = (UWORD *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "Count") == 0) {
    obj->Count = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "MaxCount") == 0) {
    obj->MaxCount = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DyOffset") == 0) {
    obj->DyOffset = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "SLRepeat") == 0) {
    obj->SLRepeat = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Flags") == 0) {
    obj->Flags = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_CopList_constructor(lua_State *L)
{
  // Allocate pointer-to-struct CopList in userdata
  struct CopList **objp = lua_newuserdata(L, sizeof(struct CopList *));
  *objp = malloc(sizeof(struct CopList));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct CopList));

  // Set metatable
  luaL_getmetatable(L, "CopList");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_CopList_index(lua_State *L)
{
  struct CopList *obj = *(struct CopList **)luaL_checkudata(L, 1, "CopList");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "Next") == 0) {
    struct CopList **ud = (struct CopList **)lua_newuserdata(L, sizeof(struct CopList *));
    *ud = (struct CopList*)obj->Next;
    luaL_getmetatable(L, "CopList");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "_CopList") == 0) {
    struct CopList **ud = (struct CopList **)lua_newuserdata(L, sizeof(struct CopList *));
    *ud = (struct CopList*)obj->_CopList;
    luaL_getmetatable(L, "CopList");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "_ViewPort") == 0) {
    struct ViewPort **ud = (struct ViewPort **)lua_newuserdata(L, sizeof(struct ViewPort *));
    *ud = (struct ViewPort*)obj->_ViewPort;
    luaL_getmetatable(L, "ViewPort");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "CopIns") == 0) {
    struct CopIns **ud = (struct CopIns **)lua_newuserdata(L, sizeof(struct CopIns *));
    *ud = (struct CopIns*)obj->CopIns;
    luaL_getmetatable(L, "CopIns");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "CopPtr") == 0) {
    struct CopIns **ud = (struct CopIns **)lua_newuserdata(L, sizeof(struct CopIns *));
    *ud = (struct CopIns*)obj->CopPtr;
    luaL_getmetatable(L, "CopIns");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "CopLStart") == 0) {
    lua_pushlightuserdata(L, obj->CopLStart);
    return 1;
  }
  if (strcmp(key, "CopSStart") == 0) {
    lua_pushlightuserdata(L, obj->CopSStart);
    return 1;
  }
  if (strcmp(key, "Count") == 0) {
    lua_pushinteger(L, obj->Count);
    return 1;
  }
  if (strcmp(key, "MaxCount") == 0) {
    lua_pushinteger(L, obj->MaxCount);
    return 1;
  }
  if (strcmp(key, "DyOffset") == 0) {
    lua_pushinteger(L, obj->DyOffset);
    return 1;
  }
  if (strcmp(key, "SLRepeat") == 0) {
    lua_pushinteger(L, obj->SLRepeat);
    return 1;
  }
  if (strcmp(key, "Flags") == 0) {
    lua_pushinteger(L, obj->Flags);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct CopList));
    return 1;
}

  return 0;
}

static void
_lua_gen_CopList_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "CopLStart");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "CopSStart");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "Count");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "MaxCount");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "DyOffset");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "SLRepeat");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "Flags");
  lua_rawseti(L, -2, 7);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_CopList(lua_State *L) {
  if (luaL_newmetatable(L, "CopList")) {
    lua_pushcfunction(L, _lua_gen_CopList_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_CopList_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_CopList_constructor);
    lua_setglobal(L, "CopList");
    _lua_gen_CopList_install_keys(L);
    lua_pushstring(L, "CopList");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_cprlist_newindex(lua_State *L)
{
  struct cprlist *obj = *(struct cprlist **)luaL_checkudata(L, 1, "cprlist");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "Next") == 0) {
    // finder 1
    //obj->Next = *(struct cprlist **)luaL_checkudata(L, 3, "cprlist");
    obj->Next = (struct cprlist *)_lua_gen_checkcprlist(L, 3);
    return 0;
  }
  if (strcmp(key, "start") == 0) {
    obj->start = (UWORD *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "MaxCount") == 0) {
    obj->MaxCount = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_cprlist_constructor(lua_State *L)
{
  // Allocate pointer-to-struct cprlist in userdata
  struct cprlist **objp = lua_newuserdata(L, sizeof(struct cprlist *));
  *objp = malloc(sizeof(struct cprlist));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct cprlist));

  // Set metatable
  luaL_getmetatable(L, "cprlist");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_cprlist_index(lua_State *L)
{
  struct cprlist *obj = *(struct cprlist **)luaL_checkudata(L, 1, "cprlist");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "Next") == 0) {
    struct cprlist **ud = (struct cprlist **)lua_newuserdata(L, sizeof(struct cprlist *));
    *ud = (struct cprlist*)obj->Next;
    luaL_getmetatable(L, "cprlist");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "start") == 0) {
    lua_pushlightuserdata(L, obj->start);
    return 1;
  }
  if (strcmp(key, "MaxCount") == 0) {
    lua_pushinteger(L, obj->MaxCount);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct cprlist));
    return 1;
}

  return 0;
}

static void
_lua_gen_cprlist_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "start");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "MaxCount");
  lua_rawseti(L, -2, 2);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_cprlist(lua_State *L) {
  if (luaL_newmetatable(L, "cprlist")) {
    lua_pushcfunction(L, _lua_gen_cprlist_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_cprlist_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_cprlist_constructor);
    lua_setglobal(L, "cprlist");
    _lua_gen_cprlist_install_keys(L);
    lua_pushstring(L, "cprlist");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_ViewPort_newindex(lua_State *L)
{
  struct ViewPort *obj = *(struct ViewPort **)luaL_checkudata(L, 1, "ViewPort");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "Next") == 0) {
    // finder 1
    //obj->Next = *(struct ViewPort **)luaL_checkudata(L, 3, "ViewPort");
    obj->Next = (struct ViewPort *)_lua_gen_checkViewPort(L, 3);
    return 0;
  }
  if (strcmp(key, "ColorMap") == 0) {
    // finder 1
    //obj->ColorMap = *(struct ColorMap **)luaL_checkudata(L, 3, "ColorMap");
    obj->ColorMap = (struct ColorMap *)_lua_gen_checkColorMap(L, 3);
    return 0;
  }
  if (strcmp(key, "DspIns") == 0) {
    // finder 1
    //obj->DspIns = *(struct CopList **)luaL_checkudata(L, 3, "CopList");
    obj->DspIns = (struct CopList *)_lua_gen_checkCopList(L, 3);
    return 0;
  }
  if (strcmp(key, "SprIns") == 0) {
    // finder 1
    //obj->SprIns = *(struct CopList **)luaL_checkudata(L, 3, "CopList");
    obj->SprIns = (struct CopList *)_lua_gen_checkCopList(L, 3);
    return 0;
  }
  if (strcmp(key, "ClrIns") == 0) {
    // finder 1
    //obj->ClrIns = *(struct CopList **)luaL_checkudata(L, 3, "CopList");
    obj->ClrIns = (struct CopList *)_lua_gen_checkCopList(L, 3);
    return 0;
  }
  if (strcmp(key, "UCopIns") == 0) {
    obj->UCopIns = (struct UCopList *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "DWidth") == 0) {
    obj->DWidth = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DHeight") == 0) {
    obj->DHeight = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DxOffset") == 0) {
    obj->DxOffset = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DyOffset") == 0) {
    obj->DyOffset = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Modes") == 0) {
    obj->Modes = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "SpritePriorities") == 0) {
    obj->SpritePriorities = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ExtendedModes") == 0) {
    obj->ExtendedModes = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type RasInfo struct RasInfo
  if (strcmp(key, "RasInfo") == 0) {
    return luaL_error(L, "Unsupported type struct RasInfo for field RasInfo");
  }
  return 0;
}


static int
_lua_ViewPort_constructor(lua_State *L)
{
  // Allocate pointer-to-struct ViewPort in userdata
  struct ViewPort **objp = lua_newuserdata(L, sizeof(struct ViewPort *));
  *objp = malloc(sizeof(struct ViewPort));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct ViewPort));

  // Set metatable
  luaL_getmetatable(L, "ViewPort");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_ViewPort_index(lua_State *L)
{
  struct ViewPort *obj = *(struct ViewPort **)luaL_checkudata(L, 1, "ViewPort");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "Next") == 0) {
    struct ViewPort **ud = (struct ViewPort **)lua_newuserdata(L, sizeof(struct ViewPort *));
    *ud = (struct ViewPort*)obj->Next;
    luaL_getmetatable(L, "ViewPort");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "ColorMap") == 0) {
    struct ColorMap **ud = (struct ColorMap **)lua_newuserdata(L, sizeof(struct ColorMap *));
    *ud = (struct ColorMap*)obj->ColorMap;
    luaL_getmetatable(L, "ColorMap");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "DspIns") == 0) {
    struct CopList **ud = (struct CopList **)lua_newuserdata(L, sizeof(struct CopList *));
    *ud = (struct CopList*)obj->DspIns;
    luaL_getmetatable(L, "CopList");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "SprIns") == 0) {
    struct CopList **ud = (struct CopList **)lua_newuserdata(L, sizeof(struct CopList *));
    *ud = (struct CopList*)obj->SprIns;
    luaL_getmetatable(L, "CopList");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "ClrIns") == 0) {
    struct CopList **ud = (struct CopList **)lua_newuserdata(L, sizeof(struct CopList *));
    *ud = (struct CopList*)obj->ClrIns;
    luaL_getmetatable(L, "CopList");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "UCopIns") == 0) {
    lua_pushlightuserdata(L, obj->UCopIns);
    return 1;
  }
  if (strcmp(key, "DWidth") == 0) {
    lua_pushinteger(L, obj->DWidth);
    return 1;
  }
  if (strcmp(key, "DHeight") == 0) {
    lua_pushinteger(L, obj->DHeight);
    return 1;
  }
  if (strcmp(key, "DxOffset") == 0) {
    lua_pushinteger(L, obj->DxOffset);
    return 1;
  }
  if (strcmp(key, "DyOffset") == 0) {
    lua_pushinteger(L, obj->DyOffset);
    return 1;
  }
  if (strcmp(key, "Modes") == 0) {
    lua_pushinteger(L, obj->Modes);
    return 1;
  }
  if (strcmp(key, "SpritePriorities") == 0) {
    lua_pushinteger(L, obj->SpritePriorities);
    return 1;
  }
  if (strcmp(key, "ExtendedModes") == 0) {
    lua_pushinteger(L, obj->ExtendedModes);
    return 1;
  }
  // Unsupported RasInfo struct RasInfo *
  if (strcmp(key, "RasInfo") == 0) {
    return luaL_error(L, "Unsupported type struct RasInfo * for field RasInfo");
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct ViewPort));
    return 1;
}

  return 0;
}

static void
_lua_gen_ViewPort_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "DWidth");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "DHeight");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "DxOffset");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "DyOffset");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "Modes");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "SpritePriorities");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "ExtendedModes");
  lua_rawseti(L, -2, 7);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_ViewPort(lua_State *L) {
  if (luaL_newmetatable(L, "ViewPort")) {
    lua_pushcfunction(L, _lua_gen_ViewPort_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_ViewPort_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_ViewPort_constructor);
    lua_setglobal(L, "ViewPort");
    _lua_gen_ViewPort_install_keys(L);
    lua_pushstring(L, "ViewPort");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

typedef struct {
  UWORD* data;
  uint16_t count;
} lua_gen_wrapped_UWORD_array_data_t;

static int _lua_gen_wrapped_UWORD_array_ptr_method(lua_State* L) {
    lua_gen_wrapped_UWORD_array_data_t* wrapper = luaL_checkudata(L, 1, "UWORD_array_proxy");
    int index = luaL_checkinteger(L, 2);
    void* ptr = &wrapper->data[index - 1];
    lua_pushlightuserdata(L, ptr);
    return 1;
}
static int
_lua_gen_wrapped_UWORD_array_index(lua_State* L)
{
  lua_gen_wrapped_UWORD_array_data_t* wrapper = luaL_checkudata(L, 1, "UWORD_array_proxy");
  if (lua_isinteger(L, 2)) {
    int index = lua_tointeger(L, 2);
    if (index < 1 || index > wrapper->count)
      return luaL_error(L, "index out of range (1..%d)", wrapper->count);
    lua_pushinteger(L, wrapper->data[index - 1]);
    return 1;
  }

  // Not a numeric key? Try methods
  lua_getmetatable(L, 1);
  lua_getfield(L, -1, "__methods");
  lua_pushvalue(L, 2);
  lua_gettable(L, -2);
  return 1;
}

static int
_lua_gen_wrapped_UWORD_array_newindex(lua_State* L)
{
  lua_gen_wrapped_UWORD_array_data_t* wrapper = luaL_checkudata(L, 1, "UWORD_array_proxy");
  if (!lua_isinteger(L, 2))
    return luaL_error(L, "only integer indices allowed");
  int index = lua_tointeger(L, 2);
  if (index < 1 || index > wrapper->count)
    return luaL_error(L, "index out of range (1..%d)", wrapper->count);
  UWORD value = luaL_checkinteger(L,  3);
  wrapper->data[index - 1] = value;
  return 0;
}

static void
_lua_gen_push_UWORD_array_proxy(lua_State *L,  UWORD *array, int count)
{

  lua_gen_wrapped_UWORD_array_data_t* wrapper = lua_newuserdata(L, sizeof(lua_gen_wrapped_UWORD_array_data_t));
  wrapper->data = array;
  wrapper->count = count;

  if (luaL_newmetatable(L, "UWORD_array_proxy")) {
    // Create method table
    lua_newtable(L);
    lua_pushcfunction(L, _lua_gen_wrapped_UWORD_array_ptr_method);
    lua_setfield(L, -2, "ptr");
    lua_setfield(L, -2, "__methods");

    // __index handles both numeric and method lookup
    lua_pushcfunction(L, _lua_gen_wrapped_UWORD_array_index);
    lua_setfield(L, -2, "__index");

    // __newindex for writing
    lua_pushcfunction(L, _lua_gen_wrapped_UWORD_array_newindex);
    lua_setfield(L, -2, "__newindex");
  }

  lua_setmetatable(L, -2);  // assign to userdata

}
static int
_lua_gen_copinit_newindex(lua_State *L)
{
  struct copinit *obj = *(struct copinit **)luaL_checkudata(L, 1, "copinit");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  // vsync_hblank[2] proxied via the index
  // diagstrt[12] proxied via the index
  // fm0[2] proxied via the index
  // diwstart[10] proxied via the index
  // bplcon2[2] proxied via the index
  // sprfix[16] proxied via the index
  // sprstrtup[32] proxied via the index
  // wait14[2] proxied via the index
  // norm_hblank[2] proxied via the index
  // jump[2] proxied via the index
  // wait_forever[6] proxied via the index
  // sprstop[8] proxied via the index
  return 0;
}


static int
_lua_copinit_constructor(lua_State *L)
{
  // Allocate pointer-to-struct copinit in userdata
  struct copinit **objp = lua_newuserdata(L, sizeof(struct copinit *));
  *objp = malloc(sizeof(struct copinit));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct copinit));

  // Set metatable
  luaL_getmetatable(L, "copinit");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_copinit_index(lua_State *L)
{
  struct copinit *obj = *(struct copinit **)luaL_checkudata(L, 1, "copinit");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "vsync_hblank") == 0) {
    _lua_gen_push_UWORD_array_proxy(L, obj->vsync_hblank, 2);
    return 1;
  }
  if (strcmp(key, "diagstrt") == 0) {
    _lua_gen_push_UWORD_array_proxy(L, obj->diagstrt, 12);
    return 1;
  }
  if (strcmp(key, "fm0") == 0) {
    _lua_gen_push_UWORD_array_proxy(L, obj->fm0, 2);
    return 1;
  }
  if (strcmp(key, "diwstart") == 0) {
    _lua_gen_push_UWORD_array_proxy(L, obj->diwstart, 10);
    return 1;
  }
  if (strcmp(key, "bplcon2") == 0) {
    _lua_gen_push_UWORD_array_proxy(L, obj->bplcon2, 2);
    return 1;
  }
  if (strcmp(key, "sprfix") == 0) {
    _lua_gen_push_UWORD_array_proxy(L, obj->sprfix, 16);
    return 1;
  }
  if (strcmp(key, "sprstrtup") == 0) {
    _lua_gen_push_UWORD_array_proxy(L, obj->sprstrtup, 32);
    return 1;
  }
  if (strcmp(key, "wait14") == 0) {
    _lua_gen_push_UWORD_array_proxy(L, obj->wait14, 2);
    return 1;
  }
  if (strcmp(key, "norm_hblank") == 0) {
    _lua_gen_push_UWORD_array_proxy(L, obj->norm_hblank, 2);
    return 1;
  }
  if (strcmp(key, "jump") == 0) {
    _lua_gen_push_UWORD_array_proxy(L, obj->jump, 2);
    return 1;
  }
  if (strcmp(key, "wait_forever") == 0) {
    _lua_gen_push_UWORD_array_proxy(L, obj->wait_forever, 6);
    return 1;
  }
  if (strcmp(key, "sprstop") == 0) {
    _lua_gen_push_UWORD_array_proxy(L, obj->sprstop, 8);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct copinit));
    return 1;
}

  return 0;
}

static void
_lua_gen_copinit_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "vsync_hblank");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "diagstrt");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "fm0");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "diwstart");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "bplcon2");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "sprfix");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "sprstrtup");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "wait14");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "norm_hblank");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "jump");
  lua_rawseti(L, -2, 10);
  lua_pushstring(L, "wait_forever");
  lua_rawseti(L, -2, 11);
  lua_pushstring(L, "sprstop");
  lua_rawseti(L, -2, 12);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_copinit(lua_State *L) {
  if (luaL_newmetatable(L, "copinit")) {
    lua_pushcfunction(L, _lua_gen_copinit_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_copinit_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_copinit_constructor);
    lua_setglobal(L, "copinit");
    _lua_gen_copinit_install_keys(L);
    lua_pushstring(L, "copinit");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_ColorMap_newindex(lua_State *L)
{
  struct ColorMap *obj = *(struct ColorMap **)luaL_checkudata(L, 1, "ColorMap");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "Flags") == 0) {
    obj->Flags = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Type") == 0) {
    obj->Type = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Count") == 0) {
    obj->Count = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ColorTable") == 0) {
    obj->ColorTable = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "cm_vpe") == 0) {
    // finder 1
    //obj->cm_vpe = *(struct ViewPortExtra **)luaL_checkudata(L, 3, "ViewPortExtra");
    obj->cm_vpe = (struct ViewPortExtra *)_lua_gen_checkViewPortExtra(L, 3);
    return 0;
  }
  if (strcmp(key, "LowColorBits") == 0) {
    obj->LowColorBits = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "TransparencyPlane") == 0) {
    obj->TransparencyPlane = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "SpriteResolution") == 0) {
    obj->SpriteResolution = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "SpriteResDefault") == 0) {
    obj->SpriteResDefault = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "AuxFlags") == 0) {
    obj->AuxFlags = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "cm_vp") == 0) {
    // finder 1
    //obj->cm_vp = *(struct ViewPort **)luaL_checkudata(L, 3, "ViewPort");
    obj->cm_vp = (struct ViewPort *)_lua_gen_checkViewPort(L, 3);
    return 0;
  }
  if (strcmp(key, "NormalDisplayInfo") == 0) {
    obj->NormalDisplayInfo = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "CoerceDisplayInfo") == 0) {
    obj->CoerceDisplayInfo = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "cm_batch_items") == 0) {
    // finder 1
    //obj->cm_batch_items = *(struct TagItem **)luaL_checkudata(L, 3, "TagItem");
    obj->cm_batch_items = (struct TagItem *)_lua_gen_checkTagItem(L, 3);
    return 0;
  }
  if (strcmp(key, "VPModeID") == 0) {
    obj->VPModeID = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "PalExtra") == 0) {
    // finder 1
    //obj->PalExtra = *(struct PaletteExtra **)luaL_checkudata(L, 3, "PaletteExtra");
    obj->PalExtra = (struct PaletteExtra *)_lua_gen_checkPaletteExtra(L, 3);
    return 0;
  }
  if (strcmp(key, "SpriteBase_Even") == 0) {
    obj->SpriteBase_Even = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "SpriteBase_Odd") == 0) {
    obj->SpriteBase_Odd = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Bp_0_base") == 0) {
    obj->Bp_0_base = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Bp_1_base") == 0) {
    obj->Bp_1_base = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_ColorMap_constructor(lua_State *L)
{
  // Allocate pointer-to-struct ColorMap in userdata
  struct ColorMap **objp = lua_newuserdata(L, sizeof(struct ColorMap *));
  *objp = malloc(sizeof(struct ColorMap));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct ColorMap));

  // Set metatable
  luaL_getmetatable(L, "ColorMap");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_ColorMap_index(lua_State *L)
{
  struct ColorMap *obj = *(struct ColorMap **)luaL_checkudata(L, 1, "ColorMap");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "Flags") == 0) {
    lua_pushinteger(L, obj->Flags);
    return 1;
  }
  if (strcmp(key, "Type") == 0) {
    lua_pushinteger(L, obj->Type);
    return 1;
  }
  if (strcmp(key, "Count") == 0) {
    lua_pushinteger(L, obj->Count);
    return 1;
  }
  if (strcmp(key, "ColorTable") == 0) {
    lua_pushlightuserdata(L, obj->ColorTable);
    return 1;
  }
  if (strcmp(key, "cm_vpe") == 0) {
    struct ViewPortExtra **ud = (struct ViewPortExtra **)lua_newuserdata(L, sizeof(struct ViewPortExtra *));
    *ud = (struct ViewPortExtra*)obj->cm_vpe;
    luaL_getmetatable(L, "ViewPortExtra");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "LowColorBits") == 0) {
    lua_pushlightuserdata(L, obj->LowColorBits);
    return 1;
  }
  if (strcmp(key, "TransparencyPlane") == 0) {
    lua_pushinteger(L, obj->TransparencyPlane);
    return 1;
  }
  if (strcmp(key, "SpriteResolution") == 0) {
    lua_pushinteger(L, obj->SpriteResolution);
    return 1;
  }
  if (strcmp(key, "SpriteResDefault") == 0) {
    lua_pushinteger(L, obj->SpriteResDefault);
    return 1;
  }
  if (strcmp(key, "AuxFlags") == 0) {
    lua_pushinteger(L, obj->AuxFlags);
    return 1;
  }
  if (strcmp(key, "cm_vp") == 0) {
    struct ViewPort **ud = (struct ViewPort **)lua_newuserdata(L, sizeof(struct ViewPort *));
    *ud = (struct ViewPort*)obj->cm_vp;
    luaL_getmetatable(L, "ViewPort");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "NormalDisplayInfo") == 0) {
    lua_pushlightuserdata(L, obj->NormalDisplayInfo);
    return 1;
  }
  if (strcmp(key, "CoerceDisplayInfo") == 0) {
    lua_pushlightuserdata(L, obj->CoerceDisplayInfo);
    return 1;
  }
  if (strcmp(key, "cm_batch_items") == 0) {
    struct TagItem **ud = (struct TagItem **)lua_newuserdata(L, sizeof(struct TagItem *));
    *ud = (struct TagItem*)obj->cm_batch_items;
    luaL_getmetatable(L, "TagItem");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "VPModeID") == 0) {
    lua_pushinteger(L, obj->VPModeID);
    return 1;
  }
  if (strcmp(key, "PalExtra") == 0) {
    struct PaletteExtra **ud = (struct PaletteExtra **)lua_newuserdata(L, sizeof(struct PaletteExtra *));
    *ud = (struct PaletteExtra*)obj->PalExtra;
    luaL_getmetatable(L, "PaletteExtra");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "SpriteBase_Even") == 0) {
    lua_pushinteger(L, obj->SpriteBase_Even);
    return 1;
  }
  if (strcmp(key, "SpriteBase_Odd") == 0) {
    lua_pushinteger(L, obj->SpriteBase_Odd);
    return 1;
  }
  if (strcmp(key, "Bp_0_base") == 0) {
    lua_pushinteger(L, obj->Bp_0_base);
    return 1;
  }
  if (strcmp(key, "Bp_1_base") == 0) {
    lua_pushinteger(L, obj->Bp_1_base);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct ColorMap));
    return 1;
}

  return 0;
}

static void
_lua_gen_ColorMap_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "Flags");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "Type");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "Count");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "ColorTable");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "LowColorBits");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "TransparencyPlane");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "SpriteResolution");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "SpriteResDefault");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "AuxFlags");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "NormalDisplayInfo");
  lua_rawseti(L, -2, 10);
  lua_pushstring(L, "CoerceDisplayInfo");
  lua_rawseti(L, -2, 11);
  lua_pushstring(L, "VPModeID");
  lua_rawseti(L, -2, 12);
  lua_pushstring(L, "SpriteBase_Even");
  lua_rawseti(L, -2, 13);
  lua_pushstring(L, "SpriteBase_Odd");
  lua_rawseti(L, -2, 14);
  lua_pushstring(L, "Bp_0_base");
  lua_rawseti(L, -2, 15);
  lua_pushstring(L, "Bp_1_base");
  lua_rawseti(L, -2, 16);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_ColorMap(lua_State *L) {
  if (luaL_newmetatable(L, "ColorMap")) {
    lua_pushcfunction(L, _lua_gen_ColorMap_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_ColorMap_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_ColorMap_constructor);
    lua_setglobal(L, "ColorMap");
    _lua_gen_ColorMap_install_keys(L);
    lua_pushstring(L, "ColorMap");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_MonitorSpec_newindex(lua_State *L)
{
  struct MonitorSpec *obj = *(struct MonitorSpec **)luaL_checkudata(L, 1, "MonitorSpec");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  // Unsupported type ms_Node.xln_Succ struct Node
  if (strcmp(key, "ms_Node.xln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field ms_Node.xln_Succ");
  }
  // Unsupported type ms_Node.xln_Pred struct Node
  if (strcmp(key, "ms_Node.xln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field ms_Node.xln_Pred");
  }
  if (strcmp(key, "ms_Node.xln_Type") == 0) {
    obj->ms_Node.xln_Type = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ms_Node.xln_Pri") == 0) {
    obj->ms_Node.xln_Pri = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ms_Node.xln_Name") == 0) {
    obj->ms_Node.xln_Name = (char *)luaL_checkstring(L, 3);
    return 0;
  }
  if (strcmp(key, "ms_Node.xln_Subsystem") == 0) {
    obj->ms_Node.xln_Subsystem = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ms_Node.xln_Subtype") == 0) {
    obj->ms_Node.xln_Subtype = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type ms_Node.xln_Library struct GfxBase
  if (strcmp(key, "ms_Node.xln_Library") == 0) {
    return luaL_error(L, "Unsupported type struct GfxBase for field ms_Node.xln_Library");
  }
  // Unsupported type ms_Node.xln_Init LONG ()(struct ExtendedNode , UWORD)
  if (strcmp(key, "ms_Node.xln_Init") == 0) {
    return luaL_error(L, "Unsupported type LONG ()(struct ExtendedNode , UWORD) for field ms_Node.xln_Init");
  }
  if (strcmp(key, "ms_Node") == 0) {
    // finder 0
    struct ExtendedNode *val = *(struct ExtendedNode **)luaL_checkudata(L, 3, "ExtendedNode");
    obj->ms_Node = *val;
    return 0;
  }
  if (strcmp(key, "ms_Flags") == 0) {
    obj->ms_Flags = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ratioh") == 0) {
    obj->ratioh = (LONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ratiov") == 0) {
    obj->ratiov = (LONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "total_rows") == 0) {
    obj->total_rows = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "total_colorclocks") == 0) {
    obj->total_colorclocks = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DeniseMaxDisplayColumn") == 0) {
    obj->DeniseMaxDisplayColumn = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "BeamCon0") == 0) {
    obj->BeamCon0 = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "min_row") == 0) {
    obj->min_row = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ms_Special") == 0) {
    // finder 1
    //obj->ms_Special = *(struct SpecialMonitor **)luaL_checkudata(L, 3, "SpecialMonitor");
    obj->ms_Special = (struct SpecialMonitor *)_lua_gen_checkSpecialMonitor(L, 3);
    return 0;
  }
  if (strcmp(key, "ms_OpenCount") == 0) {
    obj->ms_OpenCount = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type ms_transform LONG ()(struct MonitorSpec , Point , UWORD, Point )
  if (strcmp(key, "ms_transform") == 0) {
    return luaL_error(L, "Unsupported type LONG ()(struct MonitorSpec , Point , UWORD, Point ) for field ms_transform");
  }
  // Unsupported type ms_translate LONG ()(struct MonitorSpec , Point , UWORD, Point )
  if (strcmp(key, "ms_translate") == 0) {
    return luaL_error(L, "Unsupported type LONG ()(struct MonitorSpec , Point , UWORD, Point ) for field ms_translate");
  }
  // Unsupported type ms_scale LONG ()(struct MonitorSpec , Point , UWORD, Point )
  if (strcmp(key, "ms_scale") == 0) {
    return luaL_error(L, "Unsupported type LONG ()(struct MonitorSpec , Point , UWORD, Point ) for field ms_scale");
  }
  if (strcmp(key, "ms_xoffset") == 0) {
    obj->ms_xoffset = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ms_yoffset") == 0) {
    obj->ms_yoffset = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ms_LegalView.MinX") == 0) {
    obj->ms_LegalView.MinX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ms_LegalView.MinY") == 0) {
    obj->ms_LegalView.MinY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ms_LegalView.MaxX") == 0) {
    obj->ms_LegalView.MaxX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ms_LegalView.MaxY") == 0) {
    obj->ms_LegalView.MaxY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ms_LegalView") == 0) {
    // finder 0
    struct Rectangle *val = *(struct Rectangle **)luaL_checkudata(L, 3, "Rectangle");
    obj->ms_LegalView = *val;
    return 0;
  }
  // Unsupported type ms_maxoscan LONG ()(struct MonitorSpec , struct Rectangle , ULONG)
  if (strcmp(key, "ms_maxoscan") == 0) {
    return luaL_error(L, "Unsupported type LONG ()(struct MonitorSpec , struct Rectangle , ULONG) for field ms_maxoscan");
  }
  // Unsupported type ms_videoscan LONG ()(struct MonitorSpec , struct Rectangle , ULONG)
  if (strcmp(key, "ms_videoscan") == 0) {
    return luaL_error(L, "Unsupported type LONG ()(struct MonitorSpec , struct Rectangle , ULONG) for field ms_videoscan");
  }
  if (strcmp(key, "DeniseMinDisplayColumn") == 0) {
    obj->DeniseMinDisplayColumn = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DisplayCompatible") == 0) {
    obj->DisplayCompatible = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type DisplayInfoDataBase.lh_Head struct Node
  if (strcmp(key, "DisplayInfoDataBase.lh_Head") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field DisplayInfoDataBase.lh_Head");
  }
  // Unsupported type DisplayInfoDataBase.lh_Tail struct Node
  if (strcmp(key, "DisplayInfoDataBase.lh_Tail") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field DisplayInfoDataBase.lh_Tail");
  }
  // Unsupported type DisplayInfoDataBase.lh_TailPred struct Node
  if (strcmp(key, "DisplayInfoDataBase.lh_TailPred") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field DisplayInfoDataBase.lh_TailPred");
  }
  if (strcmp(key, "DisplayInfoDataBase.lh_Type") == 0) {
    obj->DisplayInfoDataBase.lh_Type = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DisplayInfoDataBase.l_pad") == 0) {
    obj->DisplayInfoDataBase.l_pad = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type DisplayInfoDataBase struct List
  if (strcmp(key, "DisplayInfoDataBase") == 0) {
    return luaL_error(L, "Unsupported type struct List for field DisplayInfoDataBase");
  }
  // Unsupported type DisplayInfoDataBaseSemaphore.ss_Link.ln_Succ struct Node
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_Link.ln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field DisplayInfoDataBaseSemaphore.ss_Link.ln_Succ");
  }
  // Unsupported type DisplayInfoDataBaseSemaphore.ss_Link.ln_Pred struct Node
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_Link.ln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field DisplayInfoDataBaseSemaphore.ss_Link.ln_Pred");
  }
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_Link.ln_Type") == 0) {
    obj->DisplayInfoDataBaseSemaphore.ss_Link.ln_Type = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_Link.ln_Pri") == 0) {
    obj->DisplayInfoDataBaseSemaphore.ss_Link.ln_Pri = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_Link.ln_Name") == 0) {
    obj->DisplayInfoDataBaseSemaphore.ss_Link.ln_Name = (char *)luaL_checkstring(L, 3);
    return 0;
  }
  // Unsupported type DisplayInfoDataBaseSemaphore.ss_Link struct Node
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_Link") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field DisplayInfoDataBaseSemaphore.ss_Link");
  }
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_NestCount") == 0) {
    obj->DisplayInfoDataBaseSemaphore.ss_NestCount = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type DisplayInfoDataBaseSemaphore.ss_WaitQueue.mlh_Head struct MinNode
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_WaitQueue.mlh_Head") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode for field DisplayInfoDataBaseSemaphore.ss_WaitQueue.mlh_Head");
  }
  // Unsupported type DisplayInfoDataBaseSemaphore.ss_WaitQueue.mlh_Tail struct MinNode
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_WaitQueue.mlh_Tail") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode for field DisplayInfoDataBaseSemaphore.ss_WaitQueue.mlh_Tail");
  }
  // Unsupported type DisplayInfoDataBaseSemaphore.ss_WaitQueue.mlh_TailPred struct MinNode
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_WaitQueue.mlh_TailPred") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode for field DisplayInfoDataBaseSemaphore.ss_WaitQueue.mlh_TailPred");
  }
  // Unsupported type DisplayInfoDataBaseSemaphore.ss_WaitQueue struct MinList
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_WaitQueue") == 0) {
    return luaL_error(L, "Unsupported type struct MinList for field DisplayInfoDataBaseSemaphore.ss_WaitQueue");
  }
  // Unsupported type DisplayInfoDataBaseSemaphore.ss_MultipleLink.sr_Link.mln_Succ struct MinNode
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_MultipleLink.sr_Link.mln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode for field DisplayInfoDataBaseSemaphore.ss_MultipleLink.sr_Link.mln_Succ");
  }
  // Unsupported type DisplayInfoDataBaseSemaphore.ss_MultipleLink.sr_Link.mln_Pred struct MinNode
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_MultipleLink.sr_Link.mln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode for field DisplayInfoDataBaseSemaphore.ss_MultipleLink.sr_Link.mln_Pred");
  }
  // Unsupported type DisplayInfoDataBaseSemaphore.ss_MultipleLink.sr_Link struct MinNode
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_MultipleLink.sr_Link") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode for field DisplayInfoDataBaseSemaphore.ss_MultipleLink.sr_Link");
  }
  // Unsupported type DisplayInfoDataBaseSemaphore.ss_MultipleLink.sr_Waiter struct Task
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_MultipleLink.sr_Waiter") == 0) {
    return luaL_error(L, "Unsupported type struct Task for field DisplayInfoDataBaseSemaphore.ss_MultipleLink.sr_Waiter");
  }
  // Unsupported type DisplayInfoDataBaseSemaphore.ss_MultipleLink struct SemaphoreRequest
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_MultipleLink") == 0) {
    return luaL_error(L, "Unsupported type struct SemaphoreRequest for field DisplayInfoDataBaseSemaphore.ss_MultipleLink");
  }
  // Unsupported type DisplayInfoDataBaseSemaphore.ss_Owner struct Task
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_Owner") == 0) {
    return luaL_error(L, "Unsupported type struct Task for field DisplayInfoDataBaseSemaphore.ss_Owner");
  }
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_QueueCount") == 0) {
    obj->DisplayInfoDataBaseSemaphore.ss_QueueCount = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type DisplayInfoDataBaseSemaphore struct SignalSemaphore
  if (strcmp(key, "DisplayInfoDataBaseSemaphore") == 0) {
    return luaL_error(L, "Unsupported type struct SignalSemaphore for field DisplayInfoDataBaseSemaphore");
  }
  // Unsupported type ms_MrgCop LONG ()(struct View )
  if (strcmp(key, "ms_MrgCop") == 0) {
    return luaL_error(L, "Unsupported type LONG ()(struct View ) for field ms_MrgCop");
  }
  // Unsupported type ms_LoadView LONG ()(struct View )
  if (strcmp(key, "ms_LoadView") == 0) {
    return luaL_error(L, "Unsupported type LONG ()(struct View ) for field ms_LoadView");
  }
  // Unsupported type ms_KillView LONG ()(struct MonitorSpec )
  if (strcmp(key, "ms_KillView") == 0) {
    return luaL_error(L, "Unsupported type LONG ()(struct MonitorSpec ) for field ms_KillView");
  }
  return 0;
}


static int
_lua_MonitorSpec_constructor(lua_State *L)
{
  // Allocate pointer-to-struct MonitorSpec in userdata
  struct MonitorSpec **objp = lua_newuserdata(L, sizeof(struct MonitorSpec *));
  *objp = malloc(sizeof(struct MonitorSpec));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct MonitorSpec));

  // Set metatable
  luaL_getmetatable(L, "MonitorSpec");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_MonitorSpec_index(lua_State *L)
{
  struct MonitorSpec *obj = *(struct MonitorSpec **)luaL_checkudata(L, 1, "MonitorSpec");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  // Unsupported ms_Node.xln_Succ struct Node *
  if (strcmp(key, "ms_Node.xln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field ms_Node.xln_Succ");
  }
  // Unsupported ms_Node.xln_Pred struct Node *
  if (strcmp(key, "ms_Node.xln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field ms_Node.xln_Pred");
  }
  if (strcmp(key, "ms_Node.xln_Type") == 0) {
    lua_pushinteger(L, obj->ms_Node.xln_Type);
    return 1;
  }
  if (strcmp(key, "ms_Node.xln_Pri") == 0) {
    lua_pushinteger(L, obj->ms_Node.xln_Pri);
    return 1;
  }
  if (strcmp(key, "ms_Node.xln_Name") == 0) {
    lua_pushstring(L, obj->ms_Node.xln_Name);
    return 1;
  }
  if (strcmp(key, "ms_Node.xln_Subsystem") == 0) {
    lua_pushinteger(L, obj->ms_Node.xln_Subsystem);
    return 1;
  }
  if (strcmp(key, "ms_Node.xln_Subtype") == 0) {
    lua_pushinteger(L, obj->ms_Node.xln_Subtype);
    return 1;
  }
  // Unsupported ms_Node.xln_Library struct GfxBase *
  if (strcmp(key, "ms_Node.xln_Library") == 0) {
    return luaL_error(L, "Unsupported type struct GfxBase * for field ms_Node.xln_Library");
  }
  // Unsupported ms_Node.xln_Init LONG (*)(struct ExtendedNode *, UWORD)
  if (strcmp(key, "ms_Node.xln_Init") == 0) {
    return luaL_error(L, "Unsupported type LONG (*)(struct ExtendedNode *, UWORD) for field ms_Node.xln_Init");
  }
  if (strcmp(key, "ms_Node") == 0) {
    struct ExtendedNode **ud = (struct ExtendedNode **)lua_newuserdata(L, sizeof(struct ExtendedNode *));
    *ud = (struct ExtendedNode*)&obj->ms_Node;
    luaL_getmetatable(L, "ExtendedNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "ms_Flags") == 0) {
    lua_pushinteger(L, obj->ms_Flags);
    return 1;
  }
  if (strcmp(key, "ratioh") == 0) {
    lua_pushinteger(L, obj->ratioh);
    return 1;
  }
  if (strcmp(key, "ratiov") == 0) {
    lua_pushinteger(L, obj->ratiov);
    return 1;
  }
  if (strcmp(key, "total_rows") == 0) {
    lua_pushinteger(L, obj->total_rows);
    return 1;
  }
  if (strcmp(key, "total_colorclocks") == 0) {
    lua_pushinteger(L, obj->total_colorclocks);
    return 1;
  }
  if (strcmp(key, "DeniseMaxDisplayColumn") == 0) {
    lua_pushinteger(L, obj->DeniseMaxDisplayColumn);
    return 1;
  }
  if (strcmp(key, "BeamCon0") == 0) {
    lua_pushinteger(L, obj->BeamCon0);
    return 1;
  }
  if (strcmp(key, "min_row") == 0) {
    lua_pushinteger(L, obj->min_row);
    return 1;
  }
  if (strcmp(key, "ms_Special") == 0) {
    struct SpecialMonitor **ud = (struct SpecialMonitor **)lua_newuserdata(L, sizeof(struct SpecialMonitor *));
    *ud = (struct SpecialMonitor*)obj->ms_Special;
    luaL_getmetatable(L, "SpecialMonitor");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "ms_OpenCount") == 0) {
    lua_pushinteger(L, obj->ms_OpenCount);
    return 1;
  }
  // Unsupported ms_transform LONG (*)(struct MonitorSpec *, Point *, UWORD, Point *)
  if (strcmp(key, "ms_transform") == 0) {
    return luaL_error(L, "Unsupported type LONG (*)(struct MonitorSpec *, Point *, UWORD, Point *) for field ms_transform");
  }
  // Unsupported ms_translate LONG (*)(struct MonitorSpec *, Point *, UWORD, Point *)
  if (strcmp(key, "ms_translate") == 0) {
    return luaL_error(L, "Unsupported type LONG (*)(struct MonitorSpec *, Point *, UWORD, Point *) for field ms_translate");
  }
  // Unsupported ms_scale LONG (*)(struct MonitorSpec *, Point *, UWORD, Point *)
  if (strcmp(key, "ms_scale") == 0) {
    return luaL_error(L, "Unsupported type LONG (*)(struct MonitorSpec *, Point *, UWORD, Point *) for field ms_scale");
  }
  if (strcmp(key, "ms_xoffset") == 0) {
    lua_pushinteger(L, obj->ms_xoffset);
    return 1;
  }
  if (strcmp(key, "ms_yoffset") == 0) {
    lua_pushinteger(L, obj->ms_yoffset);
    return 1;
  }
  if (strcmp(key, "ms_LegalView.MinX") == 0) {
    lua_pushinteger(L, obj->ms_LegalView.MinX);
    return 1;
  }
  if (strcmp(key, "ms_LegalView.MinY") == 0) {
    lua_pushinteger(L, obj->ms_LegalView.MinY);
    return 1;
  }
  if (strcmp(key, "ms_LegalView.MaxX") == 0) {
    lua_pushinteger(L, obj->ms_LegalView.MaxX);
    return 1;
  }
  if (strcmp(key, "ms_LegalView.MaxY") == 0) {
    lua_pushinteger(L, obj->ms_LegalView.MaxY);
    return 1;
  }
  if (strcmp(key, "ms_LegalView") == 0) {
    struct Rectangle **ud = (struct Rectangle **)lua_newuserdata(L, sizeof(struct Rectangle *));
    *ud = (struct Rectangle*)&obj->ms_LegalView;
    luaL_getmetatable(L, "Rectangle");
    lua_setmetatable(L, -2);
    return 1;
  }
  // Unsupported ms_maxoscan LONG (*)(struct MonitorSpec *, struct Rectangle *, ULONG)
  if (strcmp(key, "ms_maxoscan") == 0) {
    return luaL_error(L, "Unsupported type LONG (*)(struct MonitorSpec *, struct Rectangle *, ULONG) for field ms_maxoscan");
  }
  // Unsupported ms_videoscan LONG (*)(struct MonitorSpec *, struct Rectangle *, ULONG)
  if (strcmp(key, "ms_videoscan") == 0) {
    return luaL_error(L, "Unsupported type LONG (*)(struct MonitorSpec *, struct Rectangle *, ULONG) for field ms_videoscan");
  }
  if (strcmp(key, "DeniseMinDisplayColumn") == 0) {
    lua_pushinteger(L, obj->DeniseMinDisplayColumn);
    return 1;
  }
  if (strcmp(key, "DisplayCompatible") == 0) {
    lua_pushinteger(L, obj->DisplayCompatible);
    return 1;
  }
  // Unsupported DisplayInfoDataBase.lh_Head struct Node *
  if (strcmp(key, "DisplayInfoDataBase.lh_Head") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field DisplayInfoDataBase.lh_Head");
  }
  // Unsupported DisplayInfoDataBase.lh_Tail struct Node *
  if (strcmp(key, "DisplayInfoDataBase.lh_Tail") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field DisplayInfoDataBase.lh_Tail");
  }
  // Unsupported DisplayInfoDataBase.lh_TailPred struct Node *
  if (strcmp(key, "DisplayInfoDataBase.lh_TailPred") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field DisplayInfoDataBase.lh_TailPred");
  }
  if (strcmp(key, "DisplayInfoDataBase.lh_Type") == 0) {
    lua_pushinteger(L, obj->DisplayInfoDataBase.lh_Type);
    return 1;
  }
  if (strcmp(key, "DisplayInfoDataBase.l_pad") == 0) {
    lua_pushinteger(L, obj->DisplayInfoDataBase.l_pad);
    return 1;
  }
  // Unsupported DisplayInfoDataBase struct List
  if (strcmp(key, "DisplayInfoDataBase") == 0) {
    return luaL_error(L, "Unsupported type struct List for field DisplayInfoDataBase");
  }
  // Unsupported DisplayInfoDataBaseSemaphore.ss_Link.ln_Succ struct Node *
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_Link.ln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field DisplayInfoDataBaseSemaphore.ss_Link.ln_Succ");
  }
  // Unsupported DisplayInfoDataBaseSemaphore.ss_Link.ln_Pred struct Node *
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_Link.ln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field DisplayInfoDataBaseSemaphore.ss_Link.ln_Pred");
  }
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_Link.ln_Type") == 0) {
    lua_pushinteger(L, obj->DisplayInfoDataBaseSemaphore.ss_Link.ln_Type);
    return 1;
  }
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_Link.ln_Pri") == 0) {
    lua_pushinteger(L, obj->DisplayInfoDataBaseSemaphore.ss_Link.ln_Pri);
    return 1;
  }
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_Link.ln_Name") == 0) {
    lua_pushstring(L, obj->DisplayInfoDataBaseSemaphore.ss_Link.ln_Name);
    return 1;
  }
  // Unsupported DisplayInfoDataBaseSemaphore.ss_Link struct Node
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_Link") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field DisplayInfoDataBaseSemaphore.ss_Link");
  }
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_NestCount") == 0) {
    lua_pushinteger(L, obj->DisplayInfoDataBaseSemaphore.ss_NestCount);
    return 1;
  }
  // Unsupported DisplayInfoDataBaseSemaphore.ss_WaitQueue.mlh_Head struct MinNode *
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_WaitQueue.mlh_Head") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode * for field DisplayInfoDataBaseSemaphore.ss_WaitQueue.mlh_Head");
  }
  // Unsupported DisplayInfoDataBaseSemaphore.ss_WaitQueue.mlh_Tail struct MinNode *
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_WaitQueue.mlh_Tail") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode * for field DisplayInfoDataBaseSemaphore.ss_WaitQueue.mlh_Tail");
  }
  // Unsupported DisplayInfoDataBaseSemaphore.ss_WaitQueue.mlh_TailPred struct MinNode *
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_WaitQueue.mlh_TailPred") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode * for field DisplayInfoDataBaseSemaphore.ss_WaitQueue.mlh_TailPred");
  }
  // Unsupported DisplayInfoDataBaseSemaphore.ss_WaitQueue struct MinList
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_WaitQueue") == 0) {
    return luaL_error(L, "Unsupported type struct MinList for field DisplayInfoDataBaseSemaphore.ss_WaitQueue");
  }
  // Unsupported DisplayInfoDataBaseSemaphore.ss_MultipleLink.sr_Link.mln_Succ struct MinNode *
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_MultipleLink.sr_Link.mln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode * for field DisplayInfoDataBaseSemaphore.ss_MultipleLink.sr_Link.mln_Succ");
  }
  // Unsupported DisplayInfoDataBaseSemaphore.ss_MultipleLink.sr_Link.mln_Pred struct MinNode *
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_MultipleLink.sr_Link.mln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode * for field DisplayInfoDataBaseSemaphore.ss_MultipleLink.sr_Link.mln_Pred");
  }
  // Unsupported DisplayInfoDataBaseSemaphore.ss_MultipleLink.sr_Link struct MinNode
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_MultipleLink.sr_Link") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode for field DisplayInfoDataBaseSemaphore.ss_MultipleLink.sr_Link");
  }
  // Unsupported DisplayInfoDataBaseSemaphore.ss_MultipleLink.sr_Waiter struct Task *
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_MultipleLink.sr_Waiter") == 0) {
    return luaL_error(L, "Unsupported type struct Task * for field DisplayInfoDataBaseSemaphore.ss_MultipleLink.sr_Waiter");
  }
  // Unsupported DisplayInfoDataBaseSemaphore.ss_MultipleLink struct SemaphoreRequest
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_MultipleLink") == 0) {
    return luaL_error(L, "Unsupported type struct SemaphoreRequest for field DisplayInfoDataBaseSemaphore.ss_MultipleLink");
  }
  // Unsupported DisplayInfoDataBaseSemaphore.ss_Owner struct Task *
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_Owner") == 0) {
    return luaL_error(L, "Unsupported type struct Task * for field DisplayInfoDataBaseSemaphore.ss_Owner");
  }
  if (strcmp(key, "DisplayInfoDataBaseSemaphore.ss_QueueCount") == 0) {
    lua_pushinteger(L, obj->DisplayInfoDataBaseSemaphore.ss_QueueCount);
    return 1;
  }
  // Unsupported DisplayInfoDataBaseSemaphore struct SignalSemaphore
  if (strcmp(key, "DisplayInfoDataBaseSemaphore") == 0) {
    return luaL_error(L, "Unsupported type struct SignalSemaphore for field DisplayInfoDataBaseSemaphore");
  }
  // Unsupported ms_MrgCop LONG (*)(struct View *)
  if (strcmp(key, "ms_MrgCop") == 0) {
    return luaL_error(L, "Unsupported type LONG (*)(struct View *) for field ms_MrgCop");
  }
  // Unsupported ms_LoadView LONG (*)(struct View *)
  if (strcmp(key, "ms_LoadView") == 0) {
    return luaL_error(L, "Unsupported type LONG (*)(struct View *) for field ms_LoadView");
  }
  // Unsupported ms_KillView LONG (*)(struct MonitorSpec *)
  if (strcmp(key, "ms_KillView") == 0) {
    return luaL_error(L, "Unsupported type LONG (*)(struct MonitorSpec *) for field ms_KillView");
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct MonitorSpec));
    return 1;
}

  return 0;
}

static void
_lua_gen_MonitorSpec_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "ms_Node.xln_Type");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "ms_Node.xln_Pri");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "ms_Node.xln_Name");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "ms_Node.xln_Subsystem");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "ms_Node.xln_Subtype");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "ms_Node.xln_Init");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "ms_Flags");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "ratioh");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "ratiov");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "total_rows");
  lua_rawseti(L, -2, 10);
  lua_pushstring(L, "total_colorclocks");
  lua_rawseti(L, -2, 11);
  lua_pushstring(L, "DeniseMaxDisplayColumn");
  lua_rawseti(L, -2, 12);
  lua_pushstring(L, "BeamCon0");
  lua_rawseti(L, -2, 13);
  lua_pushstring(L, "min_row");
  lua_rawseti(L, -2, 14);
  lua_pushstring(L, "ms_OpenCount");
  lua_rawseti(L, -2, 15);
  lua_pushstring(L, "ms_transform");
  lua_rawseti(L, -2, 16);
  lua_pushstring(L, "ms_translate");
  lua_rawseti(L, -2, 17);
  lua_pushstring(L, "ms_scale");
  lua_rawseti(L, -2, 18);
  lua_pushstring(L, "ms_xoffset");
  lua_rawseti(L, -2, 19);
  lua_pushstring(L, "ms_yoffset");
  lua_rawseti(L, -2, 20);
  lua_pushstring(L, "ms_LegalView.MinX");
  lua_rawseti(L, -2, 21);
  lua_pushstring(L, "ms_LegalView.MinY");
  lua_rawseti(L, -2, 22);
  lua_pushstring(L, "ms_LegalView.MaxX");
  lua_rawseti(L, -2, 23);
  lua_pushstring(L, "ms_LegalView.MaxY");
  lua_rawseti(L, -2, 24);
  lua_pushstring(L, "ms_maxoscan");
  lua_rawseti(L, -2, 25);
  lua_pushstring(L, "ms_videoscan");
  lua_rawseti(L, -2, 26);
  lua_pushstring(L, "DeniseMinDisplayColumn");
  lua_rawseti(L, -2, 27);
  lua_pushstring(L, "DisplayCompatible");
  lua_rawseti(L, -2, 28);
  lua_pushstring(L, "DisplayInfoDataBase.lh_Type");
  lua_rawseti(L, -2, 29);
  lua_pushstring(L, "DisplayInfoDataBase.l_pad");
  lua_rawseti(L, -2, 30);
  lua_pushstring(L, "DisplayInfoDataBaseSemaphore.ss_Link.ln_Type");
  lua_rawseti(L, -2, 31);
  lua_pushstring(L, "DisplayInfoDataBaseSemaphore.ss_Link.ln_Pri");
  lua_rawseti(L, -2, 32);
  lua_pushstring(L, "DisplayInfoDataBaseSemaphore.ss_Link.ln_Name");
  lua_rawseti(L, -2, 33);
  lua_pushstring(L, "DisplayInfoDataBaseSemaphore.ss_NestCount");
  lua_rawseti(L, -2, 34);
  lua_pushstring(L, "DisplayInfoDataBaseSemaphore.ss_QueueCount");
  lua_rawseti(L, -2, 35);
  lua_pushstring(L, "ms_MrgCop");
  lua_rawseti(L, -2, 36);
  lua_pushstring(L, "ms_LoadView");
  lua_rawseti(L, -2, 37);
  lua_pushstring(L, "ms_KillView");
  lua_rawseti(L, -2, 38);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_MonitorSpec(lua_State *L) {
  if (luaL_newmetatable(L, "MonitorSpec")) {
    lua_pushcfunction(L, _lua_gen_MonitorSpec_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_MonitorSpec_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_MonitorSpec_constructor);
    lua_setglobal(L, "MonitorSpec");
    _lua_gen_MonitorSpec_install_keys(L);
    lua_pushstring(L, "MonitorSpec");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

typedef struct {
  APTR* data;
  uint16_t count;
} lua_gen_wrapped_APTR_array_data_t;

static int _lua_gen_wrapped_APTR_array_ptr_method(lua_State* L) {
    lua_gen_wrapped_APTR_array_data_t* wrapper = luaL_checkudata(L, 1, "APTR_array_proxy");
    int index = luaL_checkinteger(L, 2);
    void* ptr = &wrapper->data[index - 1];
    lua_pushlightuserdata(L, ptr);
    return 1;
}
static int
_lua_gen_wrapped_APTR_array_index(lua_State* L)
{
  lua_gen_wrapped_APTR_array_data_t* wrapper = luaL_checkudata(L, 1, "APTR_array_proxy");
  if (lua_isinteger(L, 2)) {
    int index = lua_tointeger(L, 2);
    if (index < 1 || index > wrapper->count)
      return luaL_error(L, "index out of range (1..%d)", wrapper->count);
    lua_pushlightuserdata(L, wrapper->data[index - 1]);
    return 1;
  }

  // Not a numeric key? Try methods
  lua_getmetatable(L, 1);
  lua_getfield(L, -1, "__methods");
  lua_pushvalue(L, 2);
  lua_gettable(L, -2);
  return 1;
}

static int
_lua_gen_wrapped_APTR_array_newindex(lua_State* L)
{
  lua_gen_wrapped_APTR_array_data_t* wrapper = luaL_checkudata(L, 1, "APTR_array_proxy");
  if (!lua_isinteger(L, 2))
    return luaL_error(L, "only integer indices allowed");
  int index = lua_tointeger(L, 2);
  if (index < 1 || index > wrapper->count)
    return luaL_error(L, "index out of range (1..%d)", wrapper->count);
  APTR value = lua_touserdata(L,  3);
  wrapper->data[index - 1] = value;
  return 0;
}

static void
_lua_gen_push_APTR_array_proxy(lua_State *L,  APTR *array, int count)
{

  lua_gen_wrapped_APTR_array_data_t* wrapper = lua_newuserdata(L, sizeof(lua_gen_wrapped_APTR_array_data_t));
  wrapper->data = array;
  wrapper->count = count;

  if (luaL_newmetatable(L, "APTR_array_proxy")) {
    // Create method table
    lua_newtable(L);
    lua_pushcfunction(L, _lua_gen_wrapped_APTR_array_ptr_method);
    lua_setfield(L, -2, "ptr");
    lua_setfield(L, -2, "__methods");

    // __index handles both numeric and method lookup
    lua_pushcfunction(L, _lua_gen_wrapped_APTR_array_index);
    lua_setfield(L, -2, "__index");

    // __newindex for writing
    lua_pushcfunction(L, _lua_gen_wrapped_APTR_array_newindex);
    lua_setfield(L, -2, "__newindex");
  }

  lua_setmetatable(L, -2);  // assign to userdata

}
static int
_lua_gen_ViewPortExtra_newindex(lua_State *L)
{
  struct ViewPortExtra *obj = *(struct ViewPortExtra **)luaL_checkudata(L, 1, "ViewPortExtra");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  // Unsupported type n.xln_Succ struct Node
  if (strcmp(key, "n.xln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field n.xln_Succ");
  }
  // Unsupported type n.xln_Pred struct Node
  if (strcmp(key, "n.xln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field n.xln_Pred");
  }
  if (strcmp(key, "n.xln_Type") == 0) {
    obj->n.xln_Type = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "n.xln_Pri") == 0) {
    obj->n.xln_Pri = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "n.xln_Name") == 0) {
    obj->n.xln_Name = (char *)luaL_checkstring(L, 3);
    return 0;
  }
  if (strcmp(key, "n.xln_Subsystem") == 0) {
    obj->n.xln_Subsystem = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "n.xln_Subtype") == 0) {
    obj->n.xln_Subtype = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type n.xln_Library struct GfxBase
  if (strcmp(key, "n.xln_Library") == 0) {
    return luaL_error(L, "Unsupported type struct GfxBase for field n.xln_Library");
  }
  // Unsupported type n.xln_Init LONG ()(struct ExtendedNode , UWORD)
  if (strcmp(key, "n.xln_Init") == 0) {
    return luaL_error(L, "Unsupported type LONG ()(struct ExtendedNode , UWORD) for field n.xln_Init");
  }
  if (strcmp(key, "n") == 0) {
    // finder 0
    struct ExtendedNode *val = *(struct ExtendedNode **)luaL_checkudata(L, 3, "ExtendedNode");
    obj->n = *val;
    return 0;
  }
  if (strcmp(key, "ViewPort") == 0) {
    // finder 1
    //obj->ViewPort = *(struct ViewPort **)luaL_checkudata(L, 3, "ViewPort");
    obj->ViewPort = (struct ViewPort *)_lua_gen_checkViewPort(L, 3);
    return 0;
  }
  if (strcmp(key, "DisplayClip.MinX") == 0) {
    obj->DisplayClip.MinX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DisplayClip.MinY") == 0) {
    obj->DisplayClip.MinY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DisplayClip.MaxX") == 0) {
    obj->DisplayClip.MaxX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DisplayClip.MaxY") == 0) {
    obj->DisplayClip.MaxY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DisplayClip") == 0) {
    // finder 0
    struct Rectangle *val = *(struct Rectangle **)luaL_checkudata(L, 3, "Rectangle");
    obj->DisplayClip = *val;
    return 0;
  }
  if (strcmp(key, "VecTable") == 0) {
    obj->VecTable = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  // DriverData[2] proxied via the index
  if (strcmp(key, "Flags") == 0) {
    obj->Flags = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // Origin[2] proxied via the index
  if (strcmp(key, "cop1ptr") == 0) {
    obj->cop1ptr = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "cop2ptr") == 0) {
    obj->cop2ptr = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_ViewPortExtra_constructor(lua_State *L)
{
  // Allocate pointer-to-struct ViewPortExtra in userdata
  struct ViewPortExtra **objp = lua_newuserdata(L, sizeof(struct ViewPortExtra *));
  *objp = malloc(sizeof(struct ViewPortExtra));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct ViewPortExtra));

  // Set metatable
  luaL_getmetatable(L, "ViewPortExtra");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_ViewPortExtra_index(lua_State *L)
{
  struct ViewPortExtra *obj = *(struct ViewPortExtra **)luaL_checkudata(L, 1, "ViewPortExtra");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  // Unsupported n.xln_Succ struct Node *
  if (strcmp(key, "n.xln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field n.xln_Succ");
  }
  // Unsupported n.xln_Pred struct Node *
  if (strcmp(key, "n.xln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field n.xln_Pred");
  }
  if (strcmp(key, "n.xln_Type") == 0) {
    lua_pushinteger(L, obj->n.xln_Type);
    return 1;
  }
  if (strcmp(key, "n.xln_Pri") == 0) {
    lua_pushinteger(L, obj->n.xln_Pri);
    return 1;
  }
  if (strcmp(key, "n.xln_Name") == 0) {
    lua_pushstring(L, obj->n.xln_Name);
    return 1;
  }
  if (strcmp(key, "n.xln_Subsystem") == 0) {
    lua_pushinteger(L, obj->n.xln_Subsystem);
    return 1;
  }
  if (strcmp(key, "n.xln_Subtype") == 0) {
    lua_pushinteger(L, obj->n.xln_Subtype);
    return 1;
  }
  // Unsupported n.xln_Library struct GfxBase *
  if (strcmp(key, "n.xln_Library") == 0) {
    return luaL_error(L, "Unsupported type struct GfxBase * for field n.xln_Library");
  }
  // Unsupported n.xln_Init LONG (*)(struct ExtendedNode *, UWORD)
  if (strcmp(key, "n.xln_Init") == 0) {
    return luaL_error(L, "Unsupported type LONG (*)(struct ExtendedNode *, UWORD) for field n.xln_Init");
  }
  if (strcmp(key, "n") == 0) {
    struct ExtendedNode **ud = (struct ExtendedNode **)lua_newuserdata(L, sizeof(struct ExtendedNode *));
    *ud = (struct ExtendedNode*)&obj->n;
    luaL_getmetatable(L, "ExtendedNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "ViewPort") == 0) {
    struct ViewPort **ud = (struct ViewPort **)lua_newuserdata(L, sizeof(struct ViewPort *));
    *ud = (struct ViewPort*)obj->ViewPort;
    luaL_getmetatable(L, "ViewPort");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "DisplayClip.MinX") == 0) {
    lua_pushinteger(L, obj->DisplayClip.MinX);
    return 1;
  }
  if (strcmp(key, "DisplayClip.MinY") == 0) {
    lua_pushinteger(L, obj->DisplayClip.MinY);
    return 1;
  }
  if (strcmp(key, "DisplayClip.MaxX") == 0) {
    lua_pushinteger(L, obj->DisplayClip.MaxX);
    return 1;
  }
  if (strcmp(key, "DisplayClip.MaxY") == 0) {
    lua_pushinteger(L, obj->DisplayClip.MaxY);
    return 1;
  }
  if (strcmp(key, "DisplayClip") == 0) {
    struct Rectangle **ud = (struct Rectangle **)lua_newuserdata(L, sizeof(struct Rectangle *));
    *ud = (struct Rectangle*)&obj->DisplayClip;
    luaL_getmetatable(L, "Rectangle");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "VecTable") == 0) {
    lua_pushlightuserdata(L, obj->VecTable);
    return 1;
  }
  if (strcmp(key, "DriverData") == 0) {
    _lua_gen_push_APTR_array_proxy(L, obj->DriverData, 2);
    return 1;
  }
  if (strcmp(key, "Flags") == 0) {
    lua_pushinteger(L, obj->Flags);
    return 1;
  }
  if (strcmp(key, "Origin") == 0) {
     return luaL_error(L, "Unsupported array type Point");
  }
  if (strcmp(key, "cop1ptr") == 0) {
    lua_pushinteger(L, obj->cop1ptr);
    return 1;
  }
  if (strcmp(key, "cop2ptr") == 0) {
    lua_pushinteger(L, obj->cop2ptr);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct ViewPortExtra));
    return 1;
}

  return 0;
}

static void
_lua_gen_ViewPortExtra_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "n.xln_Type");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "n.xln_Pri");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "n.xln_Name");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "n.xln_Subsystem");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "n.xln_Subtype");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "n.xln_Init");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "DisplayClip.MinX");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "DisplayClip.MinY");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "DisplayClip.MaxX");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "DisplayClip.MaxY");
  lua_rawseti(L, -2, 10);
  lua_pushstring(L, "VecTable");
  lua_rawseti(L, -2, 11);
  lua_pushstring(L, "DriverData");
  lua_rawseti(L, -2, 12);
  lua_pushstring(L, "Flags");
  lua_rawseti(L, -2, 13);
  lua_pushstring(L, "Origin");
  lua_rawseti(L, -2, 14);
  lua_pushstring(L, "cop1ptr");
  lua_rawseti(L, -2, 15);
  lua_pushstring(L, "cop2ptr");
  lua_rawseti(L, -2, 16);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_ViewPortExtra(lua_State *L) {
  if (luaL_newmetatable(L, "ViewPortExtra")) {
    lua_pushcfunction(L, _lua_gen_ViewPortExtra_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_ViewPortExtra_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_ViewPortExtra_constructor);
    lua_setglobal(L, "ViewPortExtra");
    _lua_gen_ViewPortExtra_install_keys(L);
    lua_pushstring(L, "ViewPortExtra");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_PaletteExtra_newindex(lua_State *L)
{
  struct PaletteExtra *obj = *(struct PaletteExtra **)luaL_checkudata(L, 1, "PaletteExtra");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  // Unsupported type pe_Semaphore.ss_Link.ln_Succ struct Node
  if (strcmp(key, "pe_Semaphore.ss_Link.ln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field pe_Semaphore.ss_Link.ln_Succ");
  }
  // Unsupported type pe_Semaphore.ss_Link.ln_Pred struct Node
  if (strcmp(key, "pe_Semaphore.ss_Link.ln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field pe_Semaphore.ss_Link.ln_Pred");
  }
  if (strcmp(key, "pe_Semaphore.ss_Link.ln_Type") == 0) {
    obj->pe_Semaphore.ss_Link.ln_Type = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "pe_Semaphore.ss_Link.ln_Pri") == 0) {
    obj->pe_Semaphore.ss_Link.ln_Pri = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "pe_Semaphore.ss_Link.ln_Name") == 0) {
    obj->pe_Semaphore.ss_Link.ln_Name = (char *)luaL_checkstring(L, 3);
    return 0;
  }
  // Unsupported type pe_Semaphore.ss_Link struct Node
  if (strcmp(key, "pe_Semaphore.ss_Link") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field pe_Semaphore.ss_Link");
  }
  if (strcmp(key, "pe_Semaphore.ss_NestCount") == 0) {
    obj->pe_Semaphore.ss_NestCount = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type pe_Semaphore.ss_WaitQueue.mlh_Head struct MinNode
  if (strcmp(key, "pe_Semaphore.ss_WaitQueue.mlh_Head") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode for field pe_Semaphore.ss_WaitQueue.mlh_Head");
  }
  // Unsupported type pe_Semaphore.ss_WaitQueue.mlh_Tail struct MinNode
  if (strcmp(key, "pe_Semaphore.ss_WaitQueue.mlh_Tail") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode for field pe_Semaphore.ss_WaitQueue.mlh_Tail");
  }
  // Unsupported type pe_Semaphore.ss_WaitQueue.mlh_TailPred struct MinNode
  if (strcmp(key, "pe_Semaphore.ss_WaitQueue.mlh_TailPred") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode for field pe_Semaphore.ss_WaitQueue.mlh_TailPred");
  }
  // Unsupported type pe_Semaphore.ss_WaitQueue struct MinList
  if (strcmp(key, "pe_Semaphore.ss_WaitQueue") == 0) {
    return luaL_error(L, "Unsupported type struct MinList for field pe_Semaphore.ss_WaitQueue");
  }
  // Unsupported type pe_Semaphore.ss_MultipleLink.sr_Link.mln_Succ struct MinNode
  if (strcmp(key, "pe_Semaphore.ss_MultipleLink.sr_Link.mln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode for field pe_Semaphore.ss_MultipleLink.sr_Link.mln_Succ");
  }
  // Unsupported type pe_Semaphore.ss_MultipleLink.sr_Link.mln_Pred struct MinNode
  if (strcmp(key, "pe_Semaphore.ss_MultipleLink.sr_Link.mln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode for field pe_Semaphore.ss_MultipleLink.sr_Link.mln_Pred");
  }
  // Unsupported type pe_Semaphore.ss_MultipleLink.sr_Link struct MinNode
  if (strcmp(key, "pe_Semaphore.ss_MultipleLink.sr_Link") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode for field pe_Semaphore.ss_MultipleLink.sr_Link");
  }
  // Unsupported type pe_Semaphore.ss_MultipleLink.sr_Waiter struct Task
  if (strcmp(key, "pe_Semaphore.ss_MultipleLink.sr_Waiter") == 0) {
    return luaL_error(L, "Unsupported type struct Task for field pe_Semaphore.ss_MultipleLink.sr_Waiter");
  }
  // Unsupported type pe_Semaphore.ss_MultipleLink struct SemaphoreRequest
  if (strcmp(key, "pe_Semaphore.ss_MultipleLink") == 0) {
    return luaL_error(L, "Unsupported type struct SemaphoreRequest for field pe_Semaphore.ss_MultipleLink");
  }
  // Unsupported type pe_Semaphore.ss_Owner struct Task
  if (strcmp(key, "pe_Semaphore.ss_Owner") == 0) {
    return luaL_error(L, "Unsupported type struct Task for field pe_Semaphore.ss_Owner");
  }
  if (strcmp(key, "pe_Semaphore.ss_QueueCount") == 0) {
    obj->pe_Semaphore.ss_QueueCount = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type pe_Semaphore struct SignalSemaphore
  if (strcmp(key, "pe_Semaphore") == 0) {
    return luaL_error(L, "Unsupported type struct SignalSemaphore for field pe_Semaphore");
  }
  if (strcmp(key, "pe_FirstFree") == 0) {
    obj->pe_FirstFree = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "pe_NFree") == 0) {
    obj->pe_NFree = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "pe_FirstShared") == 0) {
    obj->pe_FirstShared = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "pe_NShared") == 0) {
    obj->pe_NShared = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "pe_RefCnt") == 0) {
    obj->pe_RefCnt = (UBYTE *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "pe_AllocList") == 0) {
    obj->pe_AllocList = (UBYTE *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "pe_ViewPort") == 0) {
    // finder 1
    //obj->pe_ViewPort = *(struct ViewPort **)luaL_checkudata(L, 3, "ViewPort");
    obj->pe_ViewPort = (struct ViewPort *)_lua_gen_checkViewPort(L, 3);
    return 0;
  }
  if (strcmp(key, "pe_SharableColors") == 0) {
    obj->pe_SharableColors = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_PaletteExtra_constructor(lua_State *L)
{
  // Allocate pointer-to-struct PaletteExtra in userdata
  struct PaletteExtra **objp = lua_newuserdata(L, sizeof(struct PaletteExtra *));
  *objp = malloc(sizeof(struct PaletteExtra));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct PaletteExtra));

  // Set metatable
  luaL_getmetatable(L, "PaletteExtra");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_PaletteExtra_index(lua_State *L)
{
  struct PaletteExtra *obj = *(struct PaletteExtra **)luaL_checkudata(L, 1, "PaletteExtra");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  // Unsupported pe_Semaphore.ss_Link.ln_Succ struct Node *
  if (strcmp(key, "pe_Semaphore.ss_Link.ln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field pe_Semaphore.ss_Link.ln_Succ");
  }
  // Unsupported pe_Semaphore.ss_Link.ln_Pred struct Node *
  if (strcmp(key, "pe_Semaphore.ss_Link.ln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field pe_Semaphore.ss_Link.ln_Pred");
  }
  if (strcmp(key, "pe_Semaphore.ss_Link.ln_Type") == 0) {
    lua_pushinteger(L, obj->pe_Semaphore.ss_Link.ln_Type);
    return 1;
  }
  if (strcmp(key, "pe_Semaphore.ss_Link.ln_Pri") == 0) {
    lua_pushinteger(L, obj->pe_Semaphore.ss_Link.ln_Pri);
    return 1;
  }
  if (strcmp(key, "pe_Semaphore.ss_Link.ln_Name") == 0) {
    lua_pushstring(L, obj->pe_Semaphore.ss_Link.ln_Name);
    return 1;
  }
  // Unsupported pe_Semaphore.ss_Link struct Node
  if (strcmp(key, "pe_Semaphore.ss_Link") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field pe_Semaphore.ss_Link");
  }
  if (strcmp(key, "pe_Semaphore.ss_NestCount") == 0) {
    lua_pushinteger(L, obj->pe_Semaphore.ss_NestCount);
    return 1;
  }
  // Unsupported pe_Semaphore.ss_WaitQueue.mlh_Head struct MinNode *
  if (strcmp(key, "pe_Semaphore.ss_WaitQueue.mlh_Head") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode * for field pe_Semaphore.ss_WaitQueue.mlh_Head");
  }
  // Unsupported pe_Semaphore.ss_WaitQueue.mlh_Tail struct MinNode *
  if (strcmp(key, "pe_Semaphore.ss_WaitQueue.mlh_Tail") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode * for field pe_Semaphore.ss_WaitQueue.mlh_Tail");
  }
  // Unsupported pe_Semaphore.ss_WaitQueue.mlh_TailPred struct MinNode *
  if (strcmp(key, "pe_Semaphore.ss_WaitQueue.mlh_TailPred") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode * for field pe_Semaphore.ss_WaitQueue.mlh_TailPred");
  }
  // Unsupported pe_Semaphore.ss_WaitQueue struct MinList
  if (strcmp(key, "pe_Semaphore.ss_WaitQueue") == 0) {
    return luaL_error(L, "Unsupported type struct MinList for field pe_Semaphore.ss_WaitQueue");
  }
  // Unsupported pe_Semaphore.ss_MultipleLink.sr_Link.mln_Succ struct MinNode *
  if (strcmp(key, "pe_Semaphore.ss_MultipleLink.sr_Link.mln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode * for field pe_Semaphore.ss_MultipleLink.sr_Link.mln_Succ");
  }
  // Unsupported pe_Semaphore.ss_MultipleLink.sr_Link.mln_Pred struct MinNode *
  if (strcmp(key, "pe_Semaphore.ss_MultipleLink.sr_Link.mln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode * for field pe_Semaphore.ss_MultipleLink.sr_Link.mln_Pred");
  }
  // Unsupported pe_Semaphore.ss_MultipleLink.sr_Link struct MinNode
  if (strcmp(key, "pe_Semaphore.ss_MultipleLink.sr_Link") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode for field pe_Semaphore.ss_MultipleLink.sr_Link");
  }
  // Unsupported pe_Semaphore.ss_MultipleLink.sr_Waiter struct Task *
  if (strcmp(key, "pe_Semaphore.ss_MultipleLink.sr_Waiter") == 0) {
    return luaL_error(L, "Unsupported type struct Task * for field pe_Semaphore.ss_MultipleLink.sr_Waiter");
  }
  // Unsupported pe_Semaphore.ss_MultipleLink struct SemaphoreRequest
  if (strcmp(key, "pe_Semaphore.ss_MultipleLink") == 0) {
    return luaL_error(L, "Unsupported type struct SemaphoreRequest for field pe_Semaphore.ss_MultipleLink");
  }
  // Unsupported pe_Semaphore.ss_Owner struct Task *
  if (strcmp(key, "pe_Semaphore.ss_Owner") == 0) {
    return luaL_error(L, "Unsupported type struct Task * for field pe_Semaphore.ss_Owner");
  }
  if (strcmp(key, "pe_Semaphore.ss_QueueCount") == 0) {
    lua_pushinteger(L, obj->pe_Semaphore.ss_QueueCount);
    return 1;
  }
  // Unsupported pe_Semaphore struct SignalSemaphore
  if (strcmp(key, "pe_Semaphore") == 0) {
    return luaL_error(L, "Unsupported type struct SignalSemaphore for field pe_Semaphore");
  }
  if (strcmp(key, "pe_FirstFree") == 0) {
    lua_pushinteger(L, obj->pe_FirstFree);
    return 1;
  }
  if (strcmp(key, "pe_NFree") == 0) {
    lua_pushinteger(L, obj->pe_NFree);
    return 1;
  }
  if (strcmp(key, "pe_FirstShared") == 0) {
    lua_pushinteger(L, obj->pe_FirstShared);
    return 1;
  }
  if (strcmp(key, "pe_NShared") == 0) {
    lua_pushinteger(L, obj->pe_NShared);
    return 1;
  }
  if (strcmp(key, "pe_RefCnt") == 0) {
    lua_pushlightuserdata(L, obj->pe_RefCnt);
    return 1;
  }
  if (strcmp(key, "pe_AllocList") == 0) {
    lua_pushlightuserdata(L, obj->pe_AllocList);
    return 1;
  }
  if (strcmp(key, "pe_ViewPort") == 0) {
    struct ViewPort **ud = (struct ViewPort **)lua_newuserdata(L, sizeof(struct ViewPort *));
    *ud = (struct ViewPort*)obj->pe_ViewPort;
    luaL_getmetatable(L, "ViewPort");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "pe_SharableColors") == 0) {
    lua_pushinteger(L, obj->pe_SharableColors);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct PaletteExtra));
    return 1;
}

  return 0;
}

static void
_lua_gen_PaletteExtra_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "pe_Semaphore.ss_Link.ln_Type");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "pe_Semaphore.ss_Link.ln_Pri");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "pe_Semaphore.ss_Link.ln_Name");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "pe_Semaphore.ss_NestCount");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "pe_Semaphore.ss_QueueCount");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "pe_FirstFree");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "pe_NFree");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "pe_FirstShared");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "pe_NShared");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "pe_RefCnt");
  lua_rawseti(L, -2, 10);
  lua_pushstring(L, "pe_AllocList");
  lua_rawseti(L, -2, 11);
  lua_pushstring(L, "pe_SharableColors");
  lua_rawseti(L, -2, 12);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_PaletteExtra(lua_State *L) {
  if (luaL_newmetatable(L, "PaletteExtra")) {
    lua_pushcfunction(L, _lua_gen_PaletteExtra_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_PaletteExtra_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_PaletteExtra_constructor);
    lua_setglobal(L, "PaletteExtra");
    _lua_gen_PaletteExtra_install_keys(L);
    lua_pushstring(L, "PaletteExtra");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_DBufInfo_newindex(lua_State *L)
{
  struct DBufInfo *obj = *(struct DBufInfo **)luaL_checkudata(L, 1, "DBufInfo");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "dbi_Link1") == 0) {
    obj->dbi_Link1 = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_Count1") == 0) {
    obj->dbi_Count1 = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type dbi_SafeMessage.mn_Node.ln_Succ struct Node
  if (strcmp(key, "dbi_SafeMessage.mn_Node.ln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field dbi_SafeMessage.mn_Node.ln_Succ");
  }
  // Unsupported type dbi_SafeMessage.mn_Node.ln_Pred struct Node
  if (strcmp(key, "dbi_SafeMessage.mn_Node.ln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field dbi_SafeMessage.mn_Node.ln_Pred");
  }
  if (strcmp(key, "dbi_SafeMessage.mn_Node.ln_Type") == 0) {
    obj->dbi_SafeMessage.mn_Node.ln_Type = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_SafeMessage.mn_Node.ln_Pri") == 0) {
    obj->dbi_SafeMessage.mn_Node.ln_Pri = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_SafeMessage.mn_Node.ln_Name") == 0) {
    obj->dbi_SafeMessage.mn_Node.ln_Name = (char *)luaL_checkstring(L, 3);
    return 0;
  }
  // Unsupported type dbi_SafeMessage.mn_Node struct Node
  if (strcmp(key, "dbi_SafeMessage.mn_Node") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field dbi_SafeMessage.mn_Node");
  }
  // Unsupported type dbi_SafeMessage.mn_ReplyPort struct MsgPort
  if (strcmp(key, "dbi_SafeMessage.mn_ReplyPort") == 0) {
    return luaL_error(L, "Unsupported type struct MsgPort for field dbi_SafeMessage.mn_ReplyPort");
  }
  if (strcmp(key, "dbi_SafeMessage.mn_Length") == 0) {
    obj->dbi_SafeMessage.mn_Length = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type dbi_SafeMessage struct Message
  if (strcmp(key, "dbi_SafeMessage") == 0) {
    return luaL_error(L, "Unsupported type struct Message for field dbi_SafeMessage");
  }
  if (strcmp(key, "dbi_UserData1") == 0) {
    obj->dbi_UserData1 = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_Link2") == 0) {
    obj->dbi_Link2 = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_Count2") == 0) {
    obj->dbi_Count2 = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type dbi_DispMessage.mn_Node.ln_Succ struct Node
  if (strcmp(key, "dbi_DispMessage.mn_Node.ln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field dbi_DispMessage.mn_Node.ln_Succ");
  }
  // Unsupported type dbi_DispMessage.mn_Node.ln_Pred struct Node
  if (strcmp(key, "dbi_DispMessage.mn_Node.ln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field dbi_DispMessage.mn_Node.ln_Pred");
  }
  if (strcmp(key, "dbi_DispMessage.mn_Node.ln_Type") == 0) {
    obj->dbi_DispMessage.mn_Node.ln_Type = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_DispMessage.mn_Node.ln_Pri") == 0) {
    obj->dbi_DispMessage.mn_Node.ln_Pri = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_DispMessage.mn_Node.ln_Name") == 0) {
    obj->dbi_DispMessage.mn_Node.ln_Name = (char *)luaL_checkstring(L, 3);
    return 0;
  }
  // Unsupported type dbi_DispMessage.mn_Node struct Node
  if (strcmp(key, "dbi_DispMessage.mn_Node") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field dbi_DispMessage.mn_Node");
  }
  // Unsupported type dbi_DispMessage.mn_ReplyPort struct MsgPort
  if (strcmp(key, "dbi_DispMessage.mn_ReplyPort") == 0) {
    return luaL_error(L, "Unsupported type struct MsgPort for field dbi_DispMessage.mn_ReplyPort");
  }
  if (strcmp(key, "dbi_DispMessage.mn_Length") == 0) {
    obj->dbi_DispMessage.mn_Length = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type dbi_DispMessage struct Message
  if (strcmp(key, "dbi_DispMessage") == 0) {
    return luaL_error(L, "Unsupported type struct Message for field dbi_DispMessage");
  }
  if (strcmp(key, "dbi_UserData2") == 0) {
    obj->dbi_UserData2 = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_MatchLong") == 0) {
    obj->dbi_MatchLong = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_CopPtr1") == 0) {
    obj->dbi_CopPtr1 = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_CopPtr2") == 0) {
    obj->dbi_CopPtr2 = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_CopPtr3") == 0) {
    obj->dbi_CopPtr3 = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_BeamPos1") == 0) {
    obj->dbi_BeamPos1 = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_BeamPos2") == 0) {
    obj->dbi_BeamPos2 = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_DBufInfo_constructor(lua_State *L)
{
  // Allocate pointer-to-struct DBufInfo in userdata
  struct DBufInfo **objp = lua_newuserdata(L, sizeof(struct DBufInfo *));
  *objp = malloc(sizeof(struct DBufInfo));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct DBufInfo));

  // Set metatable
  luaL_getmetatable(L, "DBufInfo");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_DBufInfo_index(lua_State *L)
{
  struct DBufInfo *obj = *(struct DBufInfo **)luaL_checkudata(L, 1, "DBufInfo");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "dbi_Link1") == 0) {
    lua_pushlightuserdata(L, obj->dbi_Link1);
    return 1;
  }
  if (strcmp(key, "dbi_Count1") == 0) {
    lua_pushinteger(L, obj->dbi_Count1);
    return 1;
  }
  // Unsupported dbi_SafeMessage.mn_Node.ln_Succ struct Node *
  if (strcmp(key, "dbi_SafeMessage.mn_Node.ln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field dbi_SafeMessage.mn_Node.ln_Succ");
  }
  // Unsupported dbi_SafeMessage.mn_Node.ln_Pred struct Node *
  if (strcmp(key, "dbi_SafeMessage.mn_Node.ln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field dbi_SafeMessage.mn_Node.ln_Pred");
  }
  if (strcmp(key, "dbi_SafeMessage.mn_Node.ln_Type") == 0) {
    lua_pushinteger(L, obj->dbi_SafeMessage.mn_Node.ln_Type);
    return 1;
  }
  if (strcmp(key, "dbi_SafeMessage.mn_Node.ln_Pri") == 0) {
    lua_pushinteger(L, obj->dbi_SafeMessage.mn_Node.ln_Pri);
    return 1;
  }
  if (strcmp(key, "dbi_SafeMessage.mn_Node.ln_Name") == 0) {
    lua_pushstring(L, obj->dbi_SafeMessage.mn_Node.ln_Name);
    return 1;
  }
  // Unsupported dbi_SafeMessage.mn_Node struct Node
  if (strcmp(key, "dbi_SafeMessage.mn_Node") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field dbi_SafeMessage.mn_Node");
  }
  // Unsupported dbi_SafeMessage.mn_ReplyPort struct MsgPort *
  if (strcmp(key, "dbi_SafeMessage.mn_ReplyPort") == 0) {
    return luaL_error(L, "Unsupported type struct MsgPort * for field dbi_SafeMessage.mn_ReplyPort");
  }
  if (strcmp(key, "dbi_SafeMessage.mn_Length") == 0) {
    lua_pushinteger(L, obj->dbi_SafeMessage.mn_Length);
    return 1;
  }
  // Unsupported dbi_SafeMessage struct Message
  if (strcmp(key, "dbi_SafeMessage") == 0) {
    return luaL_error(L, "Unsupported type struct Message for field dbi_SafeMessage");
  }
  if (strcmp(key, "dbi_UserData1") == 0) {
    lua_pushlightuserdata(L, obj->dbi_UserData1);
    return 1;
  }
  if (strcmp(key, "dbi_Link2") == 0) {
    lua_pushlightuserdata(L, obj->dbi_Link2);
    return 1;
  }
  if (strcmp(key, "dbi_Count2") == 0) {
    lua_pushinteger(L, obj->dbi_Count2);
    return 1;
  }
  // Unsupported dbi_DispMessage.mn_Node.ln_Succ struct Node *
  if (strcmp(key, "dbi_DispMessage.mn_Node.ln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field dbi_DispMessage.mn_Node.ln_Succ");
  }
  // Unsupported dbi_DispMessage.mn_Node.ln_Pred struct Node *
  if (strcmp(key, "dbi_DispMessage.mn_Node.ln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field dbi_DispMessage.mn_Node.ln_Pred");
  }
  if (strcmp(key, "dbi_DispMessage.mn_Node.ln_Type") == 0) {
    lua_pushinteger(L, obj->dbi_DispMessage.mn_Node.ln_Type);
    return 1;
  }
  if (strcmp(key, "dbi_DispMessage.mn_Node.ln_Pri") == 0) {
    lua_pushinteger(L, obj->dbi_DispMessage.mn_Node.ln_Pri);
    return 1;
  }
  if (strcmp(key, "dbi_DispMessage.mn_Node.ln_Name") == 0) {
    lua_pushstring(L, obj->dbi_DispMessage.mn_Node.ln_Name);
    return 1;
  }
  // Unsupported dbi_DispMessage.mn_Node struct Node
  if (strcmp(key, "dbi_DispMessage.mn_Node") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field dbi_DispMessage.mn_Node");
  }
  // Unsupported dbi_DispMessage.mn_ReplyPort struct MsgPort *
  if (strcmp(key, "dbi_DispMessage.mn_ReplyPort") == 0) {
    return luaL_error(L, "Unsupported type struct MsgPort * for field dbi_DispMessage.mn_ReplyPort");
  }
  if (strcmp(key, "dbi_DispMessage.mn_Length") == 0) {
    lua_pushinteger(L, obj->dbi_DispMessage.mn_Length);
    return 1;
  }
  // Unsupported dbi_DispMessage struct Message
  if (strcmp(key, "dbi_DispMessage") == 0) {
    return luaL_error(L, "Unsupported type struct Message for field dbi_DispMessage");
  }
  if (strcmp(key, "dbi_UserData2") == 0) {
    lua_pushlightuserdata(L, obj->dbi_UserData2);
    return 1;
  }
  if (strcmp(key, "dbi_MatchLong") == 0) {
    lua_pushinteger(L, obj->dbi_MatchLong);
    return 1;
  }
  if (strcmp(key, "dbi_CopPtr1") == 0) {
    lua_pushlightuserdata(L, obj->dbi_CopPtr1);
    return 1;
  }
  if (strcmp(key, "dbi_CopPtr2") == 0) {
    lua_pushlightuserdata(L, obj->dbi_CopPtr2);
    return 1;
  }
  if (strcmp(key, "dbi_CopPtr3") == 0) {
    lua_pushlightuserdata(L, obj->dbi_CopPtr3);
    return 1;
  }
  if (strcmp(key, "dbi_BeamPos1") == 0) {
    lua_pushinteger(L, obj->dbi_BeamPos1);
    return 1;
  }
  if (strcmp(key, "dbi_BeamPos2") == 0) {
    lua_pushinteger(L, obj->dbi_BeamPos2);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct DBufInfo));
    return 1;
}

  return 0;
}

static void
_lua_gen_DBufInfo_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "dbi_Link1");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "dbi_Count1");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "dbi_SafeMessage.mn_Node.ln_Type");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "dbi_SafeMessage.mn_Node.ln_Pri");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "dbi_SafeMessage.mn_Node.ln_Name");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "dbi_SafeMessage.mn_Length");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "dbi_UserData1");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "dbi_Link2");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "dbi_Count2");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "dbi_DispMessage.mn_Node.ln_Type");
  lua_rawseti(L, -2, 10);
  lua_pushstring(L, "dbi_DispMessage.mn_Node.ln_Pri");
  lua_rawseti(L, -2, 11);
  lua_pushstring(L, "dbi_DispMessage.mn_Node.ln_Name");
  lua_rawseti(L, -2, 12);
  lua_pushstring(L, "dbi_DispMessage.mn_Length");
  lua_rawseti(L, -2, 13);
  lua_pushstring(L, "dbi_UserData2");
  lua_rawseti(L, -2, 14);
  lua_pushstring(L, "dbi_MatchLong");
  lua_rawseti(L, -2, 15);
  lua_pushstring(L, "dbi_CopPtr1");
  lua_rawseti(L, -2, 16);
  lua_pushstring(L, "dbi_CopPtr2");
  lua_rawseti(L, -2, 17);
  lua_pushstring(L, "dbi_CopPtr3");
  lua_rawseti(L, -2, 18);
  lua_pushstring(L, "dbi_BeamPos1");
  lua_rawseti(L, -2, 19);
  lua_pushstring(L, "dbi_BeamPos2");
  lua_rawseti(L, -2, 20);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_DBufInfo(lua_State *L) {
  if (luaL_newmetatable(L, "DBufInfo")) {
    lua_pushcfunction(L, _lua_gen_DBufInfo_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_DBufInfo_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_DBufInfo_constructor);
    lua_setglobal(L, "DBufInfo");
    _lua_gen_DBufInfo_install_keys(L);
    lua_pushstring(L, "DBufInfo");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_SpecialMonitor_newindex(lua_State *L)
{
  struct SpecialMonitor *obj = *(struct SpecialMonitor **)luaL_checkudata(L, 1, "SpecialMonitor");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  // Unsupported type spm_Node.xln_Succ struct Node
  if (strcmp(key, "spm_Node.xln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field spm_Node.xln_Succ");
  }
  // Unsupported type spm_Node.xln_Pred struct Node
  if (strcmp(key, "spm_Node.xln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field spm_Node.xln_Pred");
  }
  if (strcmp(key, "spm_Node.xln_Type") == 0) {
    obj->spm_Node.xln_Type = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "spm_Node.xln_Pri") == 0) {
    obj->spm_Node.xln_Pri = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "spm_Node.xln_Name") == 0) {
    obj->spm_Node.xln_Name = (char *)luaL_checkstring(L, 3);
    return 0;
  }
  if (strcmp(key, "spm_Node.xln_Subsystem") == 0) {
    obj->spm_Node.xln_Subsystem = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "spm_Node.xln_Subtype") == 0) {
    obj->spm_Node.xln_Subtype = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type spm_Node.xln_Library struct GfxBase
  if (strcmp(key, "spm_Node.xln_Library") == 0) {
    return luaL_error(L, "Unsupported type struct GfxBase for field spm_Node.xln_Library");
  }
  // Unsupported type spm_Node.xln_Init LONG ()(struct ExtendedNode , UWORD)
  if (strcmp(key, "spm_Node.xln_Init") == 0) {
    return luaL_error(L, "Unsupported type LONG ()(struct ExtendedNode , UWORD) for field spm_Node.xln_Init");
  }
  if (strcmp(key, "spm_Node") == 0) {
    // finder 0
    struct ExtendedNode *val = *(struct ExtendedNode **)luaL_checkudata(L, 3, "ExtendedNode");
    obj->spm_Node = *val;
    return 0;
  }
  if (strcmp(key, "spm_Flags") == 0) {
    obj->spm_Flags = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type do_monitor LONG ()(struct MonitorSpec )
  if (strcmp(key, "do_monitor") == 0) {
    return luaL_error(L, "Unsupported type LONG ()(struct MonitorSpec ) for field do_monitor");
  }
  // Unsupported type reserved1 LONG ()()
  if (strcmp(key, "reserved1") == 0) {
    return luaL_error(L, "Unsupported type LONG ()() for field reserved1");
  }
  // Unsupported type reserved2 LONG ()()
  if (strcmp(key, "reserved2") == 0) {
    return luaL_error(L, "Unsupported type LONG ()() for field reserved2");
  }
  // Unsupported type reserved3 LONG ()()
  if (strcmp(key, "reserved3") == 0) {
    return luaL_error(L, "Unsupported type LONG ()() for field reserved3");
  }
  if (strcmp(key, "hblank.asi_Start") == 0) {
    obj->hblank.asi_Start = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "hblank.asi_Stop") == 0) {
    obj->hblank.asi_Stop = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "hblank") == 0) {
    // finder 0
    struct AnalogSignalInterval *val = *(struct AnalogSignalInterval **)luaL_checkudata(L, 3, "AnalogSignalInterval");
    obj->hblank = *val;
    return 0;
  }
  if (strcmp(key, "vblank.asi_Start") == 0) {
    obj->vblank.asi_Start = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "vblank.asi_Stop") == 0) {
    obj->vblank.asi_Stop = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "vblank") == 0) {
    // finder 0
    struct AnalogSignalInterval *val = *(struct AnalogSignalInterval **)luaL_checkudata(L, 3, "AnalogSignalInterval");
    obj->vblank = *val;
    return 0;
  }
  if (strcmp(key, "hsync.asi_Start") == 0) {
    obj->hsync.asi_Start = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "hsync.asi_Stop") == 0) {
    obj->hsync.asi_Stop = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "hsync") == 0) {
    // finder 0
    struct AnalogSignalInterval *val = *(struct AnalogSignalInterval **)luaL_checkudata(L, 3, "AnalogSignalInterval");
    obj->hsync = *val;
    return 0;
  }
  if (strcmp(key, "vsync.asi_Start") == 0) {
    obj->vsync.asi_Start = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "vsync.asi_Stop") == 0) {
    obj->vsync.asi_Stop = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "vsync") == 0) {
    // finder 0
    struct AnalogSignalInterval *val = *(struct AnalogSignalInterval **)luaL_checkudata(L, 3, "AnalogSignalInterval");
    obj->vsync = *val;
    return 0;
  }
  return 0;
}


static int
_lua_SpecialMonitor_constructor(lua_State *L)
{
  // Allocate pointer-to-struct SpecialMonitor in userdata
  struct SpecialMonitor **objp = lua_newuserdata(L, sizeof(struct SpecialMonitor *));
  *objp = malloc(sizeof(struct SpecialMonitor));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct SpecialMonitor));

  // Set metatable
  luaL_getmetatable(L, "SpecialMonitor");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_SpecialMonitor_index(lua_State *L)
{
  struct SpecialMonitor *obj = *(struct SpecialMonitor **)luaL_checkudata(L, 1, "SpecialMonitor");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  // Unsupported spm_Node.xln_Succ struct Node *
  if (strcmp(key, "spm_Node.xln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field spm_Node.xln_Succ");
  }
  // Unsupported spm_Node.xln_Pred struct Node *
  if (strcmp(key, "spm_Node.xln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field spm_Node.xln_Pred");
  }
  if (strcmp(key, "spm_Node.xln_Type") == 0) {
    lua_pushinteger(L, obj->spm_Node.xln_Type);
    return 1;
  }
  if (strcmp(key, "spm_Node.xln_Pri") == 0) {
    lua_pushinteger(L, obj->spm_Node.xln_Pri);
    return 1;
  }
  if (strcmp(key, "spm_Node.xln_Name") == 0) {
    lua_pushstring(L, obj->spm_Node.xln_Name);
    return 1;
  }
  if (strcmp(key, "spm_Node.xln_Subsystem") == 0) {
    lua_pushinteger(L, obj->spm_Node.xln_Subsystem);
    return 1;
  }
  if (strcmp(key, "spm_Node.xln_Subtype") == 0) {
    lua_pushinteger(L, obj->spm_Node.xln_Subtype);
    return 1;
  }
  // Unsupported spm_Node.xln_Library struct GfxBase *
  if (strcmp(key, "spm_Node.xln_Library") == 0) {
    return luaL_error(L, "Unsupported type struct GfxBase * for field spm_Node.xln_Library");
  }
  // Unsupported spm_Node.xln_Init LONG (*)(struct ExtendedNode *, UWORD)
  if (strcmp(key, "spm_Node.xln_Init") == 0) {
    return luaL_error(L, "Unsupported type LONG (*)(struct ExtendedNode *, UWORD) for field spm_Node.xln_Init");
  }
  if (strcmp(key, "spm_Node") == 0) {
    struct ExtendedNode **ud = (struct ExtendedNode **)lua_newuserdata(L, sizeof(struct ExtendedNode *));
    *ud = (struct ExtendedNode*)&obj->spm_Node;
    luaL_getmetatable(L, "ExtendedNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "spm_Flags") == 0) {
    lua_pushinteger(L, obj->spm_Flags);
    return 1;
  }
  // Unsupported do_monitor LONG (*)(struct MonitorSpec *)
  if (strcmp(key, "do_monitor") == 0) {
    return luaL_error(L, "Unsupported type LONG (*)(struct MonitorSpec *) for field do_monitor");
  }
  // Unsupported reserved1 LONG (*)()
  if (strcmp(key, "reserved1") == 0) {
    return luaL_error(L, "Unsupported type LONG (*)() for field reserved1");
  }
  // Unsupported reserved2 LONG (*)()
  if (strcmp(key, "reserved2") == 0) {
    return luaL_error(L, "Unsupported type LONG (*)() for field reserved2");
  }
  // Unsupported reserved3 LONG (*)()
  if (strcmp(key, "reserved3") == 0) {
    return luaL_error(L, "Unsupported type LONG (*)() for field reserved3");
  }
  if (strcmp(key, "hblank.asi_Start") == 0) {
    lua_pushinteger(L, obj->hblank.asi_Start);
    return 1;
  }
  if (strcmp(key, "hblank.asi_Stop") == 0) {
    lua_pushinteger(L, obj->hblank.asi_Stop);
    return 1;
  }
  if (strcmp(key, "hblank") == 0) {
    struct AnalogSignalInterval **ud = (struct AnalogSignalInterval **)lua_newuserdata(L, sizeof(struct AnalogSignalInterval *));
    *ud = (struct AnalogSignalInterval*)&obj->hblank;
    luaL_getmetatable(L, "AnalogSignalInterval");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "vblank.asi_Start") == 0) {
    lua_pushinteger(L, obj->vblank.asi_Start);
    return 1;
  }
  if (strcmp(key, "vblank.asi_Stop") == 0) {
    lua_pushinteger(L, obj->vblank.asi_Stop);
    return 1;
  }
  if (strcmp(key, "vblank") == 0) {
    struct AnalogSignalInterval **ud = (struct AnalogSignalInterval **)lua_newuserdata(L, sizeof(struct AnalogSignalInterval *));
    *ud = (struct AnalogSignalInterval*)&obj->vblank;
    luaL_getmetatable(L, "AnalogSignalInterval");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "hsync.asi_Start") == 0) {
    lua_pushinteger(L, obj->hsync.asi_Start);
    return 1;
  }
  if (strcmp(key, "hsync.asi_Stop") == 0) {
    lua_pushinteger(L, obj->hsync.asi_Stop);
    return 1;
  }
  if (strcmp(key, "hsync") == 0) {
    struct AnalogSignalInterval **ud = (struct AnalogSignalInterval **)lua_newuserdata(L, sizeof(struct AnalogSignalInterval *));
    *ud = (struct AnalogSignalInterval*)&obj->hsync;
    luaL_getmetatable(L, "AnalogSignalInterval");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "vsync.asi_Start") == 0) {
    lua_pushinteger(L, obj->vsync.asi_Start);
    return 1;
  }
  if (strcmp(key, "vsync.asi_Stop") == 0) {
    lua_pushinteger(L, obj->vsync.asi_Stop);
    return 1;
  }
  if (strcmp(key, "vsync") == 0) {
    struct AnalogSignalInterval **ud = (struct AnalogSignalInterval **)lua_newuserdata(L, sizeof(struct AnalogSignalInterval *));
    *ud = (struct AnalogSignalInterval*)&obj->vsync;
    luaL_getmetatable(L, "AnalogSignalInterval");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct SpecialMonitor));
    return 1;
}

  return 0;
}

static void
_lua_gen_SpecialMonitor_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "spm_Node.xln_Type");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "spm_Node.xln_Pri");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "spm_Node.xln_Name");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "spm_Node.xln_Subsystem");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "spm_Node.xln_Subtype");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "spm_Node.xln_Init");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "spm_Flags");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "do_monitor");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "reserved1");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "reserved2");
  lua_rawseti(L, -2, 10);
  lua_pushstring(L, "reserved3");
  lua_rawseti(L, -2, 11);
  lua_pushstring(L, "hblank.asi_Start");
  lua_rawseti(L, -2, 12);
  lua_pushstring(L, "hblank.asi_Stop");
  lua_rawseti(L, -2, 13);
  lua_pushstring(L, "vblank.asi_Start");
  lua_rawseti(L, -2, 14);
  lua_pushstring(L, "vblank.asi_Stop");
  lua_rawseti(L, -2, 15);
  lua_pushstring(L, "hsync.asi_Start");
  lua_rawseti(L, -2, 16);
  lua_pushstring(L, "hsync.asi_Stop");
  lua_rawseti(L, -2, 17);
  lua_pushstring(L, "vsync.asi_Start");
  lua_rawseti(L, -2, 18);
  lua_pushstring(L, "vsync.asi_Stop");
  lua_rawseti(L, -2, 19);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_SpecialMonitor(lua_State *L) {
  if (luaL_newmetatable(L, "SpecialMonitor")) {
    lua_pushcfunction(L, _lua_gen_SpecialMonitor_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_SpecialMonitor_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_SpecialMonitor_constructor);
    lua_setglobal(L, "SpecialMonitor");
    _lua_gen_SpecialMonitor_install_keys(L);
    lua_pushstring(L, "SpecialMonitor");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_AnalogSignalInterval_newindex(lua_State *L)
{
  struct AnalogSignalInterval *obj = *(struct AnalogSignalInterval **)luaL_checkudata(L, 1, "AnalogSignalInterval");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "asi_Start") == 0) {
    obj->asi_Start = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "asi_Stop") == 0) {
    obj->asi_Stop = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_AnalogSignalInterval_constructor(lua_State *L)
{
  // Allocate pointer-to-struct AnalogSignalInterval in userdata
  struct AnalogSignalInterval **objp = lua_newuserdata(L, sizeof(struct AnalogSignalInterval *));
  *objp = malloc(sizeof(struct AnalogSignalInterval));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct AnalogSignalInterval));

  // Set metatable
  luaL_getmetatable(L, "AnalogSignalInterval");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_AnalogSignalInterval_index(lua_State *L)
{
  struct AnalogSignalInterval *obj = *(struct AnalogSignalInterval **)luaL_checkudata(L, 1, "AnalogSignalInterval");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "asi_Start") == 0) {
    lua_pushinteger(L, obj->asi_Start);
    return 1;
  }
  if (strcmp(key, "asi_Stop") == 0) {
    lua_pushinteger(L, obj->asi_Stop);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct AnalogSignalInterval));
    return 1;
}

  return 0;
}

static void
_lua_gen_AnalogSignalInterval_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "asi_Start");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "asi_Stop");
  lua_rawseti(L, -2, 2);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_AnalogSignalInterval(lua_State *L) {
  if (luaL_newmetatable(L, "AnalogSignalInterval")) {
    lua_pushcfunction(L, _lua_gen_AnalogSignalInterval_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_AnalogSignalInterval_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_AnalogSignalInterval_constructor);
    lua_setglobal(L, "AnalogSignalInterval");
    _lua_gen_AnalogSignalInterval_install_keys(L);
    lua_pushstring(L, "AnalogSignalInterval");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_AnimOb_newindex(lua_State *L)
{
  struct AnimOb *obj = *(struct AnimOb **)luaL_checkudata(L, 1, "AnimOb");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "NextOb") == 0) {
    // finder 1
    //obj->NextOb = *(struct AnimOb **)luaL_checkudata(L, 3, "AnimOb");
    obj->NextOb = (struct AnimOb *)_lua_gen_checkAnimOb(L, 3);
    return 0;
  }
  if (strcmp(key, "PrevOb") == 0) {
    // finder 1
    //obj->PrevOb = *(struct AnimOb **)luaL_checkudata(L, 3, "AnimOb");
    obj->PrevOb = (struct AnimOb *)_lua_gen_checkAnimOb(L, 3);
    return 0;
  }
  if (strcmp(key, "Clock") == 0) {
    obj->Clock = (LONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "AnOldY") == 0) {
    obj->AnOldY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "AnOldX") == 0) {
    obj->AnOldX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "AnY") == 0) {
    obj->AnY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "AnX") == 0) {
    obj->AnX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "YVel") == 0) {
    obj->YVel = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "XVel") == 0) {
    obj->XVel = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "YAccel") == 0) {
    obj->YAccel = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "XAccel") == 0) {
    obj->XAccel = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "RingYTrans") == 0) {
    obj->RingYTrans = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "RingXTrans") == 0) {
    obj->RingXTrans = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type AnimORoutine WORD ()(struct AnimOb )
  if (strcmp(key, "AnimORoutine") == 0) {
    return luaL_error(L, "Unsupported type WORD ()(struct AnimOb ) for field AnimORoutine");
  }
  if (strcmp(key, "HeadComp") == 0) {
    // finder 1
    //obj->HeadComp = *(struct AnimComp **)luaL_checkudata(L, 3, "AnimComp");
    obj->HeadComp = (struct AnimComp *)_lua_gen_checkAnimComp(L, 3);
    return 0;
  }
  if (strcmp(key, "AUserExt") == 0) {
    obj->AUserExt = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_AnimOb_constructor(lua_State *L)
{
  // Allocate pointer-to-struct AnimOb in userdata
  struct AnimOb **objp = lua_newuserdata(L, sizeof(struct AnimOb *));
  *objp = malloc(sizeof(struct AnimOb));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct AnimOb));

  // Set metatable
  luaL_getmetatable(L, "AnimOb");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_AnimOb_index(lua_State *L)
{
  struct AnimOb *obj = *(struct AnimOb **)luaL_checkudata(L, 1, "AnimOb");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "NextOb") == 0) {
    struct AnimOb **ud = (struct AnimOb **)lua_newuserdata(L, sizeof(struct AnimOb *));
    *ud = (struct AnimOb*)obj->NextOb;
    luaL_getmetatable(L, "AnimOb");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "PrevOb") == 0) {
    struct AnimOb **ud = (struct AnimOb **)lua_newuserdata(L, sizeof(struct AnimOb *));
    *ud = (struct AnimOb*)obj->PrevOb;
    luaL_getmetatable(L, "AnimOb");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "Clock") == 0) {
    lua_pushinteger(L, obj->Clock);
    return 1;
  }
  if (strcmp(key, "AnOldY") == 0) {
    lua_pushinteger(L, obj->AnOldY);
    return 1;
  }
  if (strcmp(key, "AnOldX") == 0) {
    lua_pushinteger(L, obj->AnOldX);
    return 1;
  }
  if (strcmp(key, "AnY") == 0) {
    lua_pushinteger(L, obj->AnY);
    return 1;
  }
  if (strcmp(key, "AnX") == 0) {
    lua_pushinteger(L, obj->AnX);
    return 1;
  }
  if (strcmp(key, "YVel") == 0) {
    lua_pushinteger(L, obj->YVel);
    return 1;
  }
  if (strcmp(key, "XVel") == 0) {
    lua_pushinteger(L, obj->XVel);
    return 1;
  }
  if (strcmp(key, "YAccel") == 0) {
    lua_pushinteger(L, obj->YAccel);
    return 1;
  }
  if (strcmp(key, "XAccel") == 0) {
    lua_pushinteger(L, obj->XAccel);
    return 1;
  }
  if (strcmp(key, "RingYTrans") == 0) {
    lua_pushinteger(L, obj->RingYTrans);
    return 1;
  }
  if (strcmp(key, "RingXTrans") == 0) {
    lua_pushinteger(L, obj->RingXTrans);
    return 1;
  }
  // Unsupported AnimORoutine WORD (*)(struct AnimOb *)
  if (strcmp(key, "AnimORoutine") == 0) {
    return luaL_error(L, "Unsupported type WORD (*)(struct AnimOb *) for field AnimORoutine");
  }
  if (strcmp(key, "HeadComp") == 0) {
    struct AnimComp **ud = (struct AnimComp **)lua_newuserdata(L, sizeof(struct AnimComp *));
    *ud = (struct AnimComp*)obj->HeadComp;
    luaL_getmetatable(L, "AnimComp");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "AUserExt") == 0) {
    lua_pushinteger(L, obj->AUserExt);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct AnimOb));
    return 1;
}

  return 0;
}

static void
_lua_gen_AnimOb_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "Clock");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "AnOldY");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "AnOldX");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "AnY");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "AnX");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "YVel");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "XVel");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "YAccel");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "XAccel");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "RingYTrans");
  lua_rawseti(L, -2, 10);
  lua_pushstring(L, "RingXTrans");
  lua_rawseti(L, -2, 11);
  lua_pushstring(L, "AnimORoutine");
  lua_rawseti(L, -2, 12);
  lua_pushstring(L, "AUserExt");
  lua_rawseti(L, -2, 13);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_AnimOb(lua_State *L) {
  if (luaL_newmetatable(L, "AnimOb")) {
    lua_pushcfunction(L, _lua_gen_AnimOb_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_AnimOb_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_AnimOb_constructor);
    lua_setglobal(L, "AnimOb");
    _lua_gen_AnimOb_install_keys(L);
    lua_pushstring(L, "AnimOb");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_AreaInfo_newindex(lua_State *L)
{
  struct AreaInfo *obj = *(struct AreaInfo **)luaL_checkudata(L, 1, "AreaInfo");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "VctrTbl") == 0) {
    obj->VctrTbl = (WORD *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "VctrPtr") == 0) {
    obj->VctrPtr = (WORD *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "FlagTbl") == 0) {
    obj->FlagTbl = (BYTE *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "FlagPtr") == 0) {
    obj->FlagPtr = (BYTE *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "Count") == 0) {
    obj->Count = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "MaxCount") == 0) {
    obj->MaxCount = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "FirstX") == 0) {
    obj->FirstX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "FirstY") == 0) {
    obj->FirstY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_AreaInfo_constructor(lua_State *L)
{
  // Allocate pointer-to-struct AreaInfo in userdata
  struct AreaInfo **objp = lua_newuserdata(L, sizeof(struct AreaInfo *));
  *objp = malloc(sizeof(struct AreaInfo));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct AreaInfo));

  // Set metatable
  luaL_getmetatable(L, "AreaInfo");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_AreaInfo_index(lua_State *L)
{
  struct AreaInfo *obj = *(struct AreaInfo **)luaL_checkudata(L, 1, "AreaInfo");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "VctrTbl") == 0) {
    lua_pushlightuserdata(L, obj->VctrTbl);
    return 1;
  }
  if (strcmp(key, "VctrPtr") == 0) {
    lua_pushlightuserdata(L, obj->VctrPtr);
    return 1;
  }
  if (strcmp(key, "FlagTbl") == 0) {
    lua_pushlightuserdata(L, obj->FlagTbl);
    return 1;
  }
  if (strcmp(key, "FlagPtr") == 0) {
    lua_pushlightuserdata(L, obj->FlagPtr);
    return 1;
  }
  if (strcmp(key, "Count") == 0) {
    lua_pushinteger(L, obj->Count);
    return 1;
  }
  if (strcmp(key, "MaxCount") == 0) {
    lua_pushinteger(L, obj->MaxCount);
    return 1;
  }
  if (strcmp(key, "FirstX") == 0) {
    lua_pushinteger(L, obj->FirstX);
    return 1;
  }
  if (strcmp(key, "FirstY") == 0) {
    lua_pushinteger(L, obj->FirstY);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct AreaInfo));
    return 1;
}

  return 0;
}

static void
_lua_gen_AreaInfo_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "VctrTbl");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "VctrPtr");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "FlagTbl");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "FlagPtr");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "Count");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "MaxCount");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "FirstX");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "FirstY");
  lua_rawseti(L, -2, 8);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_AreaInfo(lua_State *L) {
  if (luaL_newmetatable(L, "AreaInfo")) {
    lua_pushcfunction(L, _lua_gen_AreaInfo_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_AreaInfo_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_AreaInfo_constructor);
    lua_setglobal(L, "AreaInfo");
    _lua_gen_AreaInfo_install_keys(L);
    lua_pushstring(L, "AreaInfo");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_BitScaleArgs_newindex(lua_State *L)
{
  struct BitScaleArgs *obj = *(struct BitScaleArgs **)luaL_checkudata(L, 1, "BitScaleArgs");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "bsa_SrcX") == 0) {
    obj->bsa_SrcX = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bsa_SrcY") == 0) {
    obj->bsa_SrcY = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bsa_SrcWidth") == 0) {
    obj->bsa_SrcWidth = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bsa_SrcHeight") == 0) {
    obj->bsa_SrcHeight = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bsa_XSrcFactor") == 0) {
    obj->bsa_XSrcFactor = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bsa_YSrcFactor") == 0) {
    obj->bsa_YSrcFactor = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bsa_DestX") == 0) {
    obj->bsa_DestX = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bsa_DestY") == 0) {
    obj->bsa_DestY = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bsa_DestWidth") == 0) {
    obj->bsa_DestWidth = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bsa_DestHeight") == 0) {
    obj->bsa_DestHeight = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bsa_XDestFactor") == 0) {
    obj->bsa_XDestFactor = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bsa_YDestFactor") == 0) {
    obj->bsa_YDestFactor = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bsa_SrcBitMap") == 0) {
    // finder 1
    //obj->bsa_SrcBitMap = *(struct BitMap **)luaL_checkudata(L, 3, "BitMap");
    obj->bsa_SrcBitMap = (struct BitMap *)_lua_gen_checkBitMap(L, 3);
    return 0;
  }
  if (strcmp(key, "bsa_DestBitMap") == 0) {
    // finder 1
    //obj->bsa_DestBitMap = *(struct BitMap **)luaL_checkudata(L, 3, "BitMap");
    obj->bsa_DestBitMap = (struct BitMap *)_lua_gen_checkBitMap(L, 3);
    return 0;
  }
  if (strcmp(key, "bsa_Flags") == 0) {
    obj->bsa_Flags = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bsa_XDDA") == 0) {
    obj->bsa_XDDA = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bsa_YDDA") == 0) {
    obj->bsa_YDDA = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bsa_Reserved1") == 0) {
    obj->bsa_Reserved1 = (LONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bsa_Reserved2") == 0) {
    obj->bsa_Reserved2 = (LONG)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_BitScaleArgs_constructor(lua_State *L)
{
  // Allocate pointer-to-struct BitScaleArgs in userdata
  struct BitScaleArgs **objp = lua_newuserdata(L, sizeof(struct BitScaleArgs *));
  *objp = malloc(sizeof(struct BitScaleArgs));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct BitScaleArgs));

  // Set metatable
  luaL_getmetatable(L, "BitScaleArgs");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_BitScaleArgs_index(lua_State *L)
{
  struct BitScaleArgs *obj = *(struct BitScaleArgs **)luaL_checkudata(L, 1, "BitScaleArgs");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "bsa_SrcX") == 0) {
    lua_pushinteger(L, obj->bsa_SrcX);
    return 1;
  }
  if (strcmp(key, "bsa_SrcY") == 0) {
    lua_pushinteger(L, obj->bsa_SrcY);
    return 1;
  }
  if (strcmp(key, "bsa_SrcWidth") == 0) {
    lua_pushinteger(L, obj->bsa_SrcWidth);
    return 1;
  }
  if (strcmp(key, "bsa_SrcHeight") == 0) {
    lua_pushinteger(L, obj->bsa_SrcHeight);
    return 1;
  }
  if (strcmp(key, "bsa_XSrcFactor") == 0) {
    lua_pushinteger(L, obj->bsa_XSrcFactor);
    return 1;
  }
  if (strcmp(key, "bsa_YSrcFactor") == 0) {
    lua_pushinteger(L, obj->bsa_YSrcFactor);
    return 1;
  }
  if (strcmp(key, "bsa_DestX") == 0) {
    lua_pushinteger(L, obj->bsa_DestX);
    return 1;
  }
  if (strcmp(key, "bsa_DestY") == 0) {
    lua_pushinteger(L, obj->bsa_DestY);
    return 1;
  }
  if (strcmp(key, "bsa_DestWidth") == 0) {
    lua_pushinteger(L, obj->bsa_DestWidth);
    return 1;
  }
  if (strcmp(key, "bsa_DestHeight") == 0) {
    lua_pushinteger(L, obj->bsa_DestHeight);
    return 1;
  }
  if (strcmp(key, "bsa_XDestFactor") == 0) {
    lua_pushinteger(L, obj->bsa_XDestFactor);
    return 1;
  }
  if (strcmp(key, "bsa_YDestFactor") == 0) {
    lua_pushinteger(L, obj->bsa_YDestFactor);
    return 1;
  }
  if (strcmp(key, "bsa_SrcBitMap") == 0) {
    struct BitMap **ud = (struct BitMap **)lua_newuserdata(L, sizeof(struct BitMap *));
    *ud = (struct BitMap*)obj->bsa_SrcBitMap;
    luaL_getmetatable(L, "BitMap");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "bsa_DestBitMap") == 0) {
    struct BitMap **ud = (struct BitMap **)lua_newuserdata(L, sizeof(struct BitMap *));
    *ud = (struct BitMap*)obj->bsa_DestBitMap;
    luaL_getmetatable(L, "BitMap");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "bsa_Flags") == 0) {
    lua_pushinteger(L, obj->bsa_Flags);
    return 1;
  }
  if (strcmp(key, "bsa_XDDA") == 0) {
    lua_pushinteger(L, obj->bsa_XDDA);
    return 1;
  }
  if (strcmp(key, "bsa_YDDA") == 0) {
    lua_pushinteger(L, obj->bsa_YDDA);
    return 1;
  }
  if (strcmp(key, "bsa_Reserved1") == 0) {
    lua_pushinteger(L, obj->bsa_Reserved1);
    return 1;
  }
  if (strcmp(key, "bsa_Reserved2") == 0) {
    lua_pushinteger(L, obj->bsa_Reserved2);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct BitScaleArgs));
    return 1;
}

  return 0;
}

static void
_lua_gen_BitScaleArgs_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "bsa_SrcX");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "bsa_SrcY");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "bsa_SrcWidth");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "bsa_SrcHeight");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "bsa_XSrcFactor");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "bsa_YSrcFactor");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "bsa_DestX");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "bsa_DestY");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "bsa_DestWidth");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "bsa_DestHeight");
  lua_rawseti(L, -2, 10);
  lua_pushstring(L, "bsa_XDestFactor");
  lua_rawseti(L, -2, 11);
  lua_pushstring(L, "bsa_YDestFactor");
  lua_rawseti(L, -2, 12);
  lua_pushstring(L, "bsa_Flags");
  lua_rawseti(L, -2, 13);
  lua_pushstring(L, "bsa_XDDA");
  lua_rawseti(L, -2, 14);
  lua_pushstring(L, "bsa_YDDA");
  lua_rawseti(L, -2, 15);
  lua_pushstring(L, "bsa_Reserved1");
  lua_rawseti(L, -2, 16);
  lua_pushstring(L, "bsa_Reserved2");
  lua_rawseti(L, -2, 17);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_BitScaleArgs(lua_State *L) {
  if (luaL_newmetatable(L, "BitScaleArgs")) {
    lua_pushcfunction(L, _lua_gen_BitScaleArgs_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_BitScaleArgs_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_BitScaleArgs_constructor);
    lua_setglobal(L, "BitScaleArgs");
    _lua_gen_BitScaleArgs_install_keys(L);
    lua_pushstring(L, "BitScaleArgs");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_Bob_newindex(lua_State *L)
{
  struct Bob *obj = *(struct Bob **)luaL_checkudata(L, 1, "Bob");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "Flags") == 0) {
    obj->Flags = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "SaveBuffer") == 0) {
    obj->SaveBuffer = (WORD *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "ImageShadow") == 0) {
    obj->ImageShadow = (WORD *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "Before") == 0) {
    // finder 1
    //obj->Before = *(struct Bob **)luaL_checkudata(L, 3, "Bob");
    obj->Before = (struct Bob *)_lua_gen_checkBob(L, 3);
    return 0;
  }
  if (strcmp(key, "After") == 0) {
    // finder 1
    //obj->After = *(struct Bob **)luaL_checkudata(L, 3, "Bob");
    obj->After = (struct Bob *)_lua_gen_checkBob(L, 3);
    return 0;
  }
  if (strcmp(key, "BobVSprite") == 0) {
    // finder 1
    //obj->BobVSprite = *(struct VSprite **)luaL_checkudata(L, 3, "VSprite");
    obj->BobVSprite = (struct VSprite *)_lua_gen_checkVSprite(L, 3);
    return 0;
  }
  if (strcmp(key, "BobComp") == 0) {
    // finder 1
    //obj->BobComp = *(struct AnimComp **)luaL_checkudata(L, 3, "AnimComp");
    obj->BobComp = (struct AnimComp *)_lua_gen_checkAnimComp(L, 3);
    return 0;
  }
  if (strcmp(key, "DBuffer") == 0) {
    // finder 1
    //obj->DBuffer = *(struct DBufPacket **)luaL_checkudata(L, 3, "DBufPacket");
    obj->DBuffer = (struct DBufPacket *)_lua_gen_checkDBufPacket(L, 3);
    return 0;
  }
  if (strcmp(key, "BUserExt") == 0) {
    obj->BUserExt = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_Bob_constructor(lua_State *L)
{
  // Allocate pointer-to-struct Bob in userdata
  struct Bob **objp = lua_newuserdata(L, sizeof(struct Bob *));
  *objp = malloc(sizeof(struct Bob));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct Bob));

  // Set metatable
  luaL_getmetatable(L, "Bob");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_Bob_index(lua_State *L)
{
  struct Bob *obj = *(struct Bob **)luaL_checkudata(L, 1, "Bob");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "Flags") == 0) {
    lua_pushinteger(L, obj->Flags);
    return 1;
  }
  if (strcmp(key, "SaveBuffer") == 0) {
    lua_pushlightuserdata(L, obj->SaveBuffer);
    return 1;
  }
  if (strcmp(key, "ImageShadow") == 0) {
    lua_pushlightuserdata(L, obj->ImageShadow);
    return 1;
  }
  if (strcmp(key, "Before") == 0) {
    struct Bob **ud = (struct Bob **)lua_newuserdata(L, sizeof(struct Bob *));
    *ud = (struct Bob*)obj->Before;
    luaL_getmetatable(L, "Bob");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "After") == 0) {
    struct Bob **ud = (struct Bob **)lua_newuserdata(L, sizeof(struct Bob *));
    *ud = (struct Bob*)obj->After;
    luaL_getmetatable(L, "Bob");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "BobVSprite") == 0) {
    struct VSprite **ud = (struct VSprite **)lua_newuserdata(L, sizeof(struct VSprite *));
    *ud = (struct VSprite*)obj->BobVSprite;
    luaL_getmetatable(L, "VSprite");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "BobComp") == 0) {
    struct AnimComp **ud = (struct AnimComp **)lua_newuserdata(L, sizeof(struct AnimComp *));
    *ud = (struct AnimComp*)obj->BobComp;
    luaL_getmetatable(L, "AnimComp");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "DBuffer") == 0) {
    struct DBufPacket **ud = (struct DBufPacket **)lua_newuserdata(L, sizeof(struct DBufPacket *));
    *ud = (struct DBufPacket*)obj->DBuffer;
    luaL_getmetatable(L, "DBufPacket");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "BUserExt") == 0) {
    lua_pushinteger(L, obj->BUserExt);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct Bob));
    return 1;
}

  return 0;
}

static void
_lua_gen_Bob_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "Flags");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "SaveBuffer");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "ImageShadow");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "BUserExt");
  lua_rawseti(L, -2, 4);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_Bob(lua_State *L) {
  if (luaL_newmetatable(L, "Bob")) {
    lua_pushcfunction(L, _lua_gen_Bob_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_Bob_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_Bob_constructor);
    lua_setglobal(L, "Bob");
    _lua_gen_Bob_install_keys(L);
    lua_pushstring(L, "Bob");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_GelsInfo_newindex(lua_State *L)
{
  struct GelsInfo *obj = *(struct GelsInfo **)luaL_checkudata(L, 1, "GelsInfo");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "sprRsrvd") == 0) {
    obj->sprRsrvd = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Flags") == 0) {
    obj->Flags = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "gelHead") == 0) {
    // finder 1
    //obj->gelHead = *(struct VSprite **)luaL_checkudata(L, 3, "VSprite");
    obj->gelHead = (struct VSprite *)_lua_gen_checkVSprite(L, 3);
    return 0;
  }
  if (strcmp(key, "gelTail") == 0) {
    // finder 1
    //obj->gelTail = *(struct VSprite **)luaL_checkudata(L, 3, "VSprite");
    obj->gelTail = (struct VSprite *)_lua_gen_checkVSprite(L, 3);
    return 0;
  }
  if (strcmp(key, "nextLine") == 0) {
    obj->nextLine = (WORD *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "lastColor") == 0) {
    obj->lastColor = (WORD **)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "collHandler") == 0) {
    // finder 1
    //obj->collHandler = *(struct collTable **)luaL_checkudata(L, 3, "collTable");
    obj->collHandler = (struct collTable *)_lua_gen_checkcollTable(L, 3);
    return 0;
  }
  if (strcmp(key, "leftmost") == 0) {
    obj->leftmost = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "rightmost") == 0) {
    obj->rightmost = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "topmost") == 0) {
    obj->topmost = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bottommost") == 0) {
    obj->bottommost = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "firstBlissObj") == 0) {
    obj->firstBlissObj = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "lastBlissObj") == 0) {
    obj->lastBlissObj = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_GelsInfo_constructor(lua_State *L)
{
  // Allocate pointer-to-struct GelsInfo in userdata
  struct GelsInfo **objp = lua_newuserdata(L, sizeof(struct GelsInfo *));
  *objp = malloc(sizeof(struct GelsInfo));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct GelsInfo));

  // Set metatable
  luaL_getmetatable(L, "GelsInfo");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_GelsInfo_index(lua_State *L)
{
  struct GelsInfo *obj = *(struct GelsInfo **)luaL_checkudata(L, 1, "GelsInfo");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "sprRsrvd") == 0) {
    lua_pushinteger(L, obj->sprRsrvd);
    return 1;
  }
  if (strcmp(key, "Flags") == 0) {
    lua_pushinteger(L, obj->Flags);
    return 1;
  }
  if (strcmp(key, "gelHead") == 0) {
    struct VSprite **ud = (struct VSprite **)lua_newuserdata(L, sizeof(struct VSprite *));
    *ud = (struct VSprite*)obj->gelHead;
    luaL_getmetatable(L, "VSprite");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "gelTail") == 0) {
    struct VSprite **ud = (struct VSprite **)lua_newuserdata(L, sizeof(struct VSprite *));
    *ud = (struct VSprite*)obj->gelTail;
    luaL_getmetatable(L, "VSprite");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "nextLine") == 0) {
    lua_pushlightuserdata(L, obj->nextLine);
    return 1;
  }
  if (strcmp(key, "lastColor") == 0) {
    lua_pushlightuserdata(L, obj->lastColor);
    return 1;
  }
  if (strcmp(key, "collHandler") == 0) {
    struct collTable **ud = (struct collTable **)lua_newuserdata(L, sizeof(struct collTable *));
    *ud = (struct collTable*)obj->collHandler;
    luaL_getmetatable(L, "collTable");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "leftmost") == 0) {
    lua_pushinteger(L, obj->leftmost);
    return 1;
  }
  if (strcmp(key, "rightmost") == 0) {
    lua_pushinteger(L, obj->rightmost);
    return 1;
  }
  if (strcmp(key, "topmost") == 0) {
    lua_pushinteger(L, obj->topmost);
    return 1;
  }
  if (strcmp(key, "bottommost") == 0) {
    lua_pushinteger(L, obj->bottommost);
    return 1;
  }
  if (strcmp(key, "firstBlissObj") == 0) {
    lua_pushlightuserdata(L, obj->firstBlissObj);
    return 1;
  }
  if (strcmp(key, "lastBlissObj") == 0) {
    lua_pushlightuserdata(L, obj->lastBlissObj);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct GelsInfo));
    return 1;
}

  return 0;
}

static void
_lua_gen_GelsInfo_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "sprRsrvd");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "Flags");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "nextLine");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "lastColor");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "leftmost");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "rightmost");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "topmost");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "bottommost");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "firstBlissObj");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "lastBlissObj");
  lua_rawseti(L, -2, 10);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_GelsInfo(lua_State *L) {
  if (luaL_newmetatable(L, "GelsInfo")) {
    lua_pushcfunction(L, _lua_gen_GelsInfo_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_GelsInfo_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_GelsInfo_constructor);
    lua_setglobal(L, "GelsInfo");
    _lua_gen_GelsInfo_install_keys(L);
    lua_pushstring(L, "GelsInfo");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

typedef struct {
  UBYTE* data;
  uint16_t count;
} lua_gen_wrapped_UBYTE_array_data_t;

static int _lua_gen_wrapped_UBYTE_array_ptr_method(lua_State* L) {
    lua_gen_wrapped_UBYTE_array_data_t* wrapper = luaL_checkudata(L, 1, "UBYTE_array_proxy");
    int index = luaL_checkinteger(L, 2);
    void* ptr = &wrapper->data[index - 1];
    lua_pushlightuserdata(L, ptr);
    return 1;
}
static int
_lua_gen_wrapped_UBYTE_array_index(lua_State* L)
{
  lua_gen_wrapped_UBYTE_array_data_t* wrapper = luaL_checkudata(L, 1, "UBYTE_array_proxy");
  if (lua_isinteger(L, 2)) {
    int index = lua_tointeger(L, 2);
    if (index < 1 || index > wrapper->count)
      return luaL_error(L, "index out of range (1..%d)", wrapper->count);
    lua_pushinteger(L, wrapper->data[index - 1]);
    return 1;
  }

  // Not a numeric key? Try methods
  lua_getmetatable(L, 1);
  lua_getfield(L, -1, "__methods");
  lua_pushvalue(L, 2);
  lua_gettable(L, -2);
  return 1;
}

static int
_lua_gen_wrapped_UBYTE_array_newindex(lua_State* L)
{
  lua_gen_wrapped_UBYTE_array_data_t* wrapper = luaL_checkudata(L, 1, "UBYTE_array_proxy");
  if (!lua_isinteger(L, 2))
    return luaL_error(L, "only integer indices allowed");
  int index = lua_tointeger(L, 2);
  if (index < 1 || index > wrapper->count)
    return luaL_error(L, "index out of range (1..%d)", wrapper->count);
  UBYTE value = luaL_checkinteger(L,  3);
  wrapper->data[index - 1] = value;
  return 0;
}

static void
_lua_gen_push_UBYTE_array_proxy(lua_State *L,  UBYTE *array, int count)
{

  lua_gen_wrapped_UBYTE_array_data_t* wrapper = lua_newuserdata(L, sizeof(lua_gen_wrapped_UBYTE_array_data_t));
  wrapper->data = array;
  wrapper->count = count;

  if (luaL_newmetatable(L, "UBYTE_array_proxy")) {
    // Create method table
    lua_newtable(L);
    lua_pushcfunction(L, _lua_gen_wrapped_UBYTE_array_ptr_method);
    lua_setfield(L, -2, "ptr");
    lua_setfield(L, -2, "__methods");

    // __index handles both numeric and method lookup
    lua_pushcfunction(L, _lua_gen_wrapped_UBYTE_array_index);
    lua_setfield(L, -2, "__index");

    // __newindex for writing
    lua_pushcfunction(L, _lua_gen_wrapped_UBYTE_array_newindex);
    lua_setfield(L, -2, "__newindex");
  }

  lua_setmetatable(L, -2);  // assign to userdata

}
static int
_lua_gen_Layer_newindex(lua_State *L)
{
  struct Layer *obj = *(struct Layer **)luaL_checkudata(L, 1, "Layer");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "front") == 0) {
    // finder 1
    //obj->front = *(struct Layer **)luaL_checkudata(L, 3, "Layer");
    obj->front = (struct Layer *)_lua_gen_checkLayer(L, 3);
    return 0;
  }
  if (strcmp(key, "back") == 0) {
    // finder 1
    //obj->back = *(struct Layer **)luaL_checkudata(L, 3, "Layer");
    obj->back = (struct Layer *)_lua_gen_checkLayer(L, 3);
    return 0;
  }
  // Unsupported type ClipRect struct ClipRect
  if (strcmp(key, "ClipRect") == 0) {
    return luaL_error(L, "Unsupported type struct ClipRect for field ClipRect");
  }
  if (strcmp(key, "rp") == 0) {
    // finder 1
    //obj->rp = *(struct RastPort **)luaL_checkudata(L, 3, "RastPort");
    obj->rp = (struct RastPort *)_lua_gen_checkRastPort(L, 3);
    return 0;
  }
  if (strcmp(key, "bounds.MinX") == 0) {
    obj->bounds.MinX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bounds.MinY") == 0) {
    obj->bounds.MinY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bounds.MaxX") == 0) {
    obj->bounds.MaxX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bounds.MaxY") == 0) {
    obj->bounds.MaxY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bounds") == 0) {
    // finder 0
    struct Rectangle *val = *(struct Rectangle **)luaL_checkudata(L, 3, "Rectangle");
    obj->bounds = *val;
    return 0;
  }
  if (strcmp(key, "nlink") == 0) {
    // finder 1
    //obj->nlink = *(struct Layer **)luaL_checkudata(L, 3, "Layer");
    obj->nlink = (struct Layer *)_lua_gen_checkLayer(L, 3);
    return 0;
  }
  if (strcmp(key, "priority") == 0) {
    obj->priority = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Flags") == 0) {
    obj->Flags = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "SuperBitMap") == 0) {
    // finder 1
    //obj->SuperBitMap = *(struct BitMap **)luaL_checkudata(L, 3, "BitMap");
    obj->SuperBitMap = (struct BitMap *)_lua_gen_checkBitMap(L, 3);
    return 0;
  }
  // Unsupported type SuperClipRect struct ClipRect
  if (strcmp(key, "SuperClipRect") == 0) {
    return luaL_error(L, "Unsupported type struct ClipRect for field SuperClipRect");
  }
  if (strcmp(key, "Window") == 0) {
    obj->Window = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "Scroll_X") == 0) {
    obj->Scroll_X = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Scroll_Y") == 0) {
    obj->Scroll_Y = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type OnScreen struct ClipRect
  if (strcmp(key, "OnScreen") == 0) {
    return luaL_error(L, "Unsupported type struct ClipRect for field OnScreen");
  }
  // Unsupported type OffScreen struct ClipRect
  if (strcmp(key, "OffScreen") == 0) {
    return luaL_error(L, "Unsupported type struct ClipRect for field OffScreen");
  }
  // Unsupported type Backup struct ClipRect
  if (strcmp(key, "Backup") == 0) {
    return luaL_error(L, "Unsupported type struct ClipRect for field Backup");
  }
  // Unsupported type SuperSaveClipRects struct ClipRect
  if (strcmp(key, "SuperSaveClipRects") == 0) {
    return luaL_error(L, "Unsupported type struct ClipRect for field SuperSaveClipRects");
  }
  // Unsupported type Undamaged struct ClipRect
  if (strcmp(key, "Undamaged") == 0) {
    return luaL_error(L, "Unsupported type struct ClipRect for field Undamaged");
  }
  // Unsupported type LayerInfo struct Layer_Info
  if (strcmp(key, "LayerInfo") == 0) {
    return luaL_error(L, "Unsupported type struct Layer_Info for field LayerInfo");
  }
  // Unsupported type Lock.ss_Link.ln_Succ struct Node
  if (strcmp(key, "Lock.ss_Link.ln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field Lock.ss_Link.ln_Succ");
  }
  // Unsupported type Lock.ss_Link.ln_Pred struct Node
  if (strcmp(key, "Lock.ss_Link.ln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field Lock.ss_Link.ln_Pred");
  }
  if (strcmp(key, "Lock.ss_Link.ln_Type") == 0) {
    obj->Lock.ss_Link.ln_Type = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Lock.ss_Link.ln_Pri") == 0) {
    obj->Lock.ss_Link.ln_Pri = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Lock.ss_Link.ln_Name") == 0) {
    obj->Lock.ss_Link.ln_Name = (char *)luaL_checkstring(L, 3);
    return 0;
  }
  // Unsupported type Lock.ss_Link struct Node
  if (strcmp(key, "Lock.ss_Link") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field Lock.ss_Link");
  }
  if (strcmp(key, "Lock.ss_NestCount") == 0) {
    obj->Lock.ss_NestCount = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type Lock.ss_WaitQueue.mlh_Head struct MinNode
  if (strcmp(key, "Lock.ss_WaitQueue.mlh_Head") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode for field Lock.ss_WaitQueue.mlh_Head");
  }
  // Unsupported type Lock.ss_WaitQueue.mlh_Tail struct MinNode
  if (strcmp(key, "Lock.ss_WaitQueue.mlh_Tail") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode for field Lock.ss_WaitQueue.mlh_Tail");
  }
  // Unsupported type Lock.ss_WaitQueue.mlh_TailPred struct MinNode
  if (strcmp(key, "Lock.ss_WaitQueue.mlh_TailPred") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode for field Lock.ss_WaitQueue.mlh_TailPred");
  }
  // Unsupported type Lock.ss_WaitQueue struct MinList
  if (strcmp(key, "Lock.ss_WaitQueue") == 0) {
    return luaL_error(L, "Unsupported type struct MinList for field Lock.ss_WaitQueue");
  }
  // Unsupported type Lock.ss_MultipleLink.sr_Link.mln_Succ struct MinNode
  if (strcmp(key, "Lock.ss_MultipleLink.sr_Link.mln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode for field Lock.ss_MultipleLink.sr_Link.mln_Succ");
  }
  // Unsupported type Lock.ss_MultipleLink.sr_Link.mln_Pred struct MinNode
  if (strcmp(key, "Lock.ss_MultipleLink.sr_Link.mln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode for field Lock.ss_MultipleLink.sr_Link.mln_Pred");
  }
  // Unsupported type Lock.ss_MultipleLink.sr_Link struct MinNode
  if (strcmp(key, "Lock.ss_MultipleLink.sr_Link") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode for field Lock.ss_MultipleLink.sr_Link");
  }
  // Unsupported type Lock.ss_MultipleLink.sr_Waiter struct Task
  if (strcmp(key, "Lock.ss_MultipleLink.sr_Waiter") == 0) {
    return luaL_error(L, "Unsupported type struct Task for field Lock.ss_MultipleLink.sr_Waiter");
  }
  // Unsupported type Lock.ss_MultipleLink struct SemaphoreRequest
  if (strcmp(key, "Lock.ss_MultipleLink") == 0) {
    return luaL_error(L, "Unsupported type struct SemaphoreRequest for field Lock.ss_MultipleLink");
  }
  // Unsupported type Lock.ss_Owner struct Task
  if (strcmp(key, "Lock.ss_Owner") == 0) {
    return luaL_error(L, "Unsupported type struct Task for field Lock.ss_Owner");
  }
  if (strcmp(key, "Lock.ss_QueueCount") == 0) {
    obj->Lock.ss_QueueCount = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type Lock struct SignalSemaphore
  if (strcmp(key, "Lock") == 0) {
    return luaL_error(L, "Unsupported type struct SignalSemaphore for field Lock");
  }
  // Unsupported type BackFill struct Hook
  if (strcmp(key, "BackFill") == 0) {
    return luaL_error(L, "Unsupported type struct Hook for field BackFill");
  }
  if (strcmp(key, "reserved1") == 0) {
    obj->reserved1 = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ClipRegion") == 0) {
    // finder 1
    //obj->ClipRegion = *(struct Region **)luaL_checkudata(L, 3, "Region");
    obj->ClipRegion = (struct Region *)_lua_gen_checkRegion(L, 3);
    return 0;
  }
  // Unsupported type clipped struct ClipRect
  if (strcmp(key, "clipped") == 0) {
    return luaL_error(L, "Unsupported type struct ClipRect for field clipped");
  }
  if (strcmp(key, "Width") == 0) {
    obj->Width = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Height") == 0) {
    obj->Height = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // reserved2[18] proxied via the index
  if (strcmp(key, "DamageList") == 0) {
    // finder 1
    //obj->DamageList = *(struct Region **)luaL_checkudata(L, 3, "Region");
    obj->DamageList = (struct Region *)_lua_gen_checkRegion(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_Layer_constructor(lua_State *L)
{
  // Allocate pointer-to-struct Layer in userdata
  struct Layer **objp = lua_newuserdata(L, sizeof(struct Layer *));
  *objp = malloc(sizeof(struct Layer));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct Layer));

  // Set metatable
  luaL_getmetatable(L, "Layer");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_Layer_index(lua_State *L)
{
  struct Layer *obj = *(struct Layer **)luaL_checkudata(L, 1, "Layer");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "front") == 0) {
    struct Layer **ud = (struct Layer **)lua_newuserdata(L, sizeof(struct Layer *));
    *ud = (struct Layer*)obj->front;
    luaL_getmetatable(L, "Layer");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "back") == 0) {
    struct Layer **ud = (struct Layer **)lua_newuserdata(L, sizeof(struct Layer *));
    *ud = (struct Layer*)obj->back;
    luaL_getmetatable(L, "Layer");
    lua_setmetatable(L, -2);
    return 1;
  }
  // Unsupported ClipRect struct ClipRect *
  if (strcmp(key, "ClipRect") == 0) {
    return luaL_error(L, "Unsupported type struct ClipRect * for field ClipRect");
  }
  if (strcmp(key, "rp") == 0) {
    struct RastPort **ud = (struct RastPort **)lua_newuserdata(L, sizeof(struct RastPort *));
    *ud = (struct RastPort*)obj->rp;
    luaL_getmetatable(L, "RastPort");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "bounds.MinX") == 0) {
    lua_pushinteger(L, obj->bounds.MinX);
    return 1;
  }
  if (strcmp(key, "bounds.MinY") == 0) {
    lua_pushinteger(L, obj->bounds.MinY);
    return 1;
  }
  if (strcmp(key, "bounds.MaxX") == 0) {
    lua_pushinteger(L, obj->bounds.MaxX);
    return 1;
  }
  if (strcmp(key, "bounds.MaxY") == 0) {
    lua_pushinteger(L, obj->bounds.MaxY);
    return 1;
  }
  if (strcmp(key, "bounds") == 0) {
    struct Rectangle **ud = (struct Rectangle **)lua_newuserdata(L, sizeof(struct Rectangle *));
    *ud = (struct Rectangle*)&obj->bounds;
    luaL_getmetatable(L, "Rectangle");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "nlink") == 0) {
    struct Layer **ud = (struct Layer **)lua_newuserdata(L, sizeof(struct Layer *));
    *ud = (struct Layer*)obj->nlink;
    luaL_getmetatable(L, "Layer");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "priority") == 0) {
    lua_pushinteger(L, obj->priority);
    return 1;
  }
  if (strcmp(key, "Flags") == 0) {
    lua_pushinteger(L, obj->Flags);
    return 1;
  }
  if (strcmp(key, "SuperBitMap") == 0) {
    struct BitMap **ud = (struct BitMap **)lua_newuserdata(L, sizeof(struct BitMap *));
    *ud = (struct BitMap*)obj->SuperBitMap;
    luaL_getmetatable(L, "BitMap");
    lua_setmetatable(L, -2);
    return 1;
  }
  // Unsupported SuperClipRect struct ClipRect *
  if (strcmp(key, "SuperClipRect") == 0) {
    return luaL_error(L, "Unsupported type struct ClipRect * for field SuperClipRect");
  }
  if (strcmp(key, "Window") == 0) {
    lua_pushlightuserdata(L, obj->Window);
    return 1;
  }
  if (strcmp(key, "Scroll_X") == 0) {
    lua_pushinteger(L, obj->Scroll_X);
    return 1;
  }
  if (strcmp(key, "Scroll_Y") == 0) {
    lua_pushinteger(L, obj->Scroll_Y);
    return 1;
  }
  // Unsupported OnScreen struct ClipRect *
  if (strcmp(key, "OnScreen") == 0) {
    return luaL_error(L, "Unsupported type struct ClipRect * for field OnScreen");
  }
  // Unsupported OffScreen struct ClipRect *
  if (strcmp(key, "OffScreen") == 0) {
    return luaL_error(L, "Unsupported type struct ClipRect * for field OffScreen");
  }
  // Unsupported Backup struct ClipRect *
  if (strcmp(key, "Backup") == 0) {
    return luaL_error(L, "Unsupported type struct ClipRect * for field Backup");
  }
  // Unsupported SuperSaveClipRects struct ClipRect *
  if (strcmp(key, "SuperSaveClipRects") == 0) {
    return luaL_error(L, "Unsupported type struct ClipRect * for field SuperSaveClipRects");
  }
  // Unsupported Undamaged struct ClipRect *
  if (strcmp(key, "Undamaged") == 0) {
    return luaL_error(L, "Unsupported type struct ClipRect * for field Undamaged");
  }
  // Unsupported LayerInfo struct Layer_Info *
  if (strcmp(key, "LayerInfo") == 0) {
    return luaL_error(L, "Unsupported type struct Layer_Info * for field LayerInfo");
  }
  // Unsupported Lock.ss_Link.ln_Succ struct Node *
  if (strcmp(key, "Lock.ss_Link.ln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field Lock.ss_Link.ln_Succ");
  }
  // Unsupported Lock.ss_Link.ln_Pred struct Node *
  if (strcmp(key, "Lock.ss_Link.ln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field Lock.ss_Link.ln_Pred");
  }
  if (strcmp(key, "Lock.ss_Link.ln_Type") == 0) {
    lua_pushinteger(L, obj->Lock.ss_Link.ln_Type);
    return 1;
  }
  if (strcmp(key, "Lock.ss_Link.ln_Pri") == 0) {
    lua_pushinteger(L, obj->Lock.ss_Link.ln_Pri);
    return 1;
  }
  if (strcmp(key, "Lock.ss_Link.ln_Name") == 0) {
    lua_pushstring(L, obj->Lock.ss_Link.ln_Name);
    return 1;
  }
  // Unsupported Lock.ss_Link struct Node
  if (strcmp(key, "Lock.ss_Link") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field Lock.ss_Link");
  }
  if (strcmp(key, "Lock.ss_NestCount") == 0) {
    lua_pushinteger(L, obj->Lock.ss_NestCount);
    return 1;
  }
  // Unsupported Lock.ss_WaitQueue.mlh_Head struct MinNode *
  if (strcmp(key, "Lock.ss_WaitQueue.mlh_Head") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode * for field Lock.ss_WaitQueue.mlh_Head");
  }
  // Unsupported Lock.ss_WaitQueue.mlh_Tail struct MinNode *
  if (strcmp(key, "Lock.ss_WaitQueue.mlh_Tail") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode * for field Lock.ss_WaitQueue.mlh_Tail");
  }
  // Unsupported Lock.ss_WaitQueue.mlh_TailPred struct MinNode *
  if (strcmp(key, "Lock.ss_WaitQueue.mlh_TailPred") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode * for field Lock.ss_WaitQueue.mlh_TailPred");
  }
  // Unsupported Lock.ss_WaitQueue struct MinList
  if (strcmp(key, "Lock.ss_WaitQueue") == 0) {
    return luaL_error(L, "Unsupported type struct MinList for field Lock.ss_WaitQueue");
  }
  // Unsupported Lock.ss_MultipleLink.sr_Link.mln_Succ struct MinNode *
  if (strcmp(key, "Lock.ss_MultipleLink.sr_Link.mln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode * for field Lock.ss_MultipleLink.sr_Link.mln_Succ");
  }
  // Unsupported Lock.ss_MultipleLink.sr_Link.mln_Pred struct MinNode *
  if (strcmp(key, "Lock.ss_MultipleLink.sr_Link.mln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode * for field Lock.ss_MultipleLink.sr_Link.mln_Pred");
  }
  // Unsupported Lock.ss_MultipleLink.sr_Link struct MinNode
  if (strcmp(key, "Lock.ss_MultipleLink.sr_Link") == 0) {
    return luaL_error(L, "Unsupported type struct MinNode for field Lock.ss_MultipleLink.sr_Link");
  }
  // Unsupported Lock.ss_MultipleLink.sr_Waiter struct Task *
  if (strcmp(key, "Lock.ss_MultipleLink.sr_Waiter") == 0) {
    return luaL_error(L, "Unsupported type struct Task * for field Lock.ss_MultipleLink.sr_Waiter");
  }
  // Unsupported Lock.ss_MultipleLink struct SemaphoreRequest
  if (strcmp(key, "Lock.ss_MultipleLink") == 0) {
    return luaL_error(L, "Unsupported type struct SemaphoreRequest for field Lock.ss_MultipleLink");
  }
  // Unsupported Lock.ss_Owner struct Task *
  if (strcmp(key, "Lock.ss_Owner") == 0) {
    return luaL_error(L, "Unsupported type struct Task * for field Lock.ss_Owner");
  }
  if (strcmp(key, "Lock.ss_QueueCount") == 0) {
    lua_pushinteger(L, obj->Lock.ss_QueueCount);
    return 1;
  }
  // Unsupported Lock struct SignalSemaphore
  if (strcmp(key, "Lock") == 0) {
    return luaL_error(L, "Unsupported type struct SignalSemaphore for field Lock");
  }
  // Unsupported BackFill struct Hook *
  if (strcmp(key, "BackFill") == 0) {
    return luaL_error(L, "Unsupported type struct Hook * for field BackFill");
  }
  if (strcmp(key, "reserved1") == 0) {
    lua_pushinteger(L, obj->reserved1);
    return 1;
  }
  if (strcmp(key, "ClipRegion") == 0) {
    struct Region **ud = (struct Region **)lua_newuserdata(L, sizeof(struct Region *));
    *ud = (struct Region*)obj->ClipRegion;
    luaL_getmetatable(L, "Region");
    lua_setmetatable(L, -2);
    return 1;
  }
  // Unsupported clipped struct ClipRect *
  if (strcmp(key, "clipped") == 0) {
    return luaL_error(L, "Unsupported type struct ClipRect * for field clipped");
  }
  if (strcmp(key, "Width") == 0) {
    lua_pushinteger(L, obj->Width);
    return 1;
  }
  if (strcmp(key, "Height") == 0) {
    lua_pushinteger(L, obj->Height);
    return 1;
  }
  if (strcmp(key, "reserved2") == 0) {
    _lua_gen_push_UBYTE_array_proxy(L, obj->reserved2, 18);
    return 1;
  }
  if (strcmp(key, "DamageList") == 0) {
    struct Region **ud = (struct Region **)lua_newuserdata(L, sizeof(struct Region *));
    *ud = (struct Region*)obj->DamageList;
    luaL_getmetatable(L, "Region");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct Layer));
    return 1;
}

  return 0;
}

static void
_lua_gen_Layer_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "bounds.MinX");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "bounds.MinY");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "bounds.MaxX");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "bounds.MaxY");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "priority");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "Flags");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "Window");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "Scroll_X");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "Scroll_Y");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "Lock.ss_Link.ln_Type");
  lua_rawseti(L, -2, 10);
  lua_pushstring(L, "Lock.ss_Link.ln_Pri");
  lua_rawseti(L, -2, 11);
  lua_pushstring(L, "Lock.ss_Link.ln_Name");
  lua_rawseti(L, -2, 12);
  lua_pushstring(L, "Lock.ss_NestCount");
  lua_rawseti(L, -2, 13);
  lua_pushstring(L, "Lock.ss_QueueCount");
  lua_rawseti(L, -2, 14);
  lua_pushstring(L, "reserved1");
  lua_rawseti(L, -2, 15);
  lua_pushstring(L, "Width");
  lua_rawseti(L, -2, 16);
  lua_pushstring(L, "Height");
  lua_rawseti(L, -2, 17);
  lua_pushstring(L, "reserved2");
  lua_rawseti(L, -2, 18);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_Layer(lua_State *L) {
  if (luaL_newmetatable(L, "Layer")) {
    lua_pushcfunction(L, _lua_gen_Layer_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_Layer_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_Layer_constructor);
    lua_setglobal(L, "Layer");
    _lua_gen_Layer_install_keys(L);
    lua_pushstring(L, "Layer");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

typedef struct {
  ULONG* data;
  uint16_t count;
} lua_gen_wrapped_ULONG_array_data_t;

static int _lua_gen_wrapped_ULONG_array_ptr_method(lua_State* L) {
    lua_gen_wrapped_ULONG_array_data_t* wrapper = luaL_checkudata(L, 1, "ULONG_array_proxy");
    int index = luaL_checkinteger(L, 2);
    void* ptr = &wrapper->data[index - 1];
    lua_pushlightuserdata(L, ptr);
    return 1;
}
static int
_lua_gen_wrapped_ULONG_array_index(lua_State* L)
{
  lua_gen_wrapped_ULONG_array_data_t* wrapper = luaL_checkudata(L, 1, "ULONG_array_proxy");
  if (lua_isinteger(L, 2)) {
    int index = lua_tointeger(L, 2);
    if (index < 1 || index > wrapper->count)
      return luaL_error(L, "index out of range (1..%d)", wrapper->count);
    lua_pushinteger(L, wrapper->data[index - 1]);
    return 1;
  }

  // Not a numeric key? Try methods
  lua_getmetatable(L, 1);
  lua_getfield(L, -1, "__methods");
  lua_pushvalue(L, 2);
  lua_gettable(L, -2);
  return 1;
}

static int
_lua_gen_wrapped_ULONG_array_newindex(lua_State* L)
{
  lua_gen_wrapped_ULONG_array_data_t* wrapper = luaL_checkudata(L, 1, "ULONG_array_proxy");
  if (!lua_isinteger(L, 2))
    return luaL_error(L, "only integer indices allowed");
  int index = lua_tointeger(L, 2);
  if (index < 1 || index > wrapper->count)
    return luaL_error(L, "index out of range (1..%d)", wrapper->count);
  ULONG value = luaL_checkinteger(L,  3);
  wrapper->data[index - 1] = value;
  return 0;
}

static void
_lua_gen_push_ULONG_array_proxy(lua_State *L,  ULONG *array, int count)
{

  lua_gen_wrapped_ULONG_array_data_t* wrapper = lua_newuserdata(L, sizeof(lua_gen_wrapped_ULONG_array_data_t));
  wrapper->data = array;
  wrapper->count = count;

  if (luaL_newmetatable(L, "ULONG_array_proxy")) {
    // Create method table
    lua_newtable(L);
    lua_pushcfunction(L, _lua_gen_wrapped_ULONG_array_ptr_method);
    lua_setfield(L, -2, "ptr");
    lua_setfield(L, -2, "__methods");

    // __index handles both numeric and method lookup
    lua_pushcfunction(L, _lua_gen_wrapped_ULONG_array_index);
    lua_setfield(L, -2, "__index");

    // __newindex for writing
    lua_pushcfunction(L, _lua_gen_wrapped_ULONG_array_newindex);
    lua_setfield(L, -2, "__newindex");
  }

  lua_setmetatable(L, -2);  // assign to userdata

}
static int
_lua_gen_RastPort_newindex(lua_State *L)
{
  struct RastPort *obj = *(struct RastPort **)luaL_checkudata(L, 1, "RastPort");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "Layer") == 0) {
    // finder 1
    //obj->Layer = *(struct Layer **)luaL_checkudata(L, 3, "Layer");
    obj->Layer = (struct Layer *)_lua_gen_checkLayer(L, 3);
    return 0;
  }
  if (strcmp(key, "BitMap") == 0) {
    // finder 1
    //obj->BitMap = *(struct BitMap **)luaL_checkudata(L, 3, "BitMap");
    obj->BitMap = (struct BitMap *)_lua_gen_checkBitMap(L, 3);
    return 0;
  }
  if (strcmp(key, "AreaPtrn") == 0) {
    obj->AreaPtrn = (UWORD *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "TmpRas") == 0) {
    // finder 1
    //obj->TmpRas = *(struct TmpRas **)luaL_checkudata(L, 3, "TmpRas");
    obj->TmpRas = (struct TmpRas *)_lua_gen_checkTmpRas(L, 3);
    return 0;
  }
  if (strcmp(key, "AreaInfo") == 0) {
    // finder 1
    //obj->AreaInfo = *(struct AreaInfo **)luaL_checkudata(L, 3, "AreaInfo");
    obj->AreaInfo = (struct AreaInfo *)_lua_gen_checkAreaInfo(L, 3);
    return 0;
  }
  if (strcmp(key, "GelsInfo") == 0) {
    // finder 1
    //obj->GelsInfo = *(struct GelsInfo **)luaL_checkudata(L, 3, "GelsInfo");
    obj->GelsInfo = (struct GelsInfo *)_lua_gen_checkGelsInfo(L, 3);
    return 0;
  }
  if (strcmp(key, "Mask") == 0) {
    obj->Mask = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "FgPen") == 0) {
    obj->FgPen = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "BgPen") == 0) {
    obj->BgPen = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "AOlPen") == 0) {
    obj->AOlPen = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DrawMode") == 0) {
    obj->DrawMode = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "AreaPtSz") == 0) {
    obj->AreaPtSz = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "linpatcnt") == 0) {
    obj->linpatcnt = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "dummy") == 0) {
    obj->dummy = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Flags") == 0) {
    obj->Flags = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "LinePtrn") == 0) {
    obj->LinePtrn = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "cp_x") == 0) {
    obj->cp_x = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "cp_y") == 0) {
    obj->cp_y = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // minterms[8] proxied via the index
  if (strcmp(key, "PenWidth") == 0) {
    obj->PenWidth = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "PenHeight") == 0) {
    obj->PenHeight = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Font") == 0) {
    // finder 1
    //obj->Font = *(struct TextFont **)luaL_checkudata(L, 3, "TextFont");
    obj->Font = (struct TextFont *)_lua_gen_checkTextFont(L, 3);
    return 0;
  }
  if (strcmp(key, "AlgoStyle") == 0) {
    obj->AlgoStyle = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "TxFlags") == 0) {
    obj->TxFlags = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "TxHeight") == 0) {
    obj->TxHeight = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "TxWidth") == 0) {
    obj->TxWidth = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "TxBaseline") == 0) {
    obj->TxBaseline = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "TxSpacing") == 0) {
    obj->TxSpacing = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "RP_User") == 0) {
    obj->RP_User = (APTR *)lua_touserdata(L, 3);
    return 0;
  }
  // longreserved[2] proxied via the index
  // wordreserved[7] proxied via the index
  // reserved[8] proxied via the index
  return 0;
}


static int
_lua_RastPort_constructor(lua_State *L)
{
  // Allocate pointer-to-struct RastPort in userdata
  struct RastPort **objp = lua_newuserdata(L, sizeof(struct RastPort *));
  *objp = malloc(sizeof(struct RastPort));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct RastPort));

  // Set metatable
  luaL_getmetatable(L, "RastPort");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_RastPort_index(lua_State *L)
{
  struct RastPort *obj = *(struct RastPort **)luaL_checkudata(L, 1, "RastPort");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "Layer") == 0) {
    struct Layer **ud = (struct Layer **)lua_newuserdata(L, sizeof(struct Layer *));
    *ud = (struct Layer*)obj->Layer;
    luaL_getmetatable(L, "Layer");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "BitMap") == 0) {
    struct BitMap **ud = (struct BitMap **)lua_newuserdata(L, sizeof(struct BitMap *));
    *ud = (struct BitMap*)obj->BitMap;
    luaL_getmetatable(L, "BitMap");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "AreaPtrn") == 0) {
    lua_pushlightuserdata(L, obj->AreaPtrn);
    return 1;
  }
  if (strcmp(key, "TmpRas") == 0) {
    struct TmpRas **ud = (struct TmpRas **)lua_newuserdata(L, sizeof(struct TmpRas *));
    *ud = (struct TmpRas*)obj->TmpRas;
    luaL_getmetatable(L, "TmpRas");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "AreaInfo") == 0) {
    struct AreaInfo **ud = (struct AreaInfo **)lua_newuserdata(L, sizeof(struct AreaInfo *));
    *ud = (struct AreaInfo*)obj->AreaInfo;
    luaL_getmetatable(L, "AreaInfo");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "GelsInfo") == 0) {
    struct GelsInfo **ud = (struct GelsInfo **)lua_newuserdata(L, sizeof(struct GelsInfo *));
    *ud = (struct GelsInfo*)obj->GelsInfo;
    luaL_getmetatable(L, "GelsInfo");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "Mask") == 0) {
    lua_pushinteger(L, obj->Mask);
    return 1;
  }
  if (strcmp(key, "FgPen") == 0) {
    lua_pushinteger(L, obj->FgPen);
    return 1;
  }
  if (strcmp(key, "BgPen") == 0) {
    lua_pushinteger(L, obj->BgPen);
    return 1;
  }
  if (strcmp(key, "AOlPen") == 0) {
    lua_pushinteger(L, obj->AOlPen);
    return 1;
  }
  if (strcmp(key, "DrawMode") == 0) {
    lua_pushinteger(L, obj->DrawMode);
    return 1;
  }
  if (strcmp(key, "AreaPtSz") == 0) {
    lua_pushinteger(L, obj->AreaPtSz);
    return 1;
  }
  if (strcmp(key, "linpatcnt") == 0) {
    lua_pushinteger(L, obj->linpatcnt);
    return 1;
  }
  if (strcmp(key, "dummy") == 0) {
    lua_pushinteger(L, obj->dummy);
    return 1;
  }
  if (strcmp(key, "Flags") == 0) {
    lua_pushinteger(L, obj->Flags);
    return 1;
  }
  if (strcmp(key, "LinePtrn") == 0) {
    lua_pushinteger(L, obj->LinePtrn);
    return 1;
  }
  if (strcmp(key, "cp_x") == 0) {
    lua_pushinteger(L, obj->cp_x);
    return 1;
  }
  if (strcmp(key, "cp_y") == 0) {
    lua_pushinteger(L, obj->cp_y);
    return 1;
  }
  if (strcmp(key, "minterms") == 0) {
    _lua_gen_push_UBYTE_array_proxy(L, obj->minterms, 8);
    return 1;
  }
  if (strcmp(key, "PenWidth") == 0) {
    lua_pushinteger(L, obj->PenWidth);
    return 1;
  }
  if (strcmp(key, "PenHeight") == 0) {
    lua_pushinteger(L, obj->PenHeight);
    return 1;
  }
  if (strcmp(key, "Font") == 0) {
    struct TextFont **ud = (struct TextFont **)lua_newuserdata(L, sizeof(struct TextFont *));
    *ud = (struct TextFont*)obj->Font;
    luaL_getmetatable(L, "TextFont");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "AlgoStyle") == 0) {
    lua_pushinteger(L, obj->AlgoStyle);
    return 1;
  }
  if (strcmp(key, "TxFlags") == 0) {
    lua_pushinteger(L, obj->TxFlags);
    return 1;
  }
  if (strcmp(key, "TxHeight") == 0) {
    lua_pushinteger(L, obj->TxHeight);
    return 1;
  }
  if (strcmp(key, "TxWidth") == 0) {
    lua_pushinteger(L, obj->TxWidth);
    return 1;
  }
  if (strcmp(key, "TxBaseline") == 0) {
    lua_pushinteger(L, obj->TxBaseline);
    return 1;
  }
  if (strcmp(key, "TxSpacing") == 0) {
    lua_pushinteger(L, obj->TxSpacing);
    return 1;
  }
  if (strcmp(key, "RP_User") == 0) {
    lua_pushlightuserdata(L, obj->RP_User);
    return 1;
  }
  if (strcmp(key, "longreserved") == 0) {
    _lua_gen_push_ULONG_array_proxy(L, obj->longreserved, 2);
    return 1;
  }
  if (strcmp(key, "wordreserved") == 0) {
    _lua_gen_push_UWORD_array_proxy(L, obj->wordreserved, 7);
    return 1;
  }
  if (strcmp(key, "reserved") == 0) {
    _lua_gen_push_UBYTE_array_proxy(L, obj->reserved, 8);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct RastPort));
    return 1;
}

  return 0;
}

static void
_lua_gen_RastPort_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "AreaPtrn");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "Mask");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "FgPen");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "BgPen");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "AOlPen");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "DrawMode");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "AreaPtSz");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "linpatcnt");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "dummy");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "Flags");
  lua_rawseti(L, -2, 10);
  lua_pushstring(L, "LinePtrn");
  lua_rawseti(L, -2, 11);
  lua_pushstring(L, "cp_x");
  lua_rawseti(L, -2, 12);
  lua_pushstring(L, "cp_y");
  lua_rawseti(L, -2, 13);
  lua_pushstring(L, "minterms");
  lua_rawseti(L, -2, 14);
  lua_pushstring(L, "PenWidth");
  lua_rawseti(L, -2, 15);
  lua_pushstring(L, "PenHeight");
  lua_rawseti(L, -2, 16);
  lua_pushstring(L, "AlgoStyle");
  lua_rawseti(L, -2, 17);
  lua_pushstring(L, "TxFlags");
  lua_rawseti(L, -2, 18);
  lua_pushstring(L, "TxHeight");
  lua_rawseti(L, -2, 19);
  lua_pushstring(L, "TxWidth");
  lua_rawseti(L, -2, 20);
  lua_pushstring(L, "TxBaseline");
  lua_rawseti(L, -2, 21);
  lua_pushstring(L, "TxSpacing");
  lua_rawseti(L, -2, 22);
  lua_pushstring(L, "RP_User");
  lua_rawseti(L, -2, 23);
  lua_pushstring(L, "longreserved");
  lua_rawseti(L, -2, 24);
  lua_pushstring(L, "wordreserved");
  lua_rawseti(L, -2, 25);
  lua_pushstring(L, "reserved");
  lua_rawseti(L, -2, 26);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_RastPort(lua_State *L) {
  if (luaL_newmetatable(L, "RastPort")) {
    lua_pushcfunction(L, _lua_gen_RastPort_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_RastPort_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_RastPort_constructor);
    lua_setglobal(L, "RastPort");
    _lua_gen_RastPort_install_keys(L);
    lua_pushstring(L, "RastPort");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_Region_newindex(lua_State *L)
{
  struct Region *obj = *(struct Region **)luaL_checkudata(L, 1, "Region");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "bounds.MinX") == 0) {
    obj->bounds.MinX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bounds.MinY") == 0) {
    obj->bounds.MinY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bounds.MaxX") == 0) {
    obj->bounds.MaxX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bounds.MaxY") == 0) {
    obj->bounds.MaxY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bounds") == 0) {
    // finder 0
    struct Rectangle *val = *(struct Rectangle **)luaL_checkudata(L, 3, "Rectangle");
    obj->bounds = *val;
    return 0;
  }
  if (strcmp(key, "RegionRectangle") == 0) {
    // finder 1
    //obj->RegionRectangle = *(struct RegionRectangle **)luaL_checkudata(L, 3, "RegionRectangle");
    obj->RegionRectangle = (struct RegionRectangle *)_lua_gen_checkRegionRectangle(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_Region_constructor(lua_State *L)
{
  // Allocate pointer-to-struct Region in userdata
  struct Region **objp = lua_newuserdata(L, sizeof(struct Region *));
  *objp = malloc(sizeof(struct Region));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct Region));

  // Set metatable
  luaL_getmetatable(L, "Region");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_Region_index(lua_State *L)
{
  struct Region *obj = *(struct Region **)luaL_checkudata(L, 1, "Region");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "bounds.MinX") == 0) {
    lua_pushinteger(L, obj->bounds.MinX);
    return 1;
  }
  if (strcmp(key, "bounds.MinY") == 0) {
    lua_pushinteger(L, obj->bounds.MinY);
    return 1;
  }
  if (strcmp(key, "bounds.MaxX") == 0) {
    lua_pushinteger(L, obj->bounds.MaxX);
    return 1;
  }
  if (strcmp(key, "bounds.MaxY") == 0) {
    lua_pushinteger(L, obj->bounds.MaxY);
    return 1;
  }
  if (strcmp(key, "bounds") == 0) {
    struct Rectangle **ud = (struct Rectangle **)lua_newuserdata(L, sizeof(struct Rectangle *));
    *ud = (struct Rectangle*)&obj->bounds;
    luaL_getmetatable(L, "Rectangle");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "RegionRectangle") == 0) {
    struct RegionRectangle **ud = (struct RegionRectangle **)lua_newuserdata(L, sizeof(struct RegionRectangle *));
    *ud = (struct RegionRectangle*)obj->RegionRectangle;
    luaL_getmetatable(L, "RegionRectangle");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct Region));
    return 1;
}

  return 0;
}

static void
_lua_gen_Region_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "bounds.MinX");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "bounds.MinY");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "bounds.MaxX");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "bounds.MaxY");
  lua_rawseti(L, -2, 4);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_Region(lua_State *L) {
  if (luaL_newmetatable(L, "Region")) {
    lua_pushcfunction(L, _lua_gen_Region_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_Region_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_Region_constructor);
    lua_setglobal(L, "Region");
    _lua_gen_Region_install_keys(L);
    lua_pushstring(L, "Region");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_SimpleSprite_newindex(lua_State *L)
{
  struct SimpleSprite *obj = *(struct SimpleSprite **)luaL_checkudata(L, 1, "SimpleSprite");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "posctldata") == 0) {
    obj->posctldata = (UWORD *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "height") == 0) {
    obj->height = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "x") == 0) {
    obj->x = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "y") == 0) {
    obj->y = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "num") == 0) {
    obj->num = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_SimpleSprite_constructor(lua_State *L)
{
  // Allocate pointer-to-struct SimpleSprite in userdata
  struct SimpleSprite **objp = lua_newuserdata(L, sizeof(struct SimpleSprite *));
  *objp = malloc(sizeof(struct SimpleSprite));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct SimpleSprite));

  // Set metatable
  luaL_getmetatable(L, "SimpleSprite");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_SimpleSprite_index(lua_State *L)
{
  struct SimpleSprite *obj = *(struct SimpleSprite **)luaL_checkudata(L, 1, "SimpleSprite");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "posctldata") == 0) {
    lua_pushlightuserdata(L, obj->posctldata);
    return 1;
  }
  if (strcmp(key, "height") == 0) {
    lua_pushinteger(L, obj->height);
    return 1;
  }
  if (strcmp(key, "x") == 0) {
    lua_pushinteger(L, obj->x);
    return 1;
  }
  if (strcmp(key, "y") == 0) {
    lua_pushinteger(L, obj->y);
    return 1;
  }
  if (strcmp(key, "num") == 0) {
    lua_pushinteger(L, obj->num);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct SimpleSprite));
    return 1;
}

  return 0;
}

static void
_lua_gen_SimpleSprite_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "posctldata");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "height");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "x");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "y");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "num");
  lua_rawseti(L, -2, 5);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_SimpleSprite(lua_State *L) {
  if (luaL_newmetatable(L, "SimpleSprite")) {
    lua_pushcfunction(L, _lua_gen_SimpleSprite_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_SimpleSprite_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_SimpleSprite_constructor);
    lua_setglobal(L, "SimpleSprite");
    _lua_gen_SimpleSprite_install_keys(L);
    lua_pushstring(L, "SimpleSprite");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_TextAttr_newindex(lua_State *L)
{
  struct TextAttr *obj = *(struct TextAttr **)luaL_checkudata(L, 1, "TextAttr");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "ta_Name") == 0) {
    obj->ta_Name = (STRPTR)amiga_checkNullableString(L, 3);
    return 0;
  }
  if (strcmp(key, "ta_YSize") == 0) {
    obj->ta_YSize = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ta_Style") == 0) {
    obj->ta_Style = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ta_Flags") == 0) {
    obj->ta_Flags = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_TextAttr_constructor(lua_State *L)
{
  // Allocate pointer-to-struct TextAttr in userdata
  struct TextAttr **objp = lua_newuserdata(L, sizeof(struct TextAttr *));
  *objp = malloc(sizeof(struct TextAttr));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct TextAttr));

  // Set metatable
  luaL_getmetatable(L, "TextAttr");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_TextAttr_index(lua_State *L)
{
  struct TextAttr *obj = *(struct TextAttr **)luaL_checkudata(L, 1, "TextAttr");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "ta_Name") == 0) {
    lua_pushstring(L, obj->ta_Name);
    return 1;
  }
  if (strcmp(key, "ta_YSize") == 0) {
    lua_pushinteger(L, obj->ta_YSize);
    return 1;
  }
  if (strcmp(key, "ta_Style") == 0) {
    lua_pushinteger(L, obj->ta_Style);
    return 1;
  }
  if (strcmp(key, "ta_Flags") == 0) {
    lua_pushinteger(L, obj->ta_Flags);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct TextAttr));
    return 1;
}

  return 0;
}

static void
_lua_gen_TextAttr_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "ta_Name");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "ta_YSize");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "ta_Style");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "ta_Flags");
  lua_rawseti(L, -2, 4);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_TextAttr(lua_State *L) {
  if (luaL_newmetatable(L, "TextAttr")) {
    lua_pushcfunction(L, _lua_gen_TextAttr_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_TextAttr_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_TextAttr_constructor);
    lua_setglobal(L, "TextAttr");
    _lua_gen_TextAttr_install_keys(L);
    lua_pushstring(L, "TextAttr");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_TextFont_newindex(lua_State *L)
{
  struct TextFont *obj = *(struct TextFont **)luaL_checkudata(L, 1, "TextFont");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  // Unsupported type tf_Message.mn_Node.ln_Succ struct Node
  if (strcmp(key, "tf_Message.mn_Node.ln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field tf_Message.mn_Node.ln_Succ");
  }
  // Unsupported type tf_Message.mn_Node.ln_Pred struct Node
  if (strcmp(key, "tf_Message.mn_Node.ln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field tf_Message.mn_Node.ln_Pred");
  }
  if (strcmp(key, "tf_Message.mn_Node.ln_Type") == 0) {
    obj->tf_Message.mn_Node.ln_Type = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_Message.mn_Node.ln_Pri") == 0) {
    obj->tf_Message.mn_Node.ln_Pri = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_Message.mn_Node.ln_Name") == 0) {
    obj->tf_Message.mn_Node.ln_Name = (char *)luaL_checkstring(L, 3);
    return 0;
  }
  // Unsupported type tf_Message.mn_Node struct Node
  if (strcmp(key, "tf_Message.mn_Node") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field tf_Message.mn_Node");
  }
  // Unsupported type tf_Message.mn_ReplyPort struct MsgPort
  if (strcmp(key, "tf_Message.mn_ReplyPort") == 0) {
    return luaL_error(L, "Unsupported type struct MsgPort for field tf_Message.mn_ReplyPort");
  }
  if (strcmp(key, "tf_Message.mn_Length") == 0) {
    obj->tf_Message.mn_Length = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type tf_Message struct Message
  if (strcmp(key, "tf_Message") == 0) {
    return luaL_error(L, "Unsupported type struct Message for field tf_Message");
  }
  if (strcmp(key, "tf_YSize") == 0) {
    obj->tf_YSize = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_Style") == 0) {
    obj->tf_Style = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_Flags") == 0) {
    obj->tf_Flags = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_XSize") == 0) {
    obj->tf_XSize = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_Baseline") == 0) {
    obj->tf_Baseline = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_BoldSmear") == 0) {
    obj->tf_BoldSmear = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_Accessors") == 0) {
    obj->tf_Accessors = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_LoChar") == 0) {
    obj->tf_LoChar = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_HiChar") == 0) {
    obj->tf_HiChar = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_CharData") == 0) {
    obj->tf_CharData = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_Modulo") == 0) {
    obj->tf_Modulo = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_CharLoc") == 0) {
    obj->tf_CharLoc = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_CharSpace") == 0) {
    obj->tf_CharSpace = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_CharKern") == 0) {
    obj->tf_CharKern = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_TextFont_constructor(lua_State *L)
{
  // Allocate pointer-to-struct TextFont in userdata
  struct TextFont **objp = lua_newuserdata(L, sizeof(struct TextFont *));
  *objp = malloc(sizeof(struct TextFont));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct TextFont));

  // Set metatable
  luaL_getmetatable(L, "TextFont");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_TextFont_index(lua_State *L)
{
  struct TextFont *obj = *(struct TextFont **)luaL_checkudata(L, 1, "TextFont");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  // Unsupported tf_Message.mn_Node.ln_Succ struct Node *
  if (strcmp(key, "tf_Message.mn_Node.ln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field tf_Message.mn_Node.ln_Succ");
  }
  // Unsupported tf_Message.mn_Node.ln_Pred struct Node *
  if (strcmp(key, "tf_Message.mn_Node.ln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field tf_Message.mn_Node.ln_Pred");
  }
  if (strcmp(key, "tf_Message.mn_Node.ln_Type") == 0) {
    lua_pushinteger(L, obj->tf_Message.mn_Node.ln_Type);
    return 1;
  }
  if (strcmp(key, "tf_Message.mn_Node.ln_Pri") == 0) {
    lua_pushinteger(L, obj->tf_Message.mn_Node.ln_Pri);
    return 1;
  }
  if (strcmp(key, "tf_Message.mn_Node.ln_Name") == 0) {
    lua_pushstring(L, obj->tf_Message.mn_Node.ln_Name);
    return 1;
  }
  // Unsupported tf_Message.mn_Node struct Node
  if (strcmp(key, "tf_Message.mn_Node") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field tf_Message.mn_Node");
  }
  // Unsupported tf_Message.mn_ReplyPort struct MsgPort *
  if (strcmp(key, "tf_Message.mn_ReplyPort") == 0) {
    return luaL_error(L, "Unsupported type struct MsgPort * for field tf_Message.mn_ReplyPort");
  }
  if (strcmp(key, "tf_Message.mn_Length") == 0) {
    lua_pushinteger(L, obj->tf_Message.mn_Length);
    return 1;
  }
  // Unsupported tf_Message struct Message
  if (strcmp(key, "tf_Message") == 0) {
    return luaL_error(L, "Unsupported type struct Message for field tf_Message");
  }
  if (strcmp(key, "tf_YSize") == 0) {
    lua_pushinteger(L, obj->tf_YSize);
    return 1;
  }
  if (strcmp(key, "tf_Style") == 0) {
    lua_pushinteger(L, obj->tf_Style);
    return 1;
  }
  if (strcmp(key, "tf_Flags") == 0) {
    lua_pushinteger(L, obj->tf_Flags);
    return 1;
  }
  if (strcmp(key, "tf_XSize") == 0) {
    lua_pushinteger(L, obj->tf_XSize);
    return 1;
  }
  if (strcmp(key, "tf_Baseline") == 0) {
    lua_pushinteger(L, obj->tf_Baseline);
    return 1;
  }
  if (strcmp(key, "tf_BoldSmear") == 0) {
    lua_pushinteger(L, obj->tf_BoldSmear);
    return 1;
  }
  if (strcmp(key, "tf_Accessors") == 0) {
    lua_pushinteger(L, obj->tf_Accessors);
    return 1;
  }
  if (strcmp(key, "tf_LoChar") == 0) {
    lua_pushinteger(L, obj->tf_LoChar);
    return 1;
  }
  if (strcmp(key, "tf_HiChar") == 0) {
    lua_pushinteger(L, obj->tf_HiChar);
    return 1;
  }
  if (strcmp(key, "tf_CharData") == 0) {
    lua_pushlightuserdata(L, obj->tf_CharData);
    return 1;
  }
  if (strcmp(key, "tf_Modulo") == 0) {
    lua_pushinteger(L, obj->tf_Modulo);
    return 1;
  }
  if (strcmp(key, "tf_CharLoc") == 0) {
    lua_pushlightuserdata(L, obj->tf_CharLoc);
    return 1;
  }
  if (strcmp(key, "tf_CharSpace") == 0) {
    lua_pushlightuserdata(L, obj->tf_CharSpace);
    return 1;
  }
  if (strcmp(key, "tf_CharKern") == 0) {
    lua_pushlightuserdata(L, obj->tf_CharKern);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct TextFont));
    return 1;
}

  return 0;
}

static void
_lua_gen_TextFont_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "tf_Message.mn_Node.ln_Type");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "tf_Message.mn_Node.ln_Pri");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "tf_Message.mn_Node.ln_Name");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "tf_Message.mn_Length");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "tf_YSize");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "tf_Style");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "tf_Flags");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "tf_XSize");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "tf_Baseline");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "tf_BoldSmear");
  lua_rawseti(L, -2, 10);
  lua_pushstring(L, "tf_Accessors");
  lua_rawseti(L, -2, 11);
  lua_pushstring(L, "tf_LoChar");
  lua_rawseti(L, -2, 12);
  lua_pushstring(L, "tf_HiChar");
  lua_rawseti(L, -2, 13);
  lua_pushstring(L, "tf_CharData");
  lua_rawseti(L, -2, 14);
  lua_pushstring(L, "tf_Modulo");
  lua_rawseti(L, -2, 15);
  lua_pushstring(L, "tf_CharLoc");
  lua_rawseti(L, -2, 16);
  lua_pushstring(L, "tf_CharSpace");
  lua_rawseti(L, -2, 17);
  lua_pushstring(L, "tf_CharKern");
  lua_rawseti(L, -2, 18);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_TextFont(lua_State *L) {
  if (luaL_newmetatable(L, "TextFont")) {
    lua_pushcfunction(L, _lua_gen_TextFont_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_TextFont_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_TextFont_constructor);
    lua_setglobal(L, "TextFont");
    _lua_gen_TextFont_install_keys(L);
    lua_pushstring(L, "TextFont");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_VSprite_newindex(lua_State *L)
{
  struct VSprite *obj = *(struct VSprite **)luaL_checkudata(L, 1, "VSprite");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "NextVSprite") == 0) {
    // finder 1
    //obj->NextVSprite = *(struct VSprite **)luaL_checkudata(L, 3, "VSprite");
    obj->NextVSprite = (struct VSprite *)_lua_gen_checkVSprite(L, 3);
    return 0;
  }
  if (strcmp(key, "PrevVSprite") == 0) {
    // finder 1
    //obj->PrevVSprite = *(struct VSprite **)luaL_checkudata(L, 3, "VSprite");
    obj->PrevVSprite = (struct VSprite *)_lua_gen_checkVSprite(L, 3);
    return 0;
  }
  if (strcmp(key, "DrawPath") == 0) {
    // finder 1
    //obj->DrawPath = *(struct VSprite **)luaL_checkudata(L, 3, "VSprite");
    obj->DrawPath = (struct VSprite *)_lua_gen_checkVSprite(L, 3);
    return 0;
  }
  if (strcmp(key, "ClearPath") == 0) {
    // finder 1
    //obj->ClearPath = *(struct VSprite **)luaL_checkudata(L, 3, "VSprite");
    obj->ClearPath = (struct VSprite *)_lua_gen_checkVSprite(L, 3);
    return 0;
  }
  if (strcmp(key, "OldY") == 0) {
    obj->OldY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "OldX") == 0) {
    obj->OldX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Flags") == 0) {
    obj->Flags = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Y") == 0) {
    obj->Y = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "X") == 0) {
    obj->X = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Height") == 0) {
    obj->Height = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Width") == 0) {
    obj->Width = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Depth") == 0) {
    obj->Depth = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "MeMask") == 0) {
    obj->MeMask = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "HitMask") == 0) {
    obj->HitMask = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ImageData") == 0) {
    obj->ImageData = (WORD *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "BorderLine") == 0) {
    obj->BorderLine = (WORD *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "CollMask") == 0) {
    obj->CollMask = (WORD *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "SprColors") == 0) {
    obj->SprColors = (WORD *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "VSBob") == 0) {
    // finder 1
    //obj->VSBob = *(struct Bob **)luaL_checkudata(L, 3, "Bob");
    obj->VSBob = (struct Bob *)_lua_gen_checkBob(L, 3);
    return 0;
  }
  if (strcmp(key, "PlanePick") == 0) {
    obj->PlanePick = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "PlaneOnOff") == 0) {
    obj->PlaneOnOff = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "VUserExt") == 0) {
    obj->VUserExt = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_VSprite_constructor(lua_State *L)
{
  // Allocate pointer-to-struct VSprite in userdata
  struct VSprite **objp = lua_newuserdata(L, sizeof(struct VSprite *));
  *objp = malloc(sizeof(struct VSprite));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct VSprite));

  // Set metatable
  luaL_getmetatable(L, "VSprite");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_VSprite_index(lua_State *L)
{
  struct VSprite *obj = *(struct VSprite **)luaL_checkudata(L, 1, "VSprite");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "NextVSprite") == 0) {
    struct VSprite **ud = (struct VSprite **)lua_newuserdata(L, sizeof(struct VSprite *));
    *ud = (struct VSprite*)obj->NextVSprite;
    luaL_getmetatable(L, "VSprite");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "PrevVSprite") == 0) {
    struct VSprite **ud = (struct VSprite **)lua_newuserdata(L, sizeof(struct VSprite *));
    *ud = (struct VSprite*)obj->PrevVSprite;
    luaL_getmetatable(L, "VSprite");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "DrawPath") == 0) {
    struct VSprite **ud = (struct VSprite **)lua_newuserdata(L, sizeof(struct VSprite *));
    *ud = (struct VSprite*)obj->DrawPath;
    luaL_getmetatable(L, "VSprite");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "ClearPath") == 0) {
    struct VSprite **ud = (struct VSprite **)lua_newuserdata(L, sizeof(struct VSprite *));
    *ud = (struct VSprite*)obj->ClearPath;
    luaL_getmetatable(L, "VSprite");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "OldY") == 0) {
    lua_pushinteger(L, obj->OldY);
    return 1;
  }
  if (strcmp(key, "OldX") == 0) {
    lua_pushinteger(L, obj->OldX);
    return 1;
  }
  if (strcmp(key, "Flags") == 0) {
    lua_pushinteger(L, obj->Flags);
    return 1;
  }
  if (strcmp(key, "Y") == 0) {
    lua_pushinteger(L, obj->Y);
    return 1;
  }
  if (strcmp(key, "X") == 0) {
    lua_pushinteger(L, obj->X);
    return 1;
  }
  if (strcmp(key, "Height") == 0) {
    lua_pushinteger(L, obj->Height);
    return 1;
  }
  if (strcmp(key, "Width") == 0) {
    lua_pushinteger(L, obj->Width);
    return 1;
  }
  if (strcmp(key, "Depth") == 0) {
    lua_pushinteger(L, obj->Depth);
    return 1;
  }
  if (strcmp(key, "MeMask") == 0) {
    lua_pushinteger(L, obj->MeMask);
    return 1;
  }
  if (strcmp(key, "HitMask") == 0) {
    lua_pushinteger(L, obj->HitMask);
    return 1;
  }
  if (strcmp(key, "ImageData") == 0) {
    lua_pushlightuserdata(L, obj->ImageData);
    return 1;
  }
  if (strcmp(key, "BorderLine") == 0) {
    lua_pushlightuserdata(L, obj->BorderLine);
    return 1;
  }
  if (strcmp(key, "CollMask") == 0) {
    lua_pushlightuserdata(L, obj->CollMask);
    return 1;
  }
  if (strcmp(key, "SprColors") == 0) {
    lua_pushlightuserdata(L, obj->SprColors);
    return 1;
  }
  if (strcmp(key, "VSBob") == 0) {
    struct Bob **ud = (struct Bob **)lua_newuserdata(L, sizeof(struct Bob *));
    *ud = (struct Bob*)obj->VSBob;
    luaL_getmetatable(L, "Bob");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "PlanePick") == 0) {
    lua_pushinteger(L, obj->PlanePick);
    return 1;
  }
  if (strcmp(key, "PlaneOnOff") == 0) {
    lua_pushinteger(L, obj->PlaneOnOff);
    return 1;
  }
  if (strcmp(key, "VUserExt") == 0) {
    lua_pushinteger(L, obj->VUserExt);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct VSprite));
    return 1;
}

  return 0;
}

static void
_lua_gen_VSprite_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "OldY");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "OldX");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "Flags");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "Y");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "X");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "Height");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "Width");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "Depth");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "MeMask");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "HitMask");
  lua_rawseti(L, -2, 10);
  lua_pushstring(L, "ImageData");
  lua_rawseti(L, -2, 11);
  lua_pushstring(L, "BorderLine");
  lua_rawseti(L, -2, 12);
  lua_pushstring(L, "CollMask");
  lua_rawseti(L, -2, 13);
  lua_pushstring(L, "SprColors");
  lua_rawseti(L, -2, 14);
  lua_pushstring(L, "PlanePick");
  lua_rawseti(L, -2, 15);
  lua_pushstring(L, "PlaneOnOff");
  lua_rawseti(L, -2, 16);
  lua_pushstring(L, "VUserExt");
  lua_rawseti(L, -2, 17);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_VSprite(lua_State *L) {
  if (luaL_newmetatable(L, "VSprite")) {
    lua_pushcfunction(L, _lua_gen_VSprite_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_VSprite_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_VSprite_constructor);
    lua_setglobal(L, "VSprite");
    _lua_gen_VSprite_install_keys(L);
    lua_pushstring(L, "VSprite");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_bltnode_newindex(lua_State *L)
{
  struct bltnode *obj = *(struct bltnode **)luaL_checkudata(L, 1, "bltnode");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "n") == 0) {
    // finder 1
    //obj->n = *(struct bltnode **)luaL_checkudata(L, 3, "bltnode");
    obj->n = (struct bltnode *)_lua_gen_checkbltnode(L, 3);
    return 0;
  }
  // Unsupported type function int ()()
  if (strcmp(key, "function") == 0) {
    return luaL_error(L, "Unsupported type int ()() for field function");
  }
  if (strcmp(key, "stat") == 0) {
    obj->stat = (char)luaL_checknumber(L, 3);
    return 0;
  }
  if (strcmp(key, "blitsize") == 0) {
    obj->blitsize = (short)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "beamsync") == 0) {
    obj->beamsync = (short)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type cleanup int ()()
  if (strcmp(key, "cleanup") == 0) {
    return luaL_error(L, "Unsupported type int ()() for field cleanup");
  }
  return 0;
}


static int
_lua_bltnode_constructor(lua_State *L)
{
  // Allocate pointer-to-struct bltnode in userdata
  struct bltnode **objp = lua_newuserdata(L, sizeof(struct bltnode *));
  *objp = malloc(sizeof(struct bltnode));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct bltnode));

  // Set metatable
  luaL_getmetatable(L, "bltnode");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_bltnode_index(lua_State *L)
{
  struct bltnode *obj = *(struct bltnode **)luaL_checkudata(L, 1, "bltnode");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "n") == 0) {
    struct bltnode **ud = (struct bltnode **)lua_newuserdata(L, sizeof(struct bltnode *));
    *ud = (struct bltnode*)obj->n;
    luaL_getmetatable(L, "bltnode");
    lua_setmetatable(L, -2);
    return 1;
  }
  // Unsupported function int (*)()
  if (strcmp(key, "function") == 0) {
    return luaL_error(L, "Unsupported type int (*)() for field function");
  }
  if (strcmp(key, "stat") == 0) {
    lua_pushnumber(L, obj->stat);
    return 1;
  }
  if (strcmp(key, "blitsize") == 0) {
    lua_pushinteger(L, obj->blitsize);
    return 1;
  }
  if (strcmp(key, "beamsync") == 0) {
    lua_pushinteger(L, obj->beamsync);
    return 1;
  }
  // Unsupported cleanup int (*)()
  if (strcmp(key, "cleanup") == 0) {
    return luaL_error(L, "Unsupported type int (*)() for field cleanup");
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct bltnode));
    return 1;
}

  return 0;
}

static void
_lua_gen_bltnode_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "function");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "stat");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "blitsize");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "beamsync");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "cleanup");
  lua_rawseti(L, -2, 5);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_bltnode(lua_State *L) {
  if (luaL_newmetatable(L, "bltnode")) {
    lua_pushcfunction(L, _lua_gen_bltnode_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_bltnode_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_bltnode_constructor);
    lua_setglobal(L, "bltnode");
    _lua_gen_bltnode_install_keys(L);
    lua_pushstring(L, "bltnode");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_RegionRectangle_newindex(lua_State *L)
{
  struct RegionRectangle *obj = *(struct RegionRectangle **)luaL_checkudata(L, 1, "RegionRectangle");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "Next") == 0) {
    // finder 1
    //obj->Next = *(struct RegionRectangle **)luaL_checkudata(L, 3, "RegionRectangle");
    obj->Next = (struct RegionRectangle *)_lua_gen_checkRegionRectangle(L, 3);
    return 0;
  }
  if (strcmp(key, "Prev") == 0) {
    // finder 1
    //obj->Prev = *(struct RegionRectangle **)luaL_checkudata(L, 3, "RegionRectangle");
    obj->Prev = (struct RegionRectangle *)_lua_gen_checkRegionRectangle(L, 3);
    return 0;
  }
  if (strcmp(key, "bounds.MinX") == 0) {
    obj->bounds.MinX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bounds.MinY") == 0) {
    obj->bounds.MinY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bounds.MaxX") == 0) {
    obj->bounds.MaxX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bounds.MaxY") == 0) {
    obj->bounds.MaxY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bounds") == 0) {
    // finder 0
    struct Rectangle *val = *(struct Rectangle **)luaL_checkudata(L, 3, "Rectangle");
    obj->bounds = *val;
    return 0;
  }
  return 0;
}


static int
_lua_RegionRectangle_constructor(lua_State *L)
{
  // Allocate pointer-to-struct RegionRectangle in userdata
  struct RegionRectangle **objp = lua_newuserdata(L, sizeof(struct RegionRectangle *));
  *objp = malloc(sizeof(struct RegionRectangle));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct RegionRectangle));

  // Set metatable
  luaL_getmetatable(L, "RegionRectangle");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_RegionRectangle_index(lua_State *L)
{
  struct RegionRectangle *obj = *(struct RegionRectangle **)luaL_checkudata(L, 1, "RegionRectangle");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "Next") == 0) {
    struct RegionRectangle **ud = (struct RegionRectangle **)lua_newuserdata(L, sizeof(struct RegionRectangle *));
    *ud = (struct RegionRectangle*)obj->Next;
    luaL_getmetatable(L, "RegionRectangle");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "Prev") == 0) {
    struct RegionRectangle **ud = (struct RegionRectangle **)lua_newuserdata(L, sizeof(struct RegionRectangle *));
    *ud = (struct RegionRectangle*)obj->Prev;
    luaL_getmetatable(L, "RegionRectangle");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "bounds.MinX") == 0) {
    lua_pushinteger(L, obj->bounds.MinX);
    return 1;
  }
  if (strcmp(key, "bounds.MinY") == 0) {
    lua_pushinteger(L, obj->bounds.MinY);
    return 1;
  }
  if (strcmp(key, "bounds.MaxX") == 0) {
    lua_pushinteger(L, obj->bounds.MaxX);
    return 1;
  }
  if (strcmp(key, "bounds.MaxY") == 0) {
    lua_pushinteger(L, obj->bounds.MaxY);
    return 1;
  }
  if (strcmp(key, "bounds") == 0) {
    struct Rectangle **ud = (struct Rectangle **)lua_newuserdata(L, sizeof(struct Rectangle *));
    *ud = (struct Rectangle*)&obj->bounds;
    luaL_getmetatable(L, "Rectangle");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct RegionRectangle));
    return 1;
}

  return 0;
}

static void
_lua_gen_RegionRectangle_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "bounds.MinX");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "bounds.MinY");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "bounds.MaxX");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "bounds.MaxY");
  lua_rawseti(L, -2, 4);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_RegionRectangle(lua_State *L) {
  if (luaL_newmetatable(L, "RegionRectangle")) {
    lua_pushcfunction(L, _lua_gen_RegionRectangle_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_RegionRectangle_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_RegionRectangle_constructor);
    lua_setglobal(L, "RegionRectangle");
    _lua_gen_RegionRectangle_install_keys(L);
    lua_pushstring(L, "RegionRectangle");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_AnimComp_newindex(lua_State *L)
{
  struct AnimComp *obj = *(struct AnimComp **)luaL_checkudata(L, 1, "AnimComp");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "Flags") == 0) {
    obj->Flags = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Timer") == 0) {
    obj->Timer = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "TimeSet") == 0) {
    obj->TimeSet = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "NextComp") == 0) {
    // finder 1
    //obj->NextComp = *(struct AnimComp **)luaL_checkudata(L, 3, "AnimComp");
    obj->NextComp = (struct AnimComp *)_lua_gen_checkAnimComp(L, 3);
    return 0;
  }
  if (strcmp(key, "PrevComp") == 0) {
    // finder 1
    //obj->PrevComp = *(struct AnimComp **)luaL_checkudata(L, 3, "AnimComp");
    obj->PrevComp = (struct AnimComp *)_lua_gen_checkAnimComp(L, 3);
    return 0;
  }
  if (strcmp(key, "NextSeq") == 0) {
    // finder 1
    //obj->NextSeq = *(struct AnimComp **)luaL_checkudata(L, 3, "AnimComp");
    obj->NextSeq = (struct AnimComp *)_lua_gen_checkAnimComp(L, 3);
    return 0;
  }
  if (strcmp(key, "PrevSeq") == 0) {
    // finder 1
    //obj->PrevSeq = *(struct AnimComp **)luaL_checkudata(L, 3, "AnimComp");
    obj->PrevSeq = (struct AnimComp *)_lua_gen_checkAnimComp(L, 3);
    return 0;
  }
  // Unsupported type AnimCRoutine WORD ()(struct AnimComp )
  if (strcmp(key, "AnimCRoutine") == 0) {
    return luaL_error(L, "Unsupported type WORD ()(struct AnimComp ) for field AnimCRoutine");
  }
  if (strcmp(key, "YTrans") == 0) {
    obj->YTrans = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "XTrans") == 0) {
    obj->XTrans = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "HeadOb") == 0) {
    // finder 1
    //obj->HeadOb = *(struct AnimOb **)luaL_checkudata(L, 3, "AnimOb");
    obj->HeadOb = (struct AnimOb *)_lua_gen_checkAnimOb(L, 3);
    return 0;
  }
  if (strcmp(key, "AnimBob") == 0) {
    // finder 1
    //obj->AnimBob = *(struct Bob **)luaL_checkudata(L, 3, "Bob");
    obj->AnimBob = (struct Bob *)_lua_gen_checkBob(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_AnimComp_constructor(lua_State *L)
{
  // Allocate pointer-to-struct AnimComp in userdata
  struct AnimComp **objp = lua_newuserdata(L, sizeof(struct AnimComp *));
  *objp = malloc(sizeof(struct AnimComp));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct AnimComp));

  // Set metatable
  luaL_getmetatable(L, "AnimComp");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_AnimComp_index(lua_State *L)
{
  struct AnimComp *obj = *(struct AnimComp **)luaL_checkudata(L, 1, "AnimComp");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "Flags") == 0) {
    lua_pushinteger(L, obj->Flags);
    return 1;
  }
  if (strcmp(key, "Timer") == 0) {
    lua_pushinteger(L, obj->Timer);
    return 1;
  }
  if (strcmp(key, "TimeSet") == 0) {
    lua_pushinteger(L, obj->TimeSet);
    return 1;
  }
  if (strcmp(key, "NextComp") == 0) {
    struct AnimComp **ud = (struct AnimComp **)lua_newuserdata(L, sizeof(struct AnimComp *));
    *ud = (struct AnimComp*)obj->NextComp;
    luaL_getmetatable(L, "AnimComp");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "PrevComp") == 0) {
    struct AnimComp **ud = (struct AnimComp **)lua_newuserdata(L, sizeof(struct AnimComp *));
    *ud = (struct AnimComp*)obj->PrevComp;
    luaL_getmetatable(L, "AnimComp");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "NextSeq") == 0) {
    struct AnimComp **ud = (struct AnimComp **)lua_newuserdata(L, sizeof(struct AnimComp *));
    *ud = (struct AnimComp*)obj->NextSeq;
    luaL_getmetatable(L, "AnimComp");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "PrevSeq") == 0) {
    struct AnimComp **ud = (struct AnimComp **)lua_newuserdata(L, sizeof(struct AnimComp *));
    *ud = (struct AnimComp*)obj->PrevSeq;
    luaL_getmetatable(L, "AnimComp");
    lua_setmetatable(L, -2);
    return 1;
  }
  // Unsupported AnimCRoutine WORD (*)(struct AnimComp *)
  if (strcmp(key, "AnimCRoutine") == 0) {
    return luaL_error(L, "Unsupported type WORD (*)(struct AnimComp *) for field AnimCRoutine");
  }
  if (strcmp(key, "YTrans") == 0) {
    lua_pushinteger(L, obj->YTrans);
    return 1;
  }
  if (strcmp(key, "XTrans") == 0) {
    lua_pushinteger(L, obj->XTrans);
    return 1;
  }
  if (strcmp(key, "HeadOb") == 0) {
    struct AnimOb **ud = (struct AnimOb **)lua_newuserdata(L, sizeof(struct AnimOb *));
    *ud = (struct AnimOb*)obj->HeadOb;
    luaL_getmetatable(L, "AnimOb");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "AnimBob") == 0) {
    struct Bob **ud = (struct Bob **)lua_newuserdata(L, sizeof(struct Bob *));
    *ud = (struct Bob*)obj->AnimBob;
    luaL_getmetatable(L, "Bob");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct AnimComp));
    return 1;
}

  return 0;
}

static void
_lua_gen_AnimComp_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "Flags");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "Timer");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "TimeSet");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "AnimCRoutine");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "YTrans");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "XTrans");
  lua_rawseti(L, -2, 6);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_AnimComp(lua_State *L) {
  if (luaL_newmetatable(L, "AnimComp")) {
    lua_pushcfunction(L, _lua_gen_AnimComp_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_AnimComp_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_AnimComp_constructor);
    lua_setglobal(L, "AnimComp");
    _lua_gen_AnimComp_install_keys(L);
    lua_pushstring(L, "AnimComp");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_DBufPacket_newindex(lua_State *L)
{
  struct DBufPacket *obj = *(struct DBufPacket **)luaL_checkudata(L, 1, "DBufPacket");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "BufY") == 0) {
    obj->BufY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "BufX") == 0) {
    obj->BufX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "BufPath") == 0) {
    // finder 1
    //obj->BufPath = *(struct VSprite **)luaL_checkudata(L, 3, "VSprite");
    obj->BufPath = (struct VSprite *)_lua_gen_checkVSprite(L, 3);
    return 0;
  }
  if (strcmp(key, "BufBuffer") == 0) {
    obj->BufBuffer = (WORD *)lua_touserdata(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_DBufPacket_constructor(lua_State *L)
{
  // Allocate pointer-to-struct DBufPacket in userdata
  struct DBufPacket **objp = lua_newuserdata(L, sizeof(struct DBufPacket *));
  *objp = malloc(sizeof(struct DBufPacket));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct DBufPacket));

  // Set metatable
  luaL_getmetatable(L, "DBufPacket");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_DBufPacket_index(lua_State *L)
{
  struct DBufPacket *obj = *(struct DBufPacket **)luaL_checkudata(L, 1, "DBufPacket");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "BufY") == 0) {
    lua_pushinteger(L, obj->BufY);
    return 1;
  }
  if (strcmp(key, "BufX") == 0) {
    lua_pushinteger(L, obj->BufX);
    return 1;
  }
  if (strcmp(key, "BufPath") == 0) {
    struct VSprite **ud = (struct VSprite **)lua_newuserdata(L, sizeof(struct VSprite *));
    *ud = (struct VSprite*)obj->BufPath;
    luaL_getmetatable(L, "VSprite");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "BufBuffer") == 0) {
    lua_pushlightuserdata(L, obj->BufBuffer);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct DBufPacket));
    return 1;
}

  return 0;
}

static void
_lua_gen_DBufPacket_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "BufY");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "BufX");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "BufBuffer");
  lua_rawseti(L, -2, 3);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_DBufPacket(lua_State *L) {
  if (luaL_newmetatable(L, "DBufPacket")) {
    lua_pushcfunction(L, _lua_gen_DBufPacket_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_DBufPacket_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_DBufPacket_constructor);
    lua_setglobal(L, "DBufPacket");
    _lua_gen_DBufPacket_install_keys(L);
    lua_pushstring(L, "DBufPacket");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_collTable_newindex(lua_State *L)
{
  struct collTable *obj = *(struct collTable **)luaL_checkudata(L, 1, "collTable");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  // collPtrs[16] proxied via the index
  return 0;
}


static int
_lua_collTable_constructor(lua_State *L)
{
  // Allocate pointer-to-struct collTable in userdata
  struct collTable **objp = lua_newuserdata(L, sizeof(struct collTable *));
  *objp = malloc(sizeof(struct collTable));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct collTable));

  // Set metatable
  luaL_getmetatable(L, "collTable");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_collTable_index(lua_State *L)
{
  struct collTable *obj = *(struct collTable **)luaL_checkudata(L, 1, "collTable");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "collPtrs") == 0) {
     return luaL_error(L, "Unsupported array type LONG (*)(struct VSprite *, struct VSprite *)");
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct collTable));
    return 1;
}

  return 0;
}

static void
_lua_gen_collTable_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "collPtrs");
  lua_rawseti(L, -2, 1);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_collTable(lua_State *L) {
  if (luaL_newmetatable(L, "collTable")) {
    lua_pushcfunction(L, _lua_gen_collTable_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_collTable_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_collTable_constructor);
    lua_setglobal(L, "collTable");
    _lua_gen_collTable_install_keys(L);
    lua_pushstring(L, "collTable");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_TmpRas_newindex(lua_State *L)
{
  struct TmpRas *obj = *(struct TmpRas **)luaL_checkudata(L, 1, "TmpRas");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "RasPtr") == 0) {
    obj->RasPtr = (BYTE *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "Size") == 0) {
    obj->Size = (LONG)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_TmpRas_constructor(lua_State *L)
{
  // Allocate pointer-to-struct TmpRas in userdata
  struct TmpRas **objp = lua_newuserdata(L, sizeof(struct TmpRas *));
  *objp = malloc(sizeof(struct TmpRas));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct TmpRas));

  // Set metatable
  luaL_getmetatable(L, "TmpRas");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_TmpRas_index(lua_State *L)
{
  struct TmpRas *obj = *(struct TmpRas **)luaL_checkudata(L, 1, "TmpRas");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "RasPtr") == 0) {
    lua_pushlightuserdata(L, obj->RasPtr);
    return 1;
  }
  if (strcmp(key, "Size") == 0) {
    lua_pushinteger(L, obj->Size);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct TmpRas));
    return 1;
}

  return 0;
}

static void
_lua_gen_TmpRas_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "RasPtr");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "Size");
  lua_rawseti(L, -2, 2);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_TmpRas(lua_State *L) {
  if (luaL_newmetatable(L, "TmpRas")) {
    lua_pushcfunction(L, _lua_gen_TmpRas_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_TmpRas_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_TmpRas_constructor);
    lua_setglobal(L, "TmpRas");
    _lua_gen_TmpRas_install_keys(L);
    lua_pushstring(L, "TmpRas");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_ExtSprite_newindex(lua_State *L)
{
  struct ExtSprite *obj = *(struct ExtSprite **)luaL_checkudata(L, 1, "ExtSprite");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "es_SimpleSprite.posctldata") == 0) {
    obj->es_SimpleSprite.posctldata = (UWORD *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "es_SimpleSprite.height") == 0) {
    obj->es_SimpleSprite.height = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "es_SimpleSprite.x") == 0) {
    obj->es_SimpleSprite.x = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "es_SimpleSprite.y") == 0) {
    obj->es_SimpleSprite.y = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "es_SimpleSprite.num") == 0) {
    obj->es_SimpleSprite.num = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "es_SimpleSprite") == 0) {
    // finder 0
    struct SimpleSprite *val = *(struct SimpleSprite **)luaL_checkudata(L, 3, "SimpleSprite");
    obj->es_SimpleSprite = *val;
    return 0;
  }
  if (strcmp(key, "es_wordwidth") == 0) {
    obj->es_wordwidth = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "es_flags") == 0) {
    obj->es_flags = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_ExtSprite_constructor(lua_State *L)
{
  // Allocate pointer-to-struct ExtSprite in userdata
  struct ExtSprite **objp = lua_newuserdata(L, sizeof(struct ExtSprite *));
  *objp = malloc(sizeof(struct ExtSprite));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct ExtSprite));

  // Set metatable
  luaL_getmetatable(L, "ExtSprite");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_ExtSprite_index(lua_State *L)
{
  struct ExtSprite *obj = *(struct ExtSprite **)luaL_checkudata(L, 1, "ExtSprite");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "es_SimpleSprite.posctldata") == 0) {
    lua_pushlightuserdata(L, obj->es_SimpleSprite.posctldata);
    return 1;
  }
  if (strcmp(key, "es_SimpleSprite.height") == 0) {
    lua_pushinteger(L, obj->es_SimpleSprite.height);
    return 1;
  }
  if (strcmp(key, "es_SimpleSprite.x") == 0) {
    lua_pushinteger(L, obj->es_SimpleSprite.x);
    return 1;
  }
  if (strcmp(key, "es_SimpleSprite.y") == 0) {
    lua_pushinteger(L, obj->es_SimpleSprite.y);
    return 1;
  }
  if (strcmp(key, "es_SimpleSprite.num") == 0) {
    lua_pushinteger(L, obj->es_SimpleSprite.num);
    return 1;
  }
  if (strcmp(key, "es_SimpleSprite") == 0) {
    struct SimpleSprite **ud = (struct SimpleSprite **)lua_newuserdata(L, sizeof(struct SimpleSprite *));
    *ud = (struct SimpleSprite*)&obj->es_SimpleSprite;
    luaL_getmetatable(L, "SimpleSprite");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "es_wordwidth") == 0) {
    lua_pushinteger(L, obj->es_wordwidth);
    return 1;
  }
  if (strcmp(key, "es_flags") == 0) {
    lua_pushinteger(L, obj->es_flags);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct ExtSprite));
    return 1;
}

  return 0;
}

static void
_lua_gen_ExtSprite_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "es_SimpleSprite.posctldata");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "es_SimpleSprite.height");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "es_SimpleSprite.x");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "es_SimpleSprite.y");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "es_SimpleSprite.num");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "es_wordwidth");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "es_flags");
  lua_rawseti(L, -2, 7);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_ExtSprite(lua_State *L) {
  if (luaL_newmetatable(L, "ExtSprite")) {
    lua_pushcfunction(L, _lua_gen_ExtSprite_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_ExtSprite_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_ExtSprite_constructor);
    lua_setglobal(L, "ExtSprite");
    _lua_gen_ExtSprite_install_keys(L);
    lua_pushstring(L, "ExtSprite");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_ClearEOL(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  ClearEOL(rp);
  return 0;
}

static int
_lua_ClearScreen(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  ClearScreen(rp);
  return 0;
}

static int
_lua_Text(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  CONST_STRPTR string = amiga_checkConstNullableString(L, 2);
  ULONG count = luaL_checkinteger(L, 3);
  LONG _result = Text(rp, string, count);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_SetFont(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  struct TextFont * textFont = _lua_gen_checkTextFont(L, 2);
  LONG _result = SetFont(rp, textFont);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_OpenFont(lua_State* L)
{
  (void)L;
  const struct TextAttr * textAttr = _lua_gen_checkTextAttr(L, 1);
  struct TextFont * _result = OpenFont(textAttr);
  _lua_gen_pushTextFont(L, _result);
  return 1;
}

static int
_lua_CloseFont(lua_State* L)
{
  (void)L;
  struct TextFont * textFont = _lua_gen_checkTextFont(L, 1);
  CloseFont(textFont);
  return 0;
}

static int
_lua_AskSoftStyle(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  ULONG _result = AskSoftStyle(rp);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_AddBob(lua_State* L)
{
  (void)L;
  struct Bob * bob = _lua_gen_checkBob(L, 1);
  struct RastPort * rp = _lua_gen_checkRastPort(L, 2);
  AddBob(bob, rp);
  return 0;
}

static int
_lua_AddVSprite(lua_State* L)
{
  (void)L;
  struct VSprite * vSprite = _lua_gen_checkVSprite(L, 1);
  struct RastPort * rp = _lua_gen_checkRastPort(L, 2);
  AddVSprite(vSprite, rp);
  return 0;
}

static int
_lua_DoCollision(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  DoCollision(rp);
  return 0;
}

static int
_lua_DrawGList(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  struct ViewPort * vp = _lua_gen_checkViewPort(L, 2);
  DrawGList(rp, vp);
  return 0;
}

static int
_lua_InitGels(lua_State* L)
{
  (void)L;
  struct VSprite * head = _lua_gen_checkVSprite(L, 1);
  struct VSprite * tail = _lua_gen_checkVSprite(L, 2);
  struct GelsInfo * gelsInfo = _lua_gen_checkGelsInfo(L, 3);
  InitGels(head, tail, gelsInfo);
  return 0;
}

static int
_lua_InitMasks(lua_State* L)
{
  (void)L;
  struct VSprite * vSprite = _lua_gen_checkVSprite(L, 1);
  InitMasks(vSprite);
  return 0;
}

static int
_lua_RemVSprite(lua_State* L)
{
  (void)L;
  struct VSprite * vSprite = _lua_gen_checkVSprite(L, 1);
  RemVSprite(vSprite);
  return 0;
}

static int
_lua_SortGList(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  SortGList(rp);
  return 0;
}

static int
_lua_InitGMasks(lua_State* L)
{
  (void)L;
  struct AnimOb * anOb = _lua_gen_checkAnimOb(L, 1);
  InitGMasks(anOb);
  return 0;
}

static int
_lua_LoadRGB4(lua_State* L)
{
  (void)L;
  struct ViewPort * vp = _lua_gen_checkViewPort(L, 1);
  const UWORD * colors = lua_touserdata(L, 2);
  LONG count = luaL_checkinteger(L, 3);
  LoadRGB4(vp, colors, count);
  return 0;
}

static int
_lua_InitRastPort(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  InitRastPort(rp);
  return 0;
}

static int
_lua_InitVPort(lua_State* L)
{
  (void)L;
  struct ViewPort * vp = _lua_gen_checkViewPort(L, 1);
  InitVPort(vp);
  return 0;
}

static int
_lua_MrgCop(lua_State* L)
{
  (void)L;
  struct View * view = _lua_gen_checkView(L, 1);
  ULONG _result = MrgCop(view);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_MakeVPort(lua_State* L)
{
  (void)L;
  struct View * view = _lua_gen_checkView(L, 1);
  struct ViewPort * vp = _lua_gen_checkViewPort(L, 2);
  ULONG _result = MakeVPort(view, vp);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_LoadView(lua_State* L)
{
  (void)L;
  struct View * view = _lua_gen_checkView(L, 1);
  LoadView(view);
  return 0;
}

static int
_lua_WaitBlit(lua_State* L)
{
  (void)L;
  WaitBlit();
  return 0;
}

static int
_lua_SetRast(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  ULONG pen = luaL_checkinteger(L, 2);
  SetRast(rp, pen);
  return 0;
}

static int
_lua_Move(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  LONG x = luaL_checkinteger(L, 2);
  LONG y = luaL_checkinteger(L, 3);
  Move(rp, x, y);
  return 0;
}

static int
_lua_Draw(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  LONG x = luaL_checkinteger(L, 2);
  LONG y = luaL_checkinteger(L, 3);
  Draw(rp, x, y);
  return 0;
}

static int
_lua_AreaMove(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  LONG x = luaL_checkinteger(L, 2);
  LONG y = luaL_checkinteger(L, 3);
  LONG _result = AreaMove(rp, x, y);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_AreaDraw(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  LONG x = luaL_checkinteger(L, 2);
  LONG y = luaL_checkinteger(L, 3);
  LONG _result = AreaDraw(rp, x, y);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_AreaEnd(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  LONG _result = AreaEnd(rp);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_WaitTOF(lua_State* L)
{
  (void)L;
  WaitTOF();
  return 0;
}

static int
_lua_QBlit(lua_State* L)
{
  (void)L;
  struct bltnode * blit = _lua_gen_checkbltnode(L, 1);
  QBlit(blit);
  return 0;
}

static int
_lua_QBSBlit(lua_State* L)
{
  (void)L;
  struct bltnode * blit = _lua_gen_checkbltnode(L, 1);
  QBSBlit(blit);
  return 0;
}

static int
_lua_BltClear(lua_State* L)
{
  (void)L;
  PLANEPTR memBlock = lua_touserdata(L, 1);
  ULONG byteCount = luaL_checkinteger(L, 2);
  ULONG flags = luaL_checkinteger(L, 3);
  BltClear(memBlock, byteCount, flags);
  return 0;
}

static int
_lua_ReadPixel(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  LONG x = luaL_checkinteger(L, 2);
  LONG y = luaL_checkinteger(L, 3);
  ULONG _result = ReadPixel(rp, x, y);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_WritePixel(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  LONG x = luaL_checkinteger(L, 2);
  LONG y = luaL_checkinteger(L, 3);
  LONG _result = WritePixel(rp, x, y);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_Flood(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  ULONG mode = luaL_checkinteger(L, 2);
  LONG x = luaL_checkinteger(L, 3);
  LONG y = luaL_checkinteger(L, 4);
  BOOL _result = Flood(rp, mode, x, y);
  lua_pushboolean(L, _result);
  return 1;
}

static int
_lua_PolyDraw(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  LONG count = luaL_checkinteger(L, 2);
  const WORD * polyTable = lua_touserdata(L, 3);
  PolyDraw(rp, count, polyTable);
  return 0;
}

static int
_lua_SetAPen(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  ULONG pen = luaL_checkinteger(L, 2);
  SetAPen(rp, pen);
  return 0;
}

static int
_lua_SetBPen(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  ULONG pen = luaL_checkinteger(L, 2);
  SetBPen(rp, pen);
  return 0;
}

static int
_lua_SetDrMd(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  ULONG drawMode = luaL_checkinteger(L, 2);
  SetDrMd(rp, drawMode);
  return 0;
}

static int
_lua_InitView(lua_State* L)
{
  (void)L;
  struct View * view = _lua_gen_checkView(L, 1);
  InitView(view);
  return 0;
}

static int
_lua_CBump(lua_State* L)
{
  (void)L;
  struct UCopList * copList = lua_touserdata(L, 1);
  CBump(copList);
  return 0;
}

static int
_lua_CMove(lua_State* L)
{
  (void)L;
  struct UCopList * copList = lua_touserdata(L, 1);
  APTR destination = lua_touserdata(L, 2);
  LONG data = luaL_checkinteger(L, 3);
  LONG _result = CMove(copList, destination, data);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_CWait(lua_State* L)
{
  (void)L;
  struct UCopList * copList = lua_touserdata(L, 1);
  LONG v = luaL_checkinteger(L, 2);
  LONG h = luaL_checkinteger(L, 3);
  LONG _result = CWait(copList, v, h);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_VBeamPos(lua_State* L)
{
  (void)L;
  LONG _result = VBeamPos();
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_WaitBOVP(lua_State* L)
{
  (void)L;
  struct ViewPort * vp = _lua_gen_checkViewPort(L, 1);
  WaitBOVP(vp);
  return 0;
}

static int
_lua_GetSprite(lua_State* L)
{
  (void)L;
  struct SimpleSprite * sprite = _lua_gen_checkSimpleSprite(L, 1);
  LONG num = luaL_checkinteger(L, 2);
  WORD _result = GetSprite(sprite, num);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_FreeSprite(lua_State* L)
{
  (void)L;
  LONG num = luaL_checkinteger(L, 1);
  FreeSprite(num);
  return 0;
}

static int
_lua_LockLayerRom(lua_State* L)
{
  (void)L;
  struct Layer * layer = _lua_gen_checkLayer(L, 1);
  LockLayerRom(layer);
  return 0;
}

static int
_lua_UnlockLayerRom(lua_State* L)
{
  (void)L;
  struct Layer * layer = _lua_gen_checkLayer(L, 1);
  UnlockLayerRom(layer);
  return 0;
}

static int
_lua_SyncSBitMap(lua_State* L)
{
  (void)L;
  struct Layer * layer = _lua_gen_checkLayer(L, 1);
  SyncSBitMap(layer);
  return 0;
}

static int
_lua_CopySBitMap(lua_State* L)
{
  (void)L;
  struct Layer * layer = _lua_gen_checkLayer(L, 1);
  CopySBitMap(layer);
  return 0;
}

static int
_lua_OwnBlitter(lua_State* L)
{
  (void)L;
  OwnBlitter();
  return 0;
}

static int
_lua_DisownBlitter(lua_State* L)
{
  (void)L;
  DisownBlitter();
  return 0;
}

static int
_lua_InitTmpRas(lua_State* L)
{
  (void)L;
  struct TmpRas * tmpRas = _lua_gen_checkTmpRas(L, 1);
  PLANEPTR buffer = lua_touserdata(L, 2);
  LONG size = luaL_checkinteger(L, 3);
  struct TmpRas * _result = InitTmpRas(tmpRas, buffer, size);
  _lua_gen_pushTmpRas(L, _result);
  return 1;
}

static int
_lua_AskFont(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  struct TextAttr * textAttr = _lua_gen_checkTextAttr(L, 2);
  AskFont(rp, textAttr);
  return 0;
}

static int
_lua_AddFont(lua_State* L)
{
  (void)L;
  struct TextFont * textFont = _lua_gen_checkTextFont(L, 1);
  AddFont(textFont);
  return 0;
}

static int
_lua_RemFont(lua_State* L)
{
  (void)L;
  struct TextFont * textFont = _lua_gen_checkTextFont(L, 1);
  RemFont(textFont);
  return 0;
}

static int
_lua_AllocRaster(lua_State* L)
{
  (void)L;
  ULONG width = luaL_checkinteger(L, 1);
  ULONG height = luaL_checkinteger(L, 2);
  PLANEPTR _result = AllocRaster(width, height);
  lua_pushlightuserdata(L, _result);
  return 1;
}

static int
_lua_FreeRaster(lua_State* L)
{
  (void)L;
  PLANEPTR p = lua_touserdata(L, 1);
  ULONG width = luaL_checkinteger(L, 2);
  ULONG height = luaL_checkinteger(L, 3);
  FreeRaster(p, width, height);
  return 0;
}

static int
_lua_NewRegion(lua_State* L)
{
  (void)L;
  struct Region * _result = NewRegion();
  _lua_gen_pushRegion(L, _result);
  return 1;
}

static int
_lua_ClearRegion(lua_State* L)
{
  (void)L;
  struct Region * region = _lua_gen_checkRegion(L, 1);
  ClearRegion(region);
  return 0;
}

static int
_lua_DisposeRegion(lua_State* L)
{
  (void)L;
  struct Region * region = _lua_gen_checkRegion(L, 1);
  DisposeRegion(region);
  return 0;
}

static int
_lua_FreeVPortCopLists(lua_State* L)
{
  (void)L;
  struct ViewPort * vp = _lua_gen_checkViewPort(L, 1);
  FreeVPortCopLists(vp);
  return 0;
}

static int
_lua_FreeCopList(lua_State* L)
{
  (void)L;
  struct CopList * copList = _lua_gen_checkCopList(L, 1);
  FreeCopList(copList);
  return 0;
}

static int
_lua_FreeCprList(lua_State* L)
{
  (void)L;
  struct cprlist * cprList = _lua_gen_checkcprlist(L, 1);
  FreeCprList(cprList);
  return 0;
}

static int
_lua_GetColorMap(lua_State* L)
{
  (void)L;
  LONG entries = luaL_checkinteger(L, 1);
  struct ColorMap * _result = GetColorMap(entries);
  _lua_gen_pushColorMap(L, _result);
  return 1;
}

static int
_lua_FreeColorMap(lua_State* L)
{
  (void)L;
  struct ColorMap * colorMap = _lua_gen_checkColorMap(L, 1);
  FreeColorMap(colorMap);
  return 0;
}

static int
_lua_GetRGB4(lua_State* L)
{
  (void)L;
  struct ColorMap * colorMap = _lua_gen_checkColorMap(L, 1);
  LONG entry = luaL_checkinteger(L, 2);
  ULONG _result = GetRGB4(colorMap, entry);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_ScrollVPort(lua_State* L)
{
  (void)L;
  struct ViewPort * vp = _lua_gen_checkViewPort(L, 1);
  ScrollVPort(vp);
  return 0;
}

static int
_lua_UCopperListInit(lua_State* L)
{
  (void)L;
  struct UCopList * uCopList = lua_touserdata(L, 1);
  LONG n = luaL_checkinteger(L, 2);
  struct CopList * _result = UCopperListInit(uCopList, n);
  _lua_gen_pushCopList(L, _result);
  return 1;
}

static int
_lua_AttemptLockLayerRom(lua_State* L)
{
  (void)L;
  struct Layer * layer = _lua_gen_checkLayer(L, 1);
  BOOL _result = AttemptLockLayerRom(layer);
  lua_pushboolean(L, _result);
  return 1;
}

static int
_lua_GfxNew(lua_State* L)
{
  (void)L;
  ULONG gfxNodeType = luaL_checkinteger(L, 1);
  APTR _result = GfxNew(gfxNodeType);
  lua_pushlightuserdata(L, _result);
  return 1;
}

static int
_lua_GfxFree(lua_State* L)
{
  (void)L;
  APTR gfxNodePtr = lua_touserdata(L, 1);
  GfxFree(gfxNodePtr);
  return 0;
}

static int
_lua_GfxAssociate(lua_State* L)
{
  (void)L;
  APTR associateNode = lua_touserdata(L, 1);
  APTR gfxNodePtr = lua_touserdata(L, 2);
  GfxAssociate(associateNode, gfxNodePtr);
  return 0;
}

static int
_lua_BitMapScale(lua_State* L)
{
  (void)L;
  struct BitScaleArgs * bitScaleArgs = _lua_gen_checkBitScaleArgs(L, 1);
  BitMapScale(bitScaleArgs);
  return 0;
}

static int
_lua_ScalerDiv(lua_State* L)
{
  (void)L;
  ULONG factor = luaL_checkinteger(L, 1);
  ULONG numerator = luaL_checkinteger(L, 2);
  ULONG denominator = luaL_checkinteger(L, 3);
  UWORD _result = ScalerDiv(factor, numerator, denominator);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_GfxLookUp(lua_State* L)
{
  (void)L;
  CONST_APTR associateNode = lua_touserdata(L, 1);
  APTR _result = GfxLookUp(associateNode);
  lua_pushlightuserdata(L, _result);
  return 1;
}

static int
_lua_VideoControl(lua_State* L)
{
  struct ColorMap * colorMap = _lua_gen_checkColorMap(L, 1);
  struct TagItem* tagarray = NULL;
  if (!lua_isnoneornil(L, 2)) {
    struct TagItem _tags[32];
    amiga_doTagList(L, _tags, countof(_tags), 2);
    tagarray = _tags;
  }
  BOOL _result = VideoControl(colorMap, tagarray);
  lua_pushboolean(L, _result);
  return 1;
}

static int
_lua_VideoControlTags(lua_State* L)
{
  struct ColorMap * colorMap = _lua_gen_checkColorMap(L, 1);
  struct TagItem taglist[64];
  amiga_readVarTags(L, taglist, countof(taglist), 2);
  BOOL _result = VideoControl(colorMap,  taglist);
  lua_pushboolean(L, _result);
  return 1;
}

static int
_lua_OpenMonitor(lua_State* L)
{
  (void)L;
  CONST_STRPTR monitorName = amiga_checkConstNullableString(L, 1);
  ULONG displayID = luaL_checkinteger(L, 2);
  struct MonitorSpec * _result = OpenMonitor(monitorName, displayID);
  _lua_gen_pushMonitorSpec(L, _result);
  return 1;
}

static int
_lua_CloseMonitor(lua_State* L)
{
  (void)L;
  struct MonitorSpec * monitorSpec = _lua_gen_checkMonitorSpec(L, 1);
  BOOL _result = CloseMonitor(monitorSpec);
  lua_pushboolean(L, _result);
  return 1;
}

static int
_lua_FindDisplayInfo(lua_State* L)
{
  (void)L;
  ULONG displayID = luaL_checkinteger(L, 1);
  DisplayInfoHandle _result = FindDisplayInfo(displayID);
  lua_pushlightuserdata(L, _result);
  return 1;
}

static int
_lua_NextDisplayInfo(lua_State* L)
{
  (void)L;
  ULONG displayID = luaL_checkinteger(L, 1);
  ULONG _result = NextDisplayInfo(displayID);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_GetVPModeID(lua_State* L)
{
  (void)L;
  const struct ViewPort * vp = _lua_gen_checkViewPort(L, 1);
  LONG _result = GetVPModeID(vp);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_ModeNotAvailable(lua_State* L)
{
  (void)L;
  ULONG modeID = luaL_checkinteger(L, 1);
  LONG _result = ModeNotAvailable(modeID);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_ExtendFont(lua_State* L)
{
  (void)L;
  struct TextFont * font = _lua_gen_checkTextFont(L, 1);
  const struct TagItem * fontTags = _lua_gen_checkTagItem(L, 2);
  ULONG _result = ExtendFont(font, fontTags);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_ExtendFontTags(lua_State* L)
{
  (void)L;
  struct TextFont * font = _lua_gen_checkTextFont(L, 1);
  ULONG tag1Type = luaL_checkinteger(L, 2);
  ULONG _result = ExtendFontTags(font, tag1Type);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_StripFont(lua_State* L)
{
  (void)L;
  struct TextFont * font = _lua_gen_checkTextFont(L, 1);
  StripFont(font);
  return 0;
}

static int
_lua_CalcIVG(lua_State* L)
{
  (void)L;
  struct View * v = _lua_gen_checkView(L, 1);
  struct ViewPort * vp = _lua_gen_checkViewPort(L, 2);
  UWORD _result = CalcIVG(v, vp);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_AttachPalExtra(lua_State* L)
{
  (void)L;
  struct ColorMap * cm = _lua_gen_checkColorMap(L, 1);
  struct ViewPort * vp = _lua_gen_checkViewPort(L, 2);
  LONG _result = AttachPalExtra(cm, vp);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_ObtainBestPenA(lua_State* L)
{
  struct ColorMap * cm = _lua_gen_checkColorMap(L, 1);
  ULONG r = luaL_checkinteger(L, 2);
  ULONG g = luaL_checkinteger(L, 3);
  ULONG b = luaL_checkinteger(L, 4);
  struct TagItem* tags = NULL;
  if (!lua_isnoneornil(L, 5)) {
    struct TagItem _tags[32];
    amiga_doTagList(L, _tags, countof(_tags), 5);
    tags = _tags;
  }
  LONG _result = ObtainBestPenA(cm, r, g, b, tags);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_ObtainBestPen(lua_State* L)
{
  struct ColorMap * cm = _lua_gen_checkColorMap(L, 1);
  ULONG r = luaL_checkinteger(L, 2);
  ULONG g = luaL_checkinteger(L, 3);
  ULONG b = luaL_checkinteger(L, 4);
  struct TagItem taglist[64];
  amiga_readVarTags(L, taglist, countof(taglist), 5);
  LONG _result = ObtainBestPenA(cm, r, g, b,  taglist);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_SetRGB32(lua_State* L)
{
  (void)L;
  struct ViewPort * vp = _lua_gen_checkViewPort(L, 1);
  ULONG n = luaL_checkinteger(L, 2);
  ULONG r = luaL_checkinteger(L, 3);
  ULONG g = luaL_checkinteger(L, 4);
  ULONG b = luaL_checkinteger(L, 5);
  SetRGB32(vp, n, r, g, b);
  return 0;
}

static int
_lua_GetAPen(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  ULONG _result = GetAPen(rp);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_GetBPen(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  ULONG _result = GetBPen(rp);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_GetDrMd(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  ULONG _result = GetDrMd(rp);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_GetOutlinePen(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  ULONG _result = GetOutlinePen(rp);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_LoadRGB32(lua_State* L)
{
  (void)L;
  struct ViewPort * vp = _lua_gen_checkViewPort(L, 1);
  const ULONG * table = lua_touserdata(L, 2);
  LoadRGB32(vp, table);
  return 0;
}

static int
_lua_SetChipRev(lua_State* L)
{
  (void)L;
  ULONG want = luaL_checkinteger(L, 1);
  ULONG _result = SetChipRev(want);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_SetABPenDrMd(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  ULONG apen = luaL_checkinteger(L, 2);
  ULONG bpen = luaL_checkinteger(L, 3);
  ULONG drawmode = luaL_checkinteger(L, 4);
  SetABPenDrMd(rp, apen, bpen, drawmode);
  return 0;
}

static int
_lua_GetRGB32(lua_State* L)
{
  (void)L;
  const struct ColorMap * cm = _lua_gen_checkColorMap(L, 1);
  ULONG firstcolor = luaL_checkinteger(L, 2);
  ULONG ncolors = luaL_checkinteger(L, 3);
  ULONG * table = lua_touserdata(L, 4);
  GetRGB32(cm, firstcolor, ncolors, table);
  return 0;
}

static int
_lua_AllocBitMap(lua_State* L)
{
  (void)L;
  ULONG sizex = luaL_checkinteger(L, 1);
  ULONG sizey = luaL_checkinteger(L, 2);
  ULONG depth = luaL_checkinteger(L, 3);
  ULONG flags = luaL_checkinteger(L, 4);
  const struct BitMap * friend_bitmap = _lua_gen_checkBitMap(L, 5);
  struct BitMap * _result = AllocBitMap(sizex, sizey, depth, flags, friend_bitmap);
  _lua_gen_pushBitMap(L, _result);
  return 1;
}

static int
_lua_FreeBitMap(lua_State* L)
{
  (void)L;
  struct BitMap * bm = _lua_gen_checkBitMap(L, 1);
  FreeBitMap(bm);
  return 0;
}

static int
_lua_GetExtSpriteA(lua_State* L)
{
  struct ExtSprite * ss = _lua_gen_checkExtSprite(L, 1);
  struct TagItem* tags = NULL;
  if (!lua_isnoneornil(L, 2)) {
    struct TagItem _tags[32];
    amiga_doTagList(L, _tags, countof(_tags), 2);
    tags = _tags;
  }
  LONG _result = GetExtSpriteA(ss, tags);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_GetExtSprite(lua_State* L)
{
  struct ExtSprite * ss = _lua_gen_checkExtSprite(L, 1);
  struct TagItem taglist[64];
  amiga_readVarTags(L, taglist, countof(taglist), 2);
  LONG _result = GetExtSpriteA(ss,  taglist);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_CoerceMode(lua_State* L)
{
  (void)L;
  struct ViewPort * vp = _lua_gen_checkViewPort(L, 1);
  ULONG monitorid = luaL_checkinteger(L, 2);
  ULONG flags = luaL_checkinteger(L, 3);
  ULONG _result = CoerceMode(vp, monitorid, flags);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_ChangeVPBitMap(lua_State* L)
{
  (void)L;
  struct ViewPort * vp = _lua_gen_checkViewPort(L, 1);
  struct BitMap * bm = _lua_gen_checkBitMap(L, 2);
  struct DBufInfo * db = _lua_gen_checkDBufInfo(L, 3);
  ChangeVPBitMap(vp, bm, db);
  return 0;
}

static int
_lua_ReleasePen(lua_State* L)
{
  (void)L;
  struct ColorMap * cm = _lua_gen_checkColorMap(L, 1);
  ULONG n = luaL_checkinteger(L, 2);
  ReleasePen(cm, n);
  return 0;
}

static int
_lua_ObtainPen(lua_State* L)
{
  (void)L;
  struct ColorMap * cm = _lua_gen_checkColorMap(L, 1);
  ULONG n = luaL_checkinteger(L, 2);
  ULONG r = luaL_checkinteger(L, 3);
  ULONG g = luaL_checkinteger(L, 4);
  ULONG b = luaL_checkinteger(L, 5);
  LONG f = luaL_checkinteger(L, 6);
  ULONG _result = ObtainPen(cm, n, r, g, b, f);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_GetBitMapAttr(lua_State* L)
{
  (void)L;
  const struct BitMap * bm = _lua_gen_checkBitMap(L, 1);
  ULONG attrnum = luaL_checkinteger(L, 2);
  ULONG _result = GetBitMapAttr(bm, attrnum);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_AllocDBufInfo(lua_State* L)
{
  (void)L;
  struct ViewPort * vp = _lua_gen_checkViewPort(L, 1);
  struct DBufInfo * _result = AllocDBufInfo(vp);
  _lua_gen_pushDBufInfo(L, _result);
  return 1;
}

static int
_lua_FreeDBufInfo(lua_State* L)
{
  (void)L;
  struct DBufInfo * dbi = _lua_gen_checkDBufInfo(L, 1);
  FreeDBufInfo(dbi);
  return 0;
}

static int
_lua_SetOutlinePen(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  ULONG pen = luaL_checkinteger(L, 2);
  ULONG _result = SetOutlinePen(rp, pen);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_SetWriteMask(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  ULONG msk = luaL_checkinteger(L, 2);
  ULONG _result = SetWriteMask(rp, msk);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_SetMaxPen(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  ULONG maxpen = luaL_checkinteger(L, 2);
  SetMaxPen(rp, maxpen);
  return 0;
}

static int
_lua_SetRGB32CM(lua_State* L)
{
  (void)L;
  struct ColorMap * cm = _lua_gen_checkColorMap(L, 1);
  ULONG n = luaL_checkinteger(L, 2);
  ULONG r = luaL_checkinteger(L, 3);
  ULONG g = luaL_checkinteger(L, 4);
  ULONG b = luaL_checkinteger(L, 5);
  SetRGB32CM(cm, n, r, g, b);
  return 0;
}

static int
_lua_FindColor(lua_State* L)
{
  (void)L;
  struct ColorMap * cm = _lua_gen_checkColorMap(L, 1);
  ULONG r = luaL_checkinteger(L, 2);
  ULONG g = luaL_checkinteger(L, 3);
  ULONG b = luaL_checkinteger(L, 4);
  LONG maxcolor = luaL_checkinteger(L, 5);
  LONG _result = FindColor(cm, r, g, b, maxcolor);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_AllocSpriteDataA(lua_State* L)
{
  const struct BitMap * bm = _lua_gen_checkBitMap(L, 1);
  struct TagItem* tags = NULL;
  if (!lua_isnoneornil(L, 2)) {
    struct TagItem _tags[32];
    amiga_doTagList(L, _tags, countof(_tags), 2);
    tags = _tags;
  }
  struct ExtSprite * _result = AllocSpriteDataA(bm, tags);
  _lua_gen_pushExtSprite(L, _result);
  return 1;
}

static int
_lua_AllocSpriteData(lua_State* L)
{
  const struct BitMap * bm = _lua_gen_checkBitMap(L, 1);
  struct TagItem taglist[64];
  amiga_readVarTags(L, taglist, countof(taglist), 2);
  struct ExtSprite * _result = AllocSpriteDataA(bm,  taglist);
  _lua_gen_pushExtSprite(L, _result);
  return 1;
}

static int
_lua_ChangeExtSpriteA(lua_State* L)
{
  struct ViewPort * vp = _lua_gen_checkViewPort(L, 1);
  struct ExtSprite * oldsprite = _lua_gen_checkExtSprite(L, 2);
  struct ExtSprite * newsprite = _lua_gen_checkExtSprite(L, 3);
  struct TagItem* tags = NULL;
  if (!lua_isnoneornil(L, 4)) {
    struct TagItem _tags[32];
    amiga_doTagList(L, _tags, countof(_tags), 4);
    tags = _tags;
  }
  LONG _result = ChangeExtSpriteA(vp, oldsprite, newsprite, tags);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_ChangeExtSprite(lua_State* L)
{
  struct ViewPort * vp = _lua_gen_checkViewPort(L, 1);
  struct ExtSprite * oldsprite = _lua_gen_checkExtSprite(L, 2);
  struct ExtSprite * newsprite = _lua_gen_checkExtSprite(L, 3);
  struct TagItem taglist[64];
  amiga_readVarTags(L, taglist, countof(taglist), 4);
  LONG _result = ChangeExtSpriteA(vp, oldsprite, newsprite,  taglist);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_FreeSpriteData(lua_State* L)
{
  (void)L;
  struct ExtSprite * sp = _lua_gen_checkExtSprite(L, 1);
  FreeSpriteData(sp);
  return 0;
}

static int
_lua_SetRPAttrsA(lua_State* L)
{
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  struct TagItem* tags = NULL;
  if (!lua_isnoneornil(L, 2)) {
    struct TagItem _tags[32];
    amiga_doTagList(L, _tags, countof(_tags), 2);
    tags = _tags;
  }
  SetRPAttrsA(rp, tags);
  return 0;
}

static int
_lua_SetRPAttrs(lua_State* L)
{
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  struct TagItem taglist[64];
  amiga_readVarTags(L, taglist, countof(taglist), 2);
  SetRPAttrsA(rp,  taglist);
  return 0;
}

static int
_lua_GetRPAttrsA(lua_State* L)
{
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  struct TagItem* tags = NULL;
  if (!lua_isnoneornil(L, 2)) {
    struct TagItem _tags[32];
    amiga_doTagList(L, _tags, countof(_tags), 2);
    tags = _tags;
  }
  GetRPAttrsA(rp, tags);
  return 0;
}

static int
_lua_GetRPAttrs(lua_State* L)
{
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  struct TagItem taglist[64];
  amiga_readVarTags(L, taglist, countof(taglist), 2);
  GetRPAttrsA(rp,  taglist);
  return 0;
}

static int
_lua_BestModeIDA(lua_State* L)
{
  struct TagItem* tags = NULL;
  if (!lua_isnoneornil(L, 1)) {
    struct TagItem _tags[32];
    amiga_doTagList(L, _tags, countof(_tags), 1);
    tags = _tags;
  }
  ULONG _result = BestModeIDA(tags);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_BestModeID(lua_State* L)
{
  struct TagItem taglist[64];
  amiga_readVarTags(L, taglist, countof(taglist), 1);
  ULONG _result = BestModeIDA( taglist);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_RemBob(lua_State* L)
{
  (void)L;
  struct Bob * b = _lua_gen_checkBob(L, 1);
  RemBob(b);
  return 0;
}

static void
_lua_gen_install_defines(lua_State *L)
{
  lua_pushinteger(L, SUSERFLAGS);
  lua_setglobal(L, "SUSERFLAGS");
  lua_pushinteger(L, VSPRITE);
  lua_setglobal(L, "VSPRITE");
  lua_pushinteger(L, SAVEBACK);
  lua_setglobal(L, "SAVEBACK");
  lua_pushinteger(L, OVERLAY);
  lua_setglobal(L, "OVERLAY");
  lua_pushinteger(L, MUSTDRAW);
  lua_setglobal(L, "MUSTDRAW");
  lua_pushinteger(L, BACKSAVED);
  lua_setglobal(L, "BACKSAVED");
  lua_pushinteger(L, BOBUPDATE);
  lua_setglobal(L, "BOBUPDATE");
  lua_pushinteger(L, GELGONE);
  lua_setglobal(L, "GELGONE");
  lua_pushinteger(L, VSOVERFLOW);
  lua_setglobal(L, "VSOVERFLOW");
  lua_pushinteger(L, BUSERFLAGS);
  lua_setglobal(L, "BUSERFLAGS");
  lua_pushinteger(L, SAVEBOB);
  lua_setglobal(L, "SAVEBOB");
  lua_pushinteger(L, BOBISCOMP);
  lua_setglobal(L, "BOBISCOMP");
  lua_pushinteger(L, BWAITING);
  lua_setglobal(L, "BWAITING");
  lua_pushinteger(L, BDRAWN);
  lua_setglobal(L, "BDRAWN");
  lua_pushinteger(L, BOBSAWAY);
  lua_setglobal(L, "BOBSAWAY");
  lua_pushinteger(L, BOBNIX);
  lua_setglobal(L, "BOBNIX");
  lua_pushinteger(L, SAVEPRESERVE);
  lua_setglobal(L, "SAVEPRESERVE");
  lua_pushinteger(L, OUTSTEP);
  lua_setglobal(L, "OUTSTEP");
  lua_pushinteger(L, ANFRACSIZE);
  lua_setglobal(L, "ANFRACSIZE");
  lua_pushinteger(L, ANIMHALF);
  lua_setglobal(L, "ANIMHALF");
  lua_pushinteger(L, RINGTRIGGER);
  lua_setglobal(L, "RINGTRIGGER");
  lua_pushinteger(L, B2NORM);
  lua_setglobal(L, "B2NORM");
  lua_pushinteger(L, B2SWAP);
  lua_setglobal(L, "B2SWAP");
  lua_pushinteger(L, B2BOBBER);
  lua_setglobal(L, "B2BOBBER");
  lua_pushinteger(L, CUSTOMIMAGEDEPTH);
  lua_setglobal(L, "CUSTOMIMAGEDEPTH");
  lua_pushinteger(L, IA_Dummy);
  lua_setglobal(L, "IA_Dummy");
  lua_pushinteger(L, IA_Left);
  lua_setglobal(L, "IA_Left");
  lua_pushinteger(L, IA_Top);
  lua_setglobal(L, "IA_Top");
  lua_pushinteger(L, IA_Width);
  lua_setglobal(L, "IA_Width");
  lua_pushinteger(L, IA_Height);
  lua_setglobal(L, "IA_Height");
  lua_pushinteger(L, IA_FGPen);
  lua_setglobal(L, "IA_FGPen");
  lua_pushinteger(L, IA_BGPen);
  lua_setglobal(L, "IA_BGPen");
  lua_pushinteger(L, IA_Data);
  lua_setglobal(L, "IA_Data");
  lua_pushinteger(L, IA_LineWidth);
  lua_setglobal(L, "IA_LineWidth");
  lua_pushinteger(L, IA_Pens);
  lua_setglobal(L, "IA_Pens");
  lua_pushinteger(L, IA_Resolution);
  lua_setglobal(L, "IA_Resolution");
  lua_pushinteger(L, IA_APattern);
  lua_setglobal(L, "IA_APattern");
  lua_pushinteger(L, IA_APatSize);
  lua_setglobal(L, "IA_APatSize");
  lua_pushinteger(L, IA_Mode);
  lua_setglobal(L, "IA_Mode");
  lua_pushinteger(L, IA_Font);
  lua_setglobal(L, "IA_Font");
  lua_pushinteger(L, IA_Outline);
  lua_setglobal(L, "IA_Outline");
  lua_pushinteger(L, IA_Recessed);
  lua_setglobal(L, "IA_Recessed");
  lua_pushinteger(L, IA_DoubleEmboss);
  lua_setglobal(L, "IA_DoubleEmboss");
  lua_pushinteger(L, IA_EdgesOnly);
  lua_setglobal(L, "IA_EdgesOnly");
  lua_pushinteger(L, SYSIA_Size);
  lua_setglobal(L, "SYSIA_Size");
  lua_pushinteger(L, SYSIA_Depth);
  lua_setglobal(L, "SYSIA_Depth");
  lua_pushinteger(L, SYSIA_Which);
  lua_setglobal(L, "SYSIA_Which");
  lua_pushinteger(L, SYSIA_DrawInfo);
  lua_setglobal(L, "SYSIA_DrawInfo");
  lua_pushinteger(L, SYSIA_Pens);
  lua_setglobal(L, "SYSIA_Pens");
  lua_pushinteger(L, IA_ShadowPen);
  lua_setglobal(L, "IA_ShadowPen");
  lua_pushinteger(L, IA_HighlightPen);
  lua_setglobal(L, "IA_HighlightPen");
  lua_pushinteger(L, SYSIA_ReferenceFont);
  lua_setglobal(L, "SYSIA_ReferenceFont");
  lua_pushinteger(L, IA_SupportsDisable);
  lua_setglobal(L, "IA_SupportsDisable");
  lua_pushinteger(L, IA_FrameType);
  lua_setglobal(L, "IA_FrameType");
  lua_pushinteger(L, IA_Underscore);
  lua_setglobal(L, "IA_Underscore");
  lua_pushinteger(L, IA_Scalable);
  lua_setglobal(L, "IA_Scalable");
  lua_pushinteger(L, IA_ActivateKey);
  lua_setglobal(L, "IA_ActivateKey");
  lua_pushinteger(L, IA_Screen);
  lua_setglobal(L, "IA_Screen");
  lua_pushinteger(L, IA_Precision);
  lua_setglobal(L, "IA_Precision");
  lua_pushinteger(L, IA_Orientation);
  lua_setglobal(L, "IA_Orientation");
  lua_pushinteger(L, IA_Label);
  lua_setglobal(L, "IA_Label");
  lua_pushinteger(L, IA_EraseBackground);
  lua_setglobal(L, "IA_EraseBackground");
  lua_pushinteger(L, IA_LabelPen);
  lua_setglobal(L, "IA_LabelPen");
  lua_pushinteger(L, SYSISIZE_MEDRES);
  lua_setglobal(L, "SYSISIZE_MEDRES");
  lua_pushinteger(L, SYSISIZE_LOWRES);
  lua_setglobal(L, "SYSISIZE_LOWRES");
  lua_pushinteger(L, SYSISIZE_HIRES);
  lua_setglobal(L, "SYSISIZE_HIRES");
  lua_pushinteger(L, DEPTHIMAGE);
  lua_setglobal(L, "DEPTHIMAGE");
  lua_pushinteger(L, ZOOMIMAGE);
  lua_setglobal(L, "ZOOMIMAGE");
  lua_pushinteger(L, SIZEIMAGE);
  lua_setglobal(L, "SIZEIMAGE");
  lua_pushinteger(L, CLOSEIMAGE);
  lua_setglobal(L, "CLOSEIMAGE");
  lua_pushinteger(L, SDEPTHIMAGE);
  lua_setglobal(L, "SDEPTHIMAGE");
  lua_pushinteger(L, SDOWNBACKMAGE);
  lua_setglobal(L, "SDOWNBACKMAGE");
  lua_pushinteger(L, LEFTIMAGE);
  lua_setglobal(L, "LEFTIMAGE");
  lua_pushinteger(L, UPIMAGE);
  lua_setglobal(L, "UPIMAGE");
  lua_pushinteger(L, RIGHTIMAGE);
  lua_setglobal(L, "RIGHTIMAGE");
  lua_pushinteger(L, DOWNIMAGE);
  lua_setglobal(L, "DOWNIMAGE");
  lua_pushinteger(L, CHECKIMAGE);
  lua_setglobal(L, "CHECKIMAGE");
  lua_pushinteger(L, MXIMAGE);
  lua_setglobal(L, "MXIMAGE");
  lua_pushinteger(L, MENUCHECK);
  lua_setglobal(L, "MENUCHECK");
  lua_pushinteger(L, AMIGAKEY);
  lua_setglobal(L, "AMIGAKEY");
  lua_pushinteger(L, ICONIFYIMAGE);
  lua_setglobal(L, "ICONIFYIMAGE");
  lua_pushinteger(L, MENUMX);
  lua_setglobal(L, "MENUMX");
  lua_pushinteger(L, MENUSUB);
  lua_setglobal(L, "MENUSUB");
  lua_pushinteger(L, SHIFTKEYIMAGE);
  lua_setglobal(L, "SHIFTKEYIMAGE");
  lua_pushinteger(L, FRAME_DEFAULT);
  lua_setglobal(L, "FRAME_DEFAULT");
  lua_pushinteger(L, FRAME_BUTTON);
  lua_setglobal(L, "FRAME_BUTTON");
  lua_pushinteger(L, FRAME_RIDGE);
  lua_setglobal(L, "FRAME_RIDGE");
  lua_pushinteger(L, FRAME_ICONDROPBOX);
  lua_setglobal(L, "FRAME_ICONDROPBOX");
  lua_pushinteger(L, FRAME_PROPBORDER);
  lua_setglobal(L, "FRAME_PROPBORDER");
  lua_pushinteger(L, FRAME_PROPKNOB);
  lua_setglobal(L, "FRAME_PROPKNOB");
  lua_pushinteger(L, FRAME_DISPLAY);
  lua_setglobal(L, "FRAME_DISPLAY");
  lua_pushinteger(L, FRAME_CONTEXT);
  lua_setglobal(L, "FRAME_CONTEXT");
  lua_pushinteger(L, IM_DRAW);
  lua_setglobal(L, "IM_DRAW");
  lua_pushinteger(L, IM_HITTEST);
  lua_setglobal(L, "IM_HITTEST");
  lua_pushinteger(L, IM_ERASE);
  lua_setglobal(L, "IM_ERASE");
  lua_pushinteger(L, IM_MOVE);
  lua_setglobal(L, "IM_MOVE");
  lua_pushinteger(L, IM_DRAWFRAME);
  lua_setglobal(L, "IM_DRAWFRAME");
  lua_pushinteger(L, IM_FRAMEBOX);
  lua_setglobal(L, "IM_FRAMEBOX");
  lua_pushinteger(L, IM_HITFRAME);
  lua_setglobal(L, "IM_HITFRAME");
  lua_pushinteger(L, IM_ERASEFRAME);
  lua_setglobal(L, "IM_ERASEFRAME");
  lua_pushinteger(L, IM_DOMAINFRAME);
  lua_setglobal(L, "IM_DOMAINFRAME");
  lua_pushinteger(L, IDS_NORMAL);
  lua_setglobal(L, "IDS_NORMAL");
  lua_pushinteger(L, IDS_SELECTED);
  lua_setglobal(L, "IDS_SELECTED");
  lua_pushinteger(L, IDS_DISABLED);
  lua_setglobal(L, "IDS_DISABLED");
  lua_pushinteger(L, IDS_BUSY);
  lua_setglobal(L, "IDS_BUSY");
  lua_pushinteger(L, IDS_INDETERMINATE);
  lua_setglobal(L, "IDS_INDETERMINATE");
  lua_pushinteger(L, IDS_INACTIVENORMAL);
  lua_setglobal(L, "IDS_INACTIVENORMAL");
  lua_pushinteger(L, IDS_INACTIVESELECTED);
  lua_setglobal(L, "IDS_INACTIVESELECTED");
  lua_pushinteger(L, IDS_INACTIVEDISABLED);
  lua_setglobal(L, "IDS_INACTIVEDISABLED");
  lua_pushinteger(L, IDS_SELECTEDDISABLED);
  lua_setglobal(L, "IDS_SELECTEDDISABLED");
  lua_pushinteger(L, IDS_INDETERMINANT);
  lua_setglobal(L, "IDS_INDETERMINANT");
  lua_pushinteger(L, FRAMEF_SPECIFY);
  lua_setglobal(L, "FRAMEF_SPECIFY");
  lua_pushinteger(L, FRAMEF_MINIMAL);
  lua_setglobal(L, "FRAMEF_MINIMAL");
  lua_pushinteger(L, IDOMAIN_MINIMUM);
  lua_setglobal(L, "IDOMAIN_MINIMUM");
  lua_pushinteger(L, IDOMAIN_NOMINAL);
  lua_setglobal(L, "IDOMAIN_NOMINAL");
  lua_pushinteger(L, IDOMAIN_MAXIMUM);
  lua_setglobal(L, "IDOMAIN_MAXIMUM");
  lua_pushinteger(L, DRI_VERSION);
  lua_setglobal(L, "DRI_VERSION");
  lua_pushinteger(L, DRIF_NEWLOOK);
  lua_setglobal(L, "DRIF_NEWLOOK");
  lua_pushinteger(L, DETAILPEN);
  lua_setglobal(L, "DETAILPEN");
  lua_pushinteger(L, BLOCKPEN);
  lua_setglobal(L, "BLOCKPEN");
  lua_pushinteger(L, TEXTPEN);
  lua_setglobal(L, "TEXTPEN");
  lua_pushinteger(L, SHINEPEN);
  lua_setglobal(L, "SHINEPEN");
  lua_pushinteger(L, SHADOWPEN);
  lua_setglobal(L, "SHADOWPEN");
  lua_pushinteger(L, FILLPEN);
  lua_setglobal(L, "FILLPEN");
  lua_pushinteger(L, FILLTEXTPEN);
  lua_setglobal(L, "FILLTEXTPEN");
  lua_pushinteger(L, BACKGROUNDPEN);
  lua_setglobal(L, "BACKGROUNDPEN");
  lua_pushinteger(L, HIGHLIGHTTEXTPEN);
  lua_setglobal(L, "HIGHLIGHTTEXTPEN");
  lua_pushinteger(L, BARDETAILPEN);
  lua_setglobal(L, "BARDETAILPEN");
  lua_pushinteger(L, BARBLOCKPEN);
  lua_setglobal(L, "BARBLOCKPEN");
  lua_pushinteger(L, BARTRIMPEN);
  lua_setglobal(L, "BARTRIMPEN");
  lua_pushinteger(L, BARCONTOURPEN);
  lua_setglobal(L, "BARCONTOURPEN");
  lua_pushinteger(L, NUMDRIPENS);
  lua_setglobal(L, "NUMDRIPENS");
  lua_pushinteger(L, PEN_C3);
  lua_setglobal(L, "PEN_C3");
  lua_pushinteger(L, PEN_C2);
  lua_setglobal(L, "PEN_C2");
  lua_pushinteger(L, PEN_C1);
  lua_setglobal(L, "PEN_C1");
  lua_pushinteger(L, PEN_C0);
  lua_setglobal(L, "PEN_C0");
  lua_pushinteger(L, SCREENTYPE);
  lua_setglobal(L, "SCREENTYPE");
  lua_pushinteger(L, WBENCHSCREEN);
  lua_setglobal(L, "WBENCHSCREEN");
  lua_pushinteger(L, PUBLICSCREEN);
  lua_setglobal(L, "PUBLICSCREEN");
  lua_pushinteger(L, CUSTOMSCREEN);
  lua_setglobal(L, "CUSTOMSCREEN");
  lua_pushinteger(L, SHOWTITLE);
  lua_setglobal(L, "SHOWTITLE");
  lua_pushinteger(L, BEEPING);
  lua_setglobal(L, "BEEPING");
  lua_pushinteger(L, CUSTOMBITMAP);
  lua_setglobal(L, "CUSTOMBITMAP");
  lua_pushinteger(L, SCREENBEHIND);
  lua_setglobal(L, "SCREENBEHIND");
  lua_pushinteger(L, SCREENQUIET);
  lua_setglobal(L, "SCREENQUIET");
  lua_pushinteger(L, SCREENHIRES);
  lua_setglobal(L, "SCREENHIRES");
  lua_pushinteger(L, NS_EXTENDED);
  lua_setglobal(L, "NS_EXTENDED");
  lua_pushinteger(L, AUTOSCROLL);
  lua_setglobal(L, "AUTOSCROLL");
  lua_pushinteger(L, PENSHARED);
  lua_setglobal(L, "PENSHARED");
  lua_pushinteger(L, STDSCREENHEIGHT);
  lua_setglobal(L, "STDSCREENHEIGHT");
  lua_pushinteger(L, STDSCREENWIDTH);
  lua_setglobal(L, "STDSCREENWIDTH");
  lua_pushinteger(L, SA_Dummy);
  lua_setglobal(L, "SA_Dummy");
  lua_pushinteger(L, SA_Left);
  lua_setglobal(L, "SA_Left");
  lua_pushinteger(L, SA_Top);
  lua_setglobal(L, "SA_Top");
  lua_pushinteger(L, SA_Width);
  lua_setglobal(L, "SA_Width");
  lua_pushinteger(L, SA_Height);
  lua_setglobal(L, "SA_Height");
  lua_pushinteger(L, SA_Depth);
  lua_setglobal(L, "SA_Depth");
  lua_pushinteger(L, SA_DetailPen);
  lua_setglobal(L, "SA_DetailPen");
  lua_pushinteger(L, SA_BlockPen);
  lua_setglobal(L, "SA_BlockPen");
  lua_pushinteger(L, SA_Title);
  lua_setglobal(L, "SA_Title");
  lua_pushinteger(L, SA_Colors);
  lua_setglobal(L, "SA_Colors");
  lua_pushinteger(L, SA_ErrorCode);
  lua_setglobal(L, "SA_ErrorCode");
  lua_pushinteger(L, SA_Font);
  lua_setglobal(L, "SA_Font");
  lua_pushinteger(L, SA_SysFont);
  lua_setglobal(L, "SA_SysFont");
  lua_pushinteger(L, SA_Type);
  lua_setglobal(L, "SA_Type");
  lua_pushinteger(L, SA_BitMap);
  lua_setglobal(L, "SA_BitMap");
  lua_pushinteger(L, SA_PubName);
  lua_setglobal(L, "SA_PubName");
  lua_pushinteger(L, SA_PubSig);
  lua_setglobal(L, "SA_PubSig");
  lua_pushinteger(L, SA_PubTask);
  lua_setglobal(L, "SA_PubTask");
  lua_pushinteger(L, SA_DisplayID);
  lua_setglobal(L, "SA_DisplayID");
  lua_pushinteger(L, SA_DClip);
  lua_setglobal(L, "SA_DClip");
  lua_pushinteger(L, SA_Overscan);
  lua_setglobal(L, "SA_Overscan");
  lua_pushinteger(L, SA_Obsolete1);
  lua_setglobal(L, "SA_Obsolete1");
  lua_pushinteger(L, SA_ShowTitle);
  lua_setglobal(L, "SA_ShowTitle");
  lua_pushinteger(L, SA_Behind);
  lua_setglobal(L, "SA_Behind");
  lua_pushinteger(L, SA_Quiet);
  lua_setglobal(L, "SA_Quiet");
  lua_pushinteger(L, SA_AutoScroll);
  lua_setglobal(L, "SA_AutoScroll");
  lua_pushinteger(L, SA_Pens);
  lua_setglobal(L, "SA_Pens");
  lua_pushinteger(L, SA_FullPalette);
  lua_setglobal(L, "SA_FullPalette");
  lua_pushinteger(L, SA_ColorMapEntries);
  lua_setglobal(L, "SA_ColorMapEntries");
  lua_pushinteger(L, SA_Parent);
  lua_setglobal(L, "SA_Parent");
  lua_pushinteger(L, SA_Draggable);
  lua_setglobal(L, "SA_Draggable");
  lua_pushinteger(L, SA_Exclusive);
  lua_setglobal(L, "SA_Exclusive");
  lua_pushinteger(L, SA_SharePens);
  lua_setglobal(L, "SA_SharePens");
  lua_pushinteger(L, SA_BackFill);
  lua_setglobal(L, "SA_BackFill");
  lua_pushinteger(L, SA_Interleaved);
  lua_setglobal(L, "SA_Interleaved");
  lua_pushinteger(L, SA_Colors32);
  lua_setglobal(L, "SA_Colors32");
  lua_pushinteger(L, SA_VideoControl);
  lua_setglobal(L, "SA_VideoControl");
  lua_pushinteger(L, SA_FrontChild);
  lua_setglobal(L, "SA_FrontChild");
  lua_pushinteger(L, SA_BackChild);
  lua_setglobal(L, "SA_BackChild");
  lua_pushinteger(L, SA_LikeWorkbench);
  lua_setglobal(L, "SA_LikeWorkbench");
  lua_pushinteger(L, SA_Reserved);
  lua_setglobal(L, "SA_Reserved");
  lua_pushinteger(L, SA_MinimizeISG);
  lua_setglobal(L, "SA_MinimizeISG");
  lua_pushinteger(L, SA_OffScreenDragging);
  lua_setglobal(L, "SA_OffScreenDragging");
  lua_pushinteger(L, NSTAG_EXT_VPMODE);
  lua_setglobal(L, "NSTAG_EXT_VPMODE");
  lua_pushinteger(L, OSERR_NOMONITOR);
  lua_setglobal(L, "OSERR_NOMONITOR");
  lua_pushinteger(L, OSERR_NOCHIPS);
  lua_setglobal(L, "OSERR_NOCHIPS");
  lua_pushinteger(L, OSERR_NOMEM);
  lua_setglobal(L, "OSERR_NOMEM");
  lua_pushinteger(L, OSERR_NOCHIPMEM);
  lua_setglobal(L, "OSERR_NOCHIPMEM");
  lua_pushinteger(L, OSERR_PUBNOTUNIQUE);
  lua_setglobal(L, "OSERR_PUBNOTUNIQUE");
  lua_pushinteger(L, OSERR_UNKNOWNMODE);
  lua_setglobal(L, "OSERR_UNKNOWNMODE");
  lua_pushinteger(L, OSERR_TOODEEP);
  lua_setglobal(L, "OSERR_TOODEEP");
  lua_pushinteger(L, OSERR_ATTACHFAIL);
  lua_setglobal(L, "OSERR_ATTACHFAIL");
  lua_pushinteger(L, OSERR_NOTAVAILABLE);
  lua_setglobal(L, "OSERR_NOTAVAILABLE");
  lua_pushinteger(L, OSERR_NORTGBITMAP);
  lua_setglobal(L, "OSERR_NORTGBITMAP");
  lua_pushinteger(L, OSCAN_TEXT);
  lua_setglobal(L, "OSCAN_TEXT");
  lua_pushinteger(L, OSCAN_STANDARD);
  lua_setglobal(L, "OSCAN_STANDARD");
  lua_pushinteger(L, OSCAN_MAX);
  lua_setglobal(L, "OSCAN_MAX");
  lua_pushinteger(L, OSCAN_VIDEO);
  lua_setglobal(L, "OSCAN_VIDEO");
  lua_pushinteger(L, PSNF_PRIVATE);
  lua_setglobal(L, "PSNF_PRIVATE");
  lua_pushinteger(L, MAXPUBSCREENNAME);
  lua_setglobal(L, "MAXPUBSCREENNAME");
  lua_pushinteger(L, SHANGHAI);
  lua_setglobal(L, "SHANGHAI");
  lua_pushinteger(L, POPPUBSCREEN);
  lua_setglobal(L, "POPPUBSCREEN");
  lua_pushinteger(L, SDEPTH_TOFRONT);
  lua_setglobal(L, "SDEPTH_TOFRONT");
  lua_pushinteger(L, SDEPTH_TOBACK);
  lua_setglobal(L, "SDEPTH_TOBACK");
  lua_pushinteger(L, SDEPTH_INFAMILY);
  lua_setglobal(L, "SDEPTH_INFAMILY");
  lua_pushinteger(L, SDEPTH_CHILDONLY);
  lua_setglobal(L, "SDEPTH_CHILDONLY");
  lua_pushinteger(L, SPOS_RELATIVE);
  lua_setglobal(L, "SPOS_RELATIVE");
  lua_pushinteger(L, SPOS_ABSOLUTE);
  lua_setglobal(L, "SPOS_ABSOLUTE");
  lua_pushinteger(L, SPOS_MAKEVISIBLE);
  lua_setglobal(L, "SPOS_MAKEVISIBLE");
  lua_pushinteger(L, SPOS_FORCEDRAG);
  lua_setglobal(L, "SPOS_FORCEDRAG");
  lua_pushinteger(L, SB_SCREEN_BITMAP);
  lua_setglobal(L, "SB_SCREEN_BITMAP");
  lua_pushinteger(L, SB_COPY_BITMAP);
  lua_setglobal(L, "SB_COPY_BITMAP");
  lua_pushinteger(L, VTAG_END_CM);
  lua_setglobal(L, "VTAG_END_CM");
  lua_pushinteger(L, VTAG_CHROMAKEY_CLR);
  lua_setglobal(L, "VTAG_CHROMAKEY_CLR");
  lua_pushinteger(L, VTAG_CHROMAKEY_SET);
  lua_setglobal(L, "VTAG_CHROMAKEY_SET");
  lua_pushinteger(L, VTAG_BITPLANEKEY_CLR);
  lua_setglobal(L, "VTAG_BITPLANEKEY_CLR");
  lua_pushinteger(L, VTAG_BITPLANEKEY_SET);
  lua_setglobal(L, "VTAG_BITPLANEKEY_SET");
  lua_pushinteger(L, VTAG_BORDERBLANK_CLR);
  lua_setglobal(L, "VTAG_BORDERBLANK_CLR");
  lua_pushinteger(L, VTAG_BORDERBLANK_SET);
  lua_setglobal(L, "VTAG_BORDERBLANK_SET");
  lua_pushinteger(L, VTAG_BORDERNOTRANS_CLR);
  lua_setglobal(L, "VTAG_BORDERNOTRANS_CLR");
  lua_pushinteger(L, VTAG_BORDERNOTRANS_SET);
  lua_setglobal(L, "VTAG_BORDERNOTRANS_SET");
  lua_pushinteger(L, VTAG_CHROMA_PEN_CLR);
  lua_setglobal(L, "VTAG_CHROMA_PEN_CLR");
  lua_pushinteger(L, VTAG_CHROMA_PEN_SET);
  lua_setglobal(L, "VTAG_CHROMA_PEN_SET");
  lua_pushinteger(L, VTAG_CHROMA_PLANE_SET);
  lua_setglobal(L, "VTAG_CHROMA_PLANE_SET");
  lua_pushinteger(L, VTAG_ATTACH_CM_SET);
  lua_setglobal(L, "VTAG_ATTACH_CM_SET");
  lua_pushinteger(L, VTAG_NEXTBUF_CM);
  lua_setglobal(L, "VTAG_NEXTBUF_CM");
  lua_pushinteger(L, VTAG_BATCH_CM_CLR);
  lua_setglobal(L, "VTAG_BATCH_CM_CLR");
  lua_pushinteger(L, VTAG_BATCH_CM_SET);
  lua_setglobal(L, "VTAG_BATCH_CM_SET");
  lua_pushinteger(L, VTAG_NORMAL_DISP_GET);
  lua_setglobal(L, "VTAG_NORMAL_DISP_GET");
  lua_pushinteger(L, VTAG_NORMAL_DISP_SET);
  lua_setglobal(L, "VTAG_NORMAL_DISP_SET");
  lua_pushinteger(L, VTAG_COERCE_DISP_GET);
  lua_setglobal(L, "VTAG_COERCE_DISP_GET");
  lua_pushinteger(L, VTAG_COERCE_DISP_SET);
  lua_setglobal(L, "VTAG_COERCE_DISP_SET");
  lua_pushinteger(L, VTAG_VIEWPORTEXTRA_GET);
  lua_setglobal(L, "VTAG_VIEWPORTEXTRA_GET");
  lua_pushinteger(L, VTAG_VIEWPORTEXTRA_SET);
  lua_setglobal(L, "VTAG_VIEWPORTEXTRA_SET");
  lua_pushinteger(L, VTAG_CHROMAKEY_GET);
  lua_setglobal(L, "VTAG_CHROMAKEY_GET");
  lua_pushinteger(L, VTAG_BITPLANEKEY_GET);
  lua_setglobal(L, "VTAG_BITPLANEKEY_GET");
  lua_pushinteger(L, VTAG_BORDERBLANK_GET);
  lua_setglobal(L, "VTAG_BORDERBLANK_GET");
  lua_pushinteger(L, VTAG_BORDERNOTRANS_GET);
  lua_setglobal(L, "VTAG_BORDERNOTRANS_GET");
  lua_pushinteger(L, VTAG_CHROMA_PEN_GET);
  lua_setglobal(L, "VTAG_CHROMA_PEN_GET");
  lua_pushinteger(L, VTAG_CHROMA_PLANE_GET);
  lua_setglobal(L, "VTAG_CHROMA_PLANE_GET");
  lua_pushinteger(L, VTAG_ATTACH_CM_GET);
  lua_setglobal(L, "VTAG_ATTACH_CM_GET");
  lua_pushinteger(L, VTAG_BATCH_CM_GET);
  lua_setglobal(L, "VTAG_BATCH_CM_GET");
  lua_pushinteger(L, VTAG_BATCH_ITEMS_GET);
  lua_setglobal(L, "VTAG_BATCH_ITEMS_GET");
  lua_pushinteger(L, VTAG_BATCH_ITEMS_SET);
  lua_setglobal(L, "VTAG_BATCH_ITEMS_SET");
  lua_pushinteger(L, VTAG_BATCH_ITEMS_ADD);
  lua_setglobal(L, "VTAG_BATCH_ITEMS_ADD");
  lua_pushinteger(L, VTAG_VPMODEID_GET);
  lua_setglobal(L, "VTAG_VPMODEID_GET");
  lua_pushinteger(L, VTAG_VPMODEID_SET);
  lua_setglobal(L, "VTAG_VPMODEID_SET");
  lua_pushinteger(L, VTAG_VPMODEID_CLR);
  lua_setglobal(L, "VTAG_VPMODEID_CLR");
  lua_pushinteger(L, VTAG_USERCLIP_GET);
  lua_setglobal(L, "VTAG_USERCLIP_GET");
  lua_pushinteger(L, VTAG_USERCLIP_SET);
  lua_setglobal(L, "VTAG_USERCLIP_SET");
  lua_pushinteger(L, VTAG_USERCLIP_CLR);
  lua_setglobal(L, "VTAG_USERCLIP_CLR");
  lua_pushinteger(L, VTAG_PF1_BASE_GET);
  lua_setglobal(L, "VTAG_PF1_BASE_GET");
  lua_pushinteger(L, VTAG_PF2_BASE_GET);
  lua_setglobal(L, "VTAG_PF2_BASE_GET");
  lua_pushinteger(L, VTAG_SPEVEN_BASE_GET);
  lua_setglobal(L, "VTAG_SPEVEN_BASE_GET");
  lua_pushinteger(L, VTAG_SPODD_BASE_GET);
  lua_setglobal(L, "VTAG_SPODD_BASE_GET");
  lua_pushinteger(L, VTAG_PF1_BASE_SET);
  lua_setglobal(L, "VTAG_PF1_BASE_SET");
  lua_pushinteger(L, VTAG_PF2_BASE_SET);
  lua_setglobal(L, "VTAG_PF2_BASE_SET");
  lua_pushinteger(L, VTAG_SPEVEN_BASE_SET);
  lua_setglobal(L, "VTAG_SPEVEN_BASE_SET");
  lua_pushinteger(L, VTAG_SPODD_BASE_SET);
  lua_setglobal(L, "VTAG_SPODD_BASE_SET");
  lua_pushinteger(L, VTAG_BORDERSPRITE_GET);
  lua_setglobal(L, "VTAG_BORDERSPRITE_GET");
  lua_pushinteger(L, VTAG_BORDERSPRITE_SET);
  lua_setglobal(L, "VTAG_BORDERSPRITE_SET");
  lua_pushinteger(L, VTAG_BORDERSPRITE_CLR);
  lua_setglobal(L, "VTAG_BORDERSPRITE_CLR");
  lua_pushinteger(L, VTAG_SPRITERESN_SET);
  lua_setglobal(L, "VTAG_SPRITERESN_SET");
  lua_pushinteger(L, VTAG_SPRITERESN_GET);
  lua_setglobal(L, "VTAG_SPRITERESN_GET");
  lua_pushinteger(L, VTAG_PF1_TO_SPRITEPRI_SET);
  lua_setglobal(L, "VTAG_PF1_TO_SPRITEPRI_SET");
  lua_pushinteger(L, VTAG_PF1_TO_SPRITEPRI_GET);
  lua_setglobal(L, "VTAG_PF1_TO_SPRITEPRI_GET");
  lua_pushinteger(L, VTAG_PF2_TO_SPRITEPRI_SET);
  lua_setglobal(L, "VTAG_PF2_TO_SPRITEPRI_SET");
  lua_pushinteger(L, VTAG_PF2_TO_SPRITEPRI_GET);
  lua_setglobal(L, "VTAG_PF2_TO_SPRITEPRI_GET");
  lua_pushinteger(L, VTAG_IMMEDIATE);
  lua_setglobal(L, "VTAG_IMMEDIATE");
  lua_pushinteger(L, VTAG_FULLPALETTE_SET);
  lua_setglobal(L, "VTAG_FULLPALETTE_SET");
  lua_pushinteger(L, VTAG_FULLPALETTE_GET);
  lua_setglobal(L, "VTAG_FULLPALETTE_GET");
  lua_pushinteger(L, VTAG_FULLPALETTE_CLR);
  lua_setglobal(L, "VTAG_FULLPALETTE_CLR");
  lua_pushinteger(L, VTAG_DEFSPRITERESN_SET);
  lua_setglobal(L, "VTAG_DEFSPRITERESN_SET");
  lua_pushinteger(L, VTAG_DEFSPRITERESN_GET);
  lua_setglobal(L, "VTAG_DEFSPRITERESN_GET");
  lua_pushinteger(L, VC_IntermediateCLUpdate);
  lua_setglobal(L, "VC_IntermediateCLUpdate");
  lua_pushinteger(L, VC_IntermediateCLUpdate_Query);
  lua_setglobal(L, "VC_IntermediateCLUpdate_Query");
  lua_pushinteger(L, VC_NoColorPaletteLoad);
  lua_setglobal(L, "VC_NoColorPaletteLoad");
  lua_pushinteger(L, VC_NoColorPaletteLoad_Query);
  lua_setglobal(L, "VC_NoColorPaletteLoad_Query");
  lua_pushinteger(L, VC_DUALPF_Disable);
  lua_setglobal(L, "VC_DUALPF_Disable");
  lua_pushinteger(L, VC_DUALPF_Disable_Query);
  lua_setglobal(L, "VC_DUALPF_Disable_Query");
}

static void
_lua_gen_installGeneratedMetaTables(lua_State *L)
{
  _lua_gen_install_meta_TagItem(L);
  _lua_gen_install_meta_Rectangle(L);
  _lua_gen_install_meta_Point(L);
  _lua_gen_install_meta_BitMap(L);
  _lua_gen_install_meta_ExtendedNode(L);
  _lua_gen_install_meta_CopIns(L);
  _lua_gen_install_meta_CopList(L);
  _lua_gen_install_meta_cprlist(L);
  _lua_gen_install_meta_ViewPort(L);
  _lua_gen_install_meta_copinit(L);
  _lua_gen_install_meta_ColorMap(L);
  _lua_gen_install_meta_MonitorSpec(L);
  _lua_gen_install_meta_ViewPortExtra(L);
  _lua_gen_install_meta_PaletteExtra(L);
  _lua_gen_install_meta_DBufInfo(L);
  _lua_gen_install_meta_SpecialMonitor(L);
  _lua_gen_install_meta_AnalogSignalInterval(L);
  _lua_gen_install_meta_AnimOb(L);
  _lua_gen_install_meta_AreaInfo(L);
  _lua_gen_install_meta_BitScaleArgs(L);
  _lua_gen_install_meta_Bob(L);
  _lua_gen_install_meta_GelsInfo(L);
  _lua_gen_install_meta_Layer(L);
  _lua_gen_install_meta_RastPort(L);
  _lua_gen_install_meta_Region(L);
  _lua_gen_install_meta_SimpleSprite(L);
  _lua_gen_install_meta_TextAttr(L);
  _lua_gen_install_meta_TextFont(L);
  _lua_gen_install_meta_VSprite(L);
  _lua_gen_install_meta_bltnode(L);
  _lua_gen_install_meta_RegionRectangle(L);
  _lua_gen_install_meta_AnimComp(L);
  _lua_gen_install_meta_DBufPacket(L);
  _lua_gen_install_meta_collTable(L);
  _lua_gen_install_meta_TmpRas(L);
  _lua_gen_install_meta_ExtSprite(L);
}

static void
_lua_gen_installGeneratedEnums(lua_State *L)
{
  (void)L;
}

static void
_lua_gen_installGeneratedFunctions(lua_State *L)
{(void)L;

  lua_register(L, "ClearEOL", _lua_ClearEOL);
  lua_register(L, "ClearScreen", _lua_ClearScreen);
  lua_register(L, "Text", _lua_Text);
  lua_register(L, "SetFont", _lua_SetFont);
  lua_register(L, "OpenFont", _lua_OpenFont);
  lua_register(L, "CloseFont", _lua_CloseFont);
  lua_register(L, "AskSoftStyle", _lua_AskSoftStyle);
  lua_register(L, "AddBob", _lua_AddBob);
  lua_register(L, "AddVSprite", _lua_AddVSprite);
  lua_register(L, "DoCollision", _lua_DoCollision);
  lua_register(L, "DrawGList", _lua_DrawGList);
  lua_register(L, "InitGels", _lua_InitGels);
  lua_register(L, "InitMasks", _lua_InitMasks);
  lua_register(L, "RemVSprite", _lua_RemVSprite);
  lua_register(L, "SortGList", _lua_SortGList);
  lua_register(L, "InitGMasks", _lua_InitGMasks);
  lua_register(L, "LoadRGB4", _lua_LoadRGB4);
  lua_register(L, "InitRastPort", _lua_InitRastPort);
  lua_register(L, "InitVPort", _lua_InitVPort);
  lua_register(L, "MrgCop", _lua_MrgCop);
  lua_register(L, "MakeVPort", _lua_MakeVPort);
  lua_register(L, "LoadView", _lua_LoadView);
  lua_register(L, "WaitBlit", _lua_WaitBlit);
  lua_register(L, "SetRast", _lua_SetRast);
  lua_register(L, "Move", _lua_Move);
  lua_register(L, "Draw", _lua_Draw);
  lua_register(L, "AreaMove", _lua_AreaMove);
  lua_register(L, "AreaDraw", _lua_AreaDraw);
  lua_register(L, "AreaEnd", _lua_AreaEnd);
  lua_register(L, "WaitTOF", _lua_WaitTOF);
  lua_register(L, "QBlit", _lua_QBlit);
  lua_register(L, "QBSBlit", _lua_QBSBlit);
  lua_register(L, "BltClear", _lua_BltClear);
  lua_register(L, "ReadPixel", _lua_ReadPixel);
  lua_register(L, "WritePixel", _lua_WritePixel);
  lua_register(L, "Flood", _lua_Flood);
  lua_register(L, "PolyDraw", _lua_PolyDraw);
  lua_register(L, "SetAPen", _lua_SetAPen);
  lua_register(L, "SetBPen", _lua_SetBPen);
  lua_register(L, "SetDrMd", _lua_SetDrMd);
  lua_register(L, "InitView", _lua_InitView);
  lua_register(L, "CBump", _lua_CBump);
  lua_register(L, "CMove", _lua_CMove);
  lua_register(L, "CWait", _lua_CWait);
  lua_register(L, "VBeamPos", _lua_VBeamPos);
  lua_register(L, "WaitBOVP", _lua_WaitBOVP);
  lua_register(L, "GetSprite", _lua_GetSprite);
  lua_register(L, "FreeSprite", _lua_FreeSprite);
  lua_register(L, "LockLayerRom", _lua_LockLayerRom);
  lua_register(L, "UnlockLayerRom", _lua_UnlockLayerRom);
  lua_register(L, "SyncSBitMap", _lua_SyncSBitMap);
  lua_register(L, "CopySBitMap", _lua_CopySBitMap);
  lua_register(L, "OwnBlitter", _lua_OwnBlitter);
  lua_register(L, "DisownBlitter", _lua_DisownBlitter);
  lua_register(L, "InitTmpRas", _lua_InitTmpRas);
  lua_register(L, "AskFont", _lua_AskFont);
  lua_register(L, "AddFont", _lua_AddFont);
  lua_register(L, "RemFont", _lua_RemFont);
  lua_register(L, "AllocRaster", _lua_AllocRaster);
  lua_register(L, "FreeRaster", _lua_FreeRaster);
  lua_register(L, "NewRegion", _lua_NewRegion);
  lua_register(L, "ClearRegion", _lua_ClearRegion);
  lua_register(L, "DisposeRegion", _lua_DisposeRegion);
  lua_register(L, "FreeVPortCopLists", _lua_FreeVPortCopLists);
  lua_register(L, "FreeCopList", _lua_FreeCopList);
  lua_register(L, "FreeCprList", _lua_FreeCprList);
  lua_register(L, "GetColorMap", _lua_GetColorMap);
  lua_register(L, "FreeColorMap", _lua_FreeColorMap);
  lua_register(L, "GetRGB4", _lua_GetRGB4);
  lua_register(L, "ScrollVPort", _lua_ScrollVPort);
  lua_register(L, "UCopperListInit", _lua_UCopperListInit);
  lua_register(L, "AttemptLockLayerRom", _lua_AttemptLockLayerRom);
  lua_register(L, "GfxNew", _lua_GfxNew);
  lua_register(L, "GfxFree", _lua_GfxFree);
  lua_register(L, "GfxAssociate", _lua_GfxAssociate);
  lua_register(L, "BitMapScale", _lua_BitMapScale);
  lua_register(L, "ScalerDiv", _lua_ScalerDiv);
  lua_register(L, "GfxLookUp", _lua_GfxLookUp);
  lua_register(L, "VideoControl", _lua_VideoControl);
  lua_register(L, "VideoControlTags", _lua_VideoControlTags);
  lua_register(L, "OpenMonitor", _lua_OpenMonitor);
  lua_register(L, "CloseMonitor", _lua_CloseMonitor);
  lua_register(L, "FindDisplayInfo", _lua_FindDisplayInfo);
  lua_register(L, "NextDisplayInfo", _lua_NextDisplayInfo);
  lua_register(L, "GetVPModeID", _lua_GetVPModeID);
  lua_register(L, "ModeNotAvailable", _lua_ModeNotAvailable);
  lua_register(L, "ExtendFont", _lua_ExtendFont);
  lua_register(L, "ExtendFontTags", _lua_ExtendFontTags);
  lua_register(L, "StripFont", _lua_StripFont);
  lua_register(L, "CalcIVG", _lua_CalcIVG);
  lua_register(L, "AttachPalExtra", _lua_AttachPalExtra);
  lua_register(L, "ObtainBestPenA", _lua_ObtainBestPenA);
  lua_register(L, "ObtainBestPen", _lua_ObtainBestPen);
  lua_register(L, "SetRGB32", _lua_SetRGB32);
  lua_register(L, "GetAPen", _lua_GetAPen);
  lua_register(L, "GetBPen", _lua_GetBPen);
  lua_register(L, "GetDrMd", _lua_GetDrMd);
  lua_register(L, "GetOutlinePen", _lua_GetOutlinePen);
  lua_register(L, "LoadRGB32", _lua_LoadRGB32);
  lua_register(L, "SetChipRev", _lua_SetChipRev);
  lua_register(L, "SetABPenDrMd", _lua_SetABPenDrMd);
  lua_register(L, "GetRGB32", _lua_GetRGB32);
  lua_register(L, "AllocBitMap", _lua_AllocBitMap);
  lua_register(L, "FreeBitMap", _lua_FreeBitMap);
  lua_register(L, "GetExtSpriteA", _lua_GetExtSpriteA);
  lua_register(L, "GetExtSprite", _lua_GetExtSprite);
  lua_register(L, "CoerceMode", _lua_CoerceMode);
  lua_register(L, "ChangeVPBitMap", _lua_ChangeVPBitMap);
  lua_register(L, "ReleasePen", _lua_ReleasePen);
  lua_register(L, "ObtainPen", _lua_ObtainPen);
  lua_register(L, "GetBitMapAttr", _lua_GetBitMapAttr);
  lua_register(L, "AllocDBufInfo", _lua_AllocDBufInfo);
  lua_register(L, "FreeDBufInfo", _lua_FreeDBufInfo);
  lua_register(L, "SetOutlinePen", _lua_SetOutlinePen);
  lua_register(L, "SetWriteMask", _lua_SetWriteMask);
  lua_register(L, "SetMaxPen", _lua_SetMaxPen);
  lua_register(L, "SetRGB32CM", _lua_SetRGB32CM);
  lua_register(L, "FindColor", _lua_FindColor);
  lua_register(L, "AllocSpriteDataA", _lua_AllocSpriteDataA);
  lua_register(L, "AllocSpriteData", _lua_AllocSpriteData);
  lua_register(L, "ChangeExtSpriteA", _lua_ChangeExtSpriteA);
  lua_register(L, "ChangeExtSprite", _lua_ChangeExtSprite);
  lua_register(L, "FreeSpriteData", _lua_FreeSpriteData);
  lua_register(L, "SetRPAttrsA", _lua_SetRPAttrsA);
  lua_register(L, "SetRPAttrs", _lua_SetRPAttrs);
  lua_register(L, "GetRPAttrsA", _lua_GetRPAttrsA);
  lua_register(L, "GetRPAttrs", _lua_GetRPAttrs);
  lua_register(L, "BestModeIDA", _lua_BestModeIDA);
  lua_register(L, "BestModeID", _lua_BestModeID);
  lua_register(L, "RemBob", _lua_RemBob);
}

static void
_lua_gen_installGeneratedFunctionCallers(lua_State *L)
{
  (void)L;
}

void
lua_gen_install(lua_State *L) {
  _lua_gen_install_defines(L);

  _lua_gen_installGeneratedMetaTables(L);
  _lua_gen_installGeneratedEnums(L);
  _lua_gen_installGeneratedFunctions(L);
  _lua_gen_installGeneratedFunctionCallers(L);
}

