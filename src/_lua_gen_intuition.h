#define _lua_gen_pushMinNode(l, o) amiga_push_type(l, o, "MinNode")

#define _lua_gen_checkMinNode(l, i) amiga_check_type(l, i,  "MinNode")

#define _lua_gen_pushList(l, o) amiga_push_type(l, o, "List")

#define _lua_gen_checkList(l, i) amiga_check_type(l, i,  "List")

#define _lua_gen_pushMsgPort(l, o) amiga_push_type(l, o, "MsgPort")

#define _lua_gen_checkMsgPort(l, i) amiga_check_type(l, i,  "MsgPort")

#define _lua_gen_pushMessage(l, o) amiga_push_type(l, o, "Message")

#define _lua_gen_checkMessage(l, i) amiga_check_type(l, i,  "Message")

#define _lua_gen_pushHook(l, o) amiga_push_type(l, o, "Hook")

#define _lua_gen_checkHook(l, i) amiga_check_type(l, i,  "Hook")

#define _lua_gen_pushIClass(l, o) amiga_push_type(l, o, "IClass")

#define _lua_gen_checkIClass(l, i) amiga_check_type(l, i,  "IClass")

#define _lua_gen_pushPoint(l, o) amiga_push_type(l, o, "Point")

#define _lua_gen_checkPoint(l, i) amiga_check_type(l, i,  "Point")

#define _lua_gen_pushBitMap(l, o) amiga_push_type(l, o, "BitMap")

#define _lua_gen_checkBitMap(l, i) amiga_check_type(l, i,  "BitMap")

#define _lua_gen_pushView(l, o) amiga_push_type(l, o, "View")

#define _lua_gen_checkView(l, i) amiga_check_type(l, i,  "View")

#define _lua_gen_pushViewPort(l, o) amiga_push_type(l, o, "ViewPort")

#define _lua_gen_checkViewPort(l, i) amiga_check_type(l, i,  "ViewPort")

#define _lua_gen_pushViewPortExtra(l, o) amiga_push_type(l, o, "ViewPortExtra")

#define _lua_gen_checkViewPortExtra(l, i) amiga_check_type(l, i,  "ViewPortExtra")

#define _lua_gen_pushRasInfo(l, o) amiga_push_type(l, o, "RasInfo")

#define _lua_gen_checkRasInfo(l, i) amiga_check_type(l, i,  "RasInfo")

#define _lua_gen_pushColorMap(l, o) amiga_push_type(l, o, "ColorMap")

#define _lua_gen_checkColorMap(l, i) amiga_check_type(l, i,  "ColorMap")

#define _lua_gen_pushDBufInfo(l, o) amiga_push_type(l, o, "DBufInfo")

#define _lua_gen_checkDBufInfo(l, i) amiga_check_type(l, i,  "DBufInfo")

#define _lua_gen_pushBorder(l, o) amiga_push_type(l, o, "Border")

#define _lua_gen_checkBorder(l, i) amiga_check_type(l, i,  "Border")

#define _lua_gen_pushClipRect(l, o) amiga_push_type(l, o, "ClipRect")

#define _lua_gen_checkClipRect(l, i) amiga_check_type(l, i,  "ClipRect")

#define _lua_gen_pushDrawInfo(l, o) amiga_push_type(l, o, "DrawInfo")

#define _lua_gen_checkDrawInfo(l, i) amiga_check_type(l, i,  "DrawInfo")

#define _lua_gen_pushGadget(l, o) amiga_push_type(l, o, "Gadget")

#define _lua_gen_checkGadget(l, i) amiga_check_type(l, i,  "Gadget")

#define _lua_gen_pushGadgetInfo(l, o) amiga_push_type(l, o, "GadgetInfo")

#define _lua_gen_checkGadgetInfo(l, i) amiga_check_type(l, i,  "GadgetInfo")

#define _lua_gen_pushGelsInfo(l, o) amiga_push_type(l, o, "GelsInfo")

#define _lua_gen_checkGelsInfo(l, i) amiga_check_type(l, i,  "GelsInfo")

#define _lua_gen_pushImage(l, o) amiga_push_type(l, o, "Image")

#define _lua_gen_checkImage(l, i) amiga_check_type(l, i,  "Image")

#define _lua_gen_pushInputEvent(l, o) amiga_push_type(l, o, "InputEvent")

#define _lua_gen_checkInputEvent(l, i) amiga_check_type(l, i,  "InputEvent")

#define _lua_gen_pushIntuiText(l, o) amiga_push_type(l, o, "IntuiText")

#define _lua_gen_checkIntuiText(l, i) amiga_check_type(l, i,  "IntuiText")

#define _lua_gen_pushKeyMap(l, o) amiga_push_type(l, o, "KeyMap")

#define _lua_gen_checkKeyMap(l, i) amiga_check_type(l, i,  "KeyMap")

#define _lua_gen_pushLayer(l, o) amiga_push_type(l, o, "Layer")

#define _lua_gen_checkLayer(l, i) amiga_check_type(l, i,  "Layer")

#define _lua_gen_pushLayer_Info(l, o) amiga_push_type(l, o, "Layer_Info")

#define _lua_gen_checkLayer_Info(l, i) amiga_check_type(l, i,  "Layer_Info")

#define _lua_gen_pushMenu(l, o) amiga_push_type(l, o, "Menu")

#define _lua_gen_checkMenu(l, i) amiga_check_type(l, i,  "Menu")

#define _lua_gen_pushMenuItem(l, o) amiga_push_type(l, o, "MenuItem")

#define _lua_gen_checkMenuItem(l, i) amiga_check_type(l, i,  "MenuItem")

#define _lua_gen_pushNewGadget(l, o) amiga_push_type(l, o, "NewGadget")

#define _lua_gen_checkNewGadget(l, i) amiga_check_type(l, i,  "NewGadget")

#define _lua_gen_pushNewMenu(l, o) amiga_push_type(l, o, "NewMenu")

#define _lua_gen_checkNewMenu(l, i) amiga_check_type(l, i,  "NewMenu")

#define _lua_gen_pushNewScreen(l, o) amiga_push_type(l, o, "NewScreen")

#define _lua_gen_checkNewScreen(l, i) amiga_check_type(l, i,  "NewScreen")

#define _lua_gen_pushNewWindow(l, o) amiga_push_type(l, o, "NewWindow")

#define _lua_gen_checkNewWindow(l, i) amiga_check_type(l, i,  "NewWindow")

#define _lua_gen_pushRastPort(l, o) amiga_push_type(l, o, "RastPort")

#define _lua_gen_checkRastPort(l, i) amiga_check_type(l, i,  "RastPort")

#define _lua_gen_pushRequester(l, o) amiga_push_type(l, o, "Requester")

#define _lua_gen_checkRequester(l, i) amiga_check_type(l, i,  "Requester")

#define _lua_gen_pushScreen(l, o) amiga_push_type(l, o, "Screen")

#define _lua_gen_checkScreen(l, i) amiga_check_type(l, i,  "Screen")

#define _lua_gen_pushTextAttr(l, o) amiga_push_type(l, o, "TextAttr")

#define _lua_gen_checkTextAttr(l, i) amiga_check_type(l, i,  "TextAttr")

#define _lua_gen_pushTextFont(l, o) amiga_push_type(l, o, "TextFont")

#define _lua_gen_checkTextFont(l, i) amiga_check_type(l, i,  "TextFont")

#define _lua_gen_pushWindow(l, o) amiga_push_type(l, o, "Window")

#define _lua_gen_checkWindow(l, i) amiga_check_type(l, i,  "Window")

#define _lua_gen_pushStringInfo(l, o) amiga_push_type(l, o, "StringInfo")

#define _lua_gen_checkStringInfo(l, i) amiga_check_type(l, i,  "StringInfo")

#define _lua_gen_pushIntuiMessage(l, o) amiga_push_type(l, o, "IntuiMessage")

#define _lua_gen_checkIntuiMessage(l, i) amiga_check_type(l, i,  "IntuiMessage")

#define _lua_gen_pushIBox(l, o) amiga_push_type(l, o, "IBox")

#define _lua_gen_checkIBox(l, i) amiga_check_type(l, i,  "IBox")

#define _lua_gen_pushScreenBuffer(l, o) amiga_push_type(l, o, "ScreenBuffer")

#define _lua_gen_checkScreenBuffer(l, i) amiga_check_type(l, i,  "ScreenBuffer")

#define _lua_gen_pushStringExtend(l, o) amiga_push_type(l, o, "StringExtend")

#define _lua_gen_checkStringExtend(l, i) amiga_check_type(l, i,  "StringExtend")

#define _lua_gen_pushGadgetPtr(l, o) amiga_push_type(l, o, "GadgetPtr")

#define _lua_gen_checkGadgetPtr(l, i) amiga_check_type(l, i,  "GadgetPtr")

static int
_lua_gen_Hook_newindex(lua_State *L)
{
  struct Hook *obj = *(struct Hook **)luaL_checkudata(L, 1, "Hook");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "h_MinNode.mln_Succ") == 0) {
    // finder 1
    //obj->h_MinNode.mln_Succ = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->h_MinNode.mln_Succ = (struct MinNode *)_lua_gen_checkMinNode(L, 3);
    return 0;
  }
  if (strcmp(key, "h_MinNode.mln_Pred") == 0) {
    // finder 1
    //obj->h_MinNode.mln_Pred = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->h_MinNode.mln_Pred = (struct MinNode *)_lua_gen_checkMinNode(L, 3);
    return 0;
  }
  if (strcmp(key, "h_MinNode") == 0) {
    // finder 0
    struct MinNode *val = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->h_MinNode = *val;
    return 0;
  }
  // Unsupported type h_Entry ULONG ()()
  if (strcmp(key, "h_Entry") == 0) {
    return luaL_error(L, "Unsupported type ULONG ()() for field h_Entry");
  }
  // Unsupported type h_SubEntry ULONG ()()
  if (strcmp(key, "h_SubEntry") == 0) {
    return luaL_error(L, "Unsupported type ULONG ()() for field h_SubEntry");
  }
  if (strcmp(key, "h_Data") == 0) {
    obj->h_Data = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_Hook_constructor(lua_State *L)
{
  // Allocate pointer-to-struct Hook in userdata
  struct Hook **objp = lua_newuserdata(L, sizeof(struct Hook *));
  *objp = malloc(sizeof(struct Hook));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct Hook));

  // Set metatable
  luaL_getmetatable(L, "Hook");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_Hook_index(lua_State *L)
{
  struct Hook *obj = *(struct Hook **)luaL_checkudata(L, 1, "Hook");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "h_MinNode.mln_Succ") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)obj->h_MinNode.mln_Succ;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "h_MinNode.mln_Pred") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)obj->h_MinNode.mln_Pred;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "h_MinNode") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)&obj->h_MinNode;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  // Unsupported h_Entry ULONG (*)()
  if (strcmp(key, "h_Entry") == 0) {
    return luaL_error(L, "Unsupported type ULONG (*)() for field h_Entry");
  }
  // Unsupported h_SubEntry ULONG (*)()
  if (strcmp(key, "h_SubEntry") == 0) {
    return luaL_error(L, "Unsupported type ULONG (*)() for field h_SubEntry");
  }
  if (strcmp(key, "h_Data") == 0) {
    lua_pushlightuserdata(L, obj->h_Data);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct Hook));
    return 1;
}

  return 0;
}

static void
_lua_gen_Hook_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "h_Entry");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "h_SubEntry");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "h_Data");
  lua_rawseti(L, -2, 3);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_Hook(lua_State *L) {
  if (luaL_newmetatable(L, "Hook")) {
    lua_pushcfunction(L, _lua_gen_Hook_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_Hook_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_Hook_constructor);
    lua_setglobal(L, "Hook");
    _lua_gen_Hook_install_keys(L);
    lua_pushstring(L, "Hook");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

typedef struct {
  ULONG* data;
  uint16_t count;
} lua_gen_wrapped_ULONG_array_data_t;

static int _lua_gen_wrapped_ULONG_array_ptr_method(lua_State* L) {
    lua_gen_wrapped_ULONG_array_data_t* wrapper = luaL_checkudata(L, 1, "ULONG_array_proxy");
    int index = luaL_checkinteger(L, 2);
    void* ptr = &wrapper->data[index - 1];
    lua_pushlightuserdata(L, ptr);
    return 1;
}
static int
_lua_gen_wrapped_ULONG_array_index(lua_State* L)
{
  lua_gen_wrapped_ULONG_array_data_t* wrapper = luaL_checkudata(L, 1, "ULONG_array_proxy");
  if (lua_isinteger(L, 2)) {
    int index = lua_tointeger(L, 2);
    if (index < 1 || index > wrapper->count)
      return luaL_error(L, "index out of range (1..%d)", wrapper->count);
    lua_pushinteger(L, wrapper->data[index - 1]);
    return 1;
  }

  // Not a numeric key? Try methods
  lua_getmetatable(L, 1);
  lua_getfield(L, -1, "__methods");
  lua_pushvalue(L, 2);
  lua_gettable(L, -2);
  return 1;
}

static int
_lua_gen_wrapped_ULONG_array_newindex(lua_State* L)
{
  lua_gen_wrapped_ULONG_array_data_t* wrapper = luaL_checkudata(L, 1, "ULONG_array_proxy");
  if (!lua_isinteger(L, 2))
    return luaL_error(L, "only integer indices allowed");
  int index = lua_tointeger(L, 2);
  if (index < 1 || index > wrapper->count)
    return luaL_error(L, "index out of range (1..%d)", wrapper->count);
  ULONG value = luaL_checkinteger(L,  3);
  wrapper->data[index - 1] = value;
  return 0;
}

static void
_lua_gen_push_ULONG_array_proxy(lua_State *L,  ULONG *array, int count)
{

  lua_gen_wrapped_ULONG_array_data_t* wrapper = lua_newuserdata(L, sizeof(lua_gen_wrapped_ULONG_array_data_t));
  wrapper->data = array;
  wrapper->count = count;

  if (luaL_newmetatable(L, "ULONG_array_proxy")) {
    // Create method table
    lua_newtable(L);
    lua_pushcfunction(L, _lua_gen_wrapped_ULONG_array_ptr_method);
    lua_setfield(L, -2, "ptr");
    lua_setfield(L, -2, "__methods");

    // __index handles both numeric and method lookup
    lua_pushcfunction(L, _lua_gen_wrapped_ULONG_array_index);
    lua_setfield(L, -2, "__index");

    // __newindex for writing
    lua_pushcfunction(L, _lua_gen_wrapped_ULONG_array_newindex);
    lua_setfield(L, -2, "__newindex");
  }

  lua_setmetatable(L, -2);  // assign to userdata

}
static int
_lua_gen_GadgetInfo_newindex(lua_State *L)
{
  struct GadgetInfo *obj = *(struct GadgetInfo **)luaL_checkudata(L, 1, "GadgetInfo");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "gi_Screen") == 0) {
    // finder 1
    //obj->gi_Screen = *(struct Screen **)luaL_checkudata(L, 3, "Screen");
    obj->gi_Screen = (struct Screen *)_lua_gen_checkScreen(L, 3);
    return 0;
  }
  if (strcmp(key, "gi_Window") == 0) {
    // finder 1
    //obj->gi_Window = *(struct Window **)luaL_checkudata(L, 3, "Window");
    obj->gi_Window = (struct Window *)_lua_gen_checkWindow(L, 3);
    return 0;
  }
  if (strcmp(key, "gi_Requester") == 0) {
    // finder 1
    //obj->gi_Requester = *(struct Requester **)luaL_checkudata(L, 3, "Requester");
    obj->gi_Requester = (struct Requester *)_lua_gen_checkRequester(L, 3);
    return 0;
  }
  if (strcmp(key, "gi_RastPort") == 0) {
    // finder 1
    //obj->gi_RastPort = *(struct RastPort **)luaL_checkudata(L, 3, "RastPort");
    obj->gi_RastPort = (struct RastPort *)_lua_gen_checkRastPort(L, 3);
    return 0;
  }
  if (strcmp(key, "gi_Layer") == 0) {
    // finder 1
    //obj->gi_Layer = *(struct Layer **)luaL_checkudata(L, 3, "Layer");
    obj->gi_Layer = (struct Layer *)_lua_gen_checkLayer(L, 3);
    return 0;
  }
  if (strcmp(key, "gi_Domain.Left") == 0) {
    obj->gi_Domain.Left = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "gi_Domain.Top") == 0) {
    obj->gi_Domain.Top = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "gi_Domain.Width") == 0) {
    obj->gi_Domain.Width = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "gi_Domain.Height") == 0) {
    obj->gi_Domain.Height = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "gi_Domain") == 0) {
    // finder 0
    struct IBox *val = *(struct IBox **)luaL_checkudata(L, 3, "IBox");
    obj->gi_Domain = *val;
    return 0;
  }
  if (strcmp(key, "gi_Pens.DetailPen") == 0) {
    obj->gi_Pens.DetailPen = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "gi_Pens.BlockPen") == 0) {
    obj->gi_Pens.BlockPen = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type gi_Pens unnamed struct
  if (strcmp(key, "gi_Pens") == 0) {
    return luaL_error(L, "Unsupported type unnamed struct for field gi_Pens");
  }
  if (strcmp(key, "gi_DrInfo") == 0) {
    // finder 1
    //obj->gi_DrInfo = *(struct DrawInfo **)luaL_checkudata(L, 3, "DrawInfo");
    obj->gi_DrInfo = (struct DrawInfo *)_lua_gen_checkDrawInfo(L, 3);
    return 0;
  }
  // gi_Reserved[6] proxied via the index
  return 0;
}


static int
_lua_GadgetInfo_constructor(lua_State *L)
{
  // Allocate pointer-to-struct GadgetInfo in userdata
  struct GadgetInfo **objp = lua_newuserdata(L, sizeof(struct GadgetInfo *));
  *objp = malloc(sizeof(struct GadgetInfo));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct GadgetInfo));

  // Set metatable
  luaL_getmetatable(L, "GadgetInfo");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_GadgetInfo_index(lua_State *L)
{
  struct GadgetInfo *obj = *(struct GadgetInfo **)luaL_checkudata(L, 1, "GadgetInfo");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "gi_Screen") == 0) {
    struct Screen **ud = (struct Screen **)lua_newuserdata(L, sizeof(struct Screen *));
    *ud = (struct Screen*)obj->gi_Screen;
    luaL_getmetatable(L, "Screen");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "gi_Window") == 0) {
    struct Window **ud = (struct Window **)lua_newuserdata(L, sizeof(struct Window *));
    *ud = (struct Window*)obj->gi_Window;
    luaL_getmetatable(L, "Window");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "gi_Requester") == 0) {
    struct Requester **ud = (struct Requester **)lua_newuserdata(L, sizeof(struct Requester *));
    *ud = (struct Requester*)obj->gi_Requester;
    luaL_getmetatable(L, "Requester");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "gi_RastPort") == 0) {
    struct RastPort **ud = (struct RastPort **)lua_newuserdata(L, sizeof(struct RastPort *));
    *ud = (struct RastPort*)obj->gi_RastPort;
    luaL_getmetatable(L, "RastPort");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "gi_Layer") == 0) {
    struct Layer **ud = (struct Layer **)lua_newuserdata(L, sizeof(struct Layer *));
    *ud = (struct Layer*)obj->gi_Layer;
    luaL_getmetatable(L, "Layer");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "gi_Domain.Left") == 0) {
    lua_pushinteger(L, obj->gi_Domain.Left);
    return 1;
  }
  if (strcmp(key, "gi_Domain.Top") == 0) {
    lua_pushinteger(L, obj->gi_Domain.Top);
    return 1;
  }
  if (strcmp(key, "gi_Domain.Width") == 0) {
    lua_pushinteger(L, obj->gi_Domain.Width);
    return 1;
  }
  if (strcmp(key, "gi_Domain.Height") == 0) {
    lua_pushinteger(L, obj->gi_Domain.Height);
    return 1;
  }
  if (strcmp(key, "gi_Domain") == 0) {
    struct IBox **ud = (struct IBox **)lua_newuserdata(L, sizeof(struct IBox *));
    *ud = (struct IBox*)&obj->gi_Domain;
    luaL_getmetatable(L, "IBox");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "gi_Pens.DetailPen") == 0) {
    lua_pushinteger(L, obj->gi_Pens.DetailPen);
    return 1;
  }
  if (strcmp(key, "gi_Pens.BlockPen") == 0) {
    lua_pushinteger(L, obj->gi_Pens.BlockPen);
    return 1;
  }
  // Unsupported gi_Pens unnamed struct
  if (strcmp(key, "gi_Pens") == 0) {
    return luaL_error(L, "Unsupported type unnamed struct for field gi_Pens");
  }
  if (strcmp(key, "gi_DrInfo") == 0) {
    struct DrawInfo **ud = (struct DrawInfo **)lua_newuserdata(L, sizeof(struct DrawInfo *));
    *ud = (struct DrawInfo*)obj->gi_DrInfo;
    luaL_getmetatable(L, "DrawInfo");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "gi_Reserved") == 0) {
    _lua_gen_push_ULONG_array_proxy(L, obj->gi_Reserved, 6);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct GadgetInfo));
    return 1;
}

  return 0;
}

static void
_lua_gen_GadgetInfo_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "gi_Domain.Left");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "gi_Domain.Top");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "gi_Domain.Width");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "gi_Domain.Height");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "gi_Pens.DetailPen");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "gi_Pens.BlockPen");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "gi_Reserved");
  lua_rawseti(L, -2, 7);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_GadgetInfo(lua_State *L) {
  if (luaL_newmetatable(L, "GadgetInfo")) {
    lua_pushcfunction(L, _lua_gen_GadgetInfo_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_GadgetInfo_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_GadgetInfo_constructor);
    lua_setglobal(L, "GadgetInfo");
    _lua_gen_GadgetInfo_install_keys(L);
    lua_pushstring(L, "GadgetInfo");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_IClass_newindex(lua_State *L)
{
  struct IClass *obj = *(struct IClass **)luaL_checkudata(L, 1, "IClass");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "cl_Dispatcher.h_MinNode.mln_Succ") == 0) {
    // finder 1
    //obj->cl_Dispatcher.h_MinNode.mln_Succ = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->cl_Dispatcher.h_MinNode.mln_Succ = (struct MinNode *)_lua_gen_checkMinNode(L, 3);
    return 0;
  }
  if (strcmp(key, "cl_Dispatcher.h_MinNode.mln_Pred") == 0) {
    // finder 1
    //obj->cl_Dispatcher.h_MinNode.mln_Pred = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->cl_Dispatcher.h_MinNode.mln_Pred = (struct MinNode *)_lua_gen_checkMinNode(L, 3);
    return 0;
  }
  if (strcmp(key, "cl_Dispatcher.h_MinNode") == 0) {
    // finder 0
    struct MinNode *val = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->cl_Dispatcher.h_MinNode = *val;
    return 0;
  }
  // Unsupported type cl_Dispatcher.h_Entry ULONG ()()
  if (strcmp(key, "cl_Dispatcher.h_Entry") == 0) {
    return luaL_error(L, "Unsupported type ULONG ()() for field cl_Dispatcher.h_Entry");
  }
  // Unsupported type cl_Dispatcher.h_SubEntry ULONG ()()
  if (strcmp(key, "cl_Dispatcher.h_SubEntry") == 0) {
    return luaL_error(L, "Unsupported type ULONG ()() for field cl_Dispatcher.h_SubEntry");
  }
  if (strcmp(key, "cl_Dispatcher.h_Data") == 0) {
    obj->cl_Dispatcher.h_Data = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "cl_Dispatcher") == 0) {
    // finder 0
    struct Hook *val = *(struct Hook **)luaL_checkudata(L, 3, "Hook");
    obj->cl_Dispatcher = *val;
    return 0;
  }
  if (strcmp(key, "cl_Reserved") == 0) {
    obj->cl_Reserved = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "cl_Super") == 0) {
    // finder 1
    //obj->cl_Super = *(struct IClass **)luaL_checkudata(L, 3, "IClass");
    obj->cl_Super = (struct IClass *)_lua_gen_checkIClass(L, 3);
    return 0;
  }
  if (strcmp(key, "cl_ID") == 0) {
    obj->cl_ID = (ClassID)luaL_checkstring(L, 3);
    return 0;
  }
  if (strcmp(key, "cl_InstOffset") == 0) {
    obj->cl_InstOffset = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "cl_InstSize") == 0) {
    obj->cl_InstSize = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "cl_UserData") == 0) {
    obj->cl_UserData = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "cl_SubclassCount") == 0) {
    obj->cl_SubclassCount = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "cl_ObjectCount") == 0) {
    obj->cl_ObjectCount = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "cl_Flags") == 0) {
    obj->cl_Flags = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_IClass_constructor(lua_State *L)
{
  // Allocate pointer-to-struct IClass in userdata
  struct IClass **objp = lua_newuserdata(L, sizeof(struct IClass *));
  *objp = malloc(sizeof(struct IClass));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct IClass));

  // Set metatable
  luaL_getmetatable(L, "IClass");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_IClass_index(lua_State *L)
{
  struct IClass *obj = *(struct IClass **)luaL_checkudata(L, 1, "IClass");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "cl_Dispatcher.h_MinNode.mln_Succ") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)obj->cl_Dispatcher.h_MinNode.mln_Succ;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "cl_Dispatcher.h_MinNode.mln_Pred") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)obj->cl_Dispatcher.h_MinNode.mln_Pred;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "cl_Dispatcher.h_MinNode") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)&obj->cl_Dispatcher.h_MinNode;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  // Unsupported cl_Dispatcher.h_Entry ULONG (*)()
  if (strcmp(key, "cl_Dispatcher.h_Entry") == 0) {
    return luaL_error(L, "Unsupported type ULONG (*)() for field cl_Dispatcher.h_Entry");
  }
  // Unsupported cl_Dispatcher.h_SubEntry ULONG (*)()
  if (strcmp(key, "cl_Dispatcher.h_SubEntry") == 0) {
    return luaL_error(L, "Unsupported type ULONG (*)() for field cl_Dispatcher.h_SubEntry");
  }
  if (strcmp(key, "cl_Dispatcher.h_Data") == 0) {
    lua_pushlightuserdata(L, obj->cl_Dispatcher.h_Data);
    return 1;
  }
  if (strcmp(key, "cl_Dispatcher") == 0) {
    struct Hook **ud = (struct Hook **)lua_newuserdata(L, sizeof(struct Hook *));
    *ud = (struct Hook*)&obj->cl_Dispatcher;
    luaL_getmetatable(L, "Hook");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "cl_Reserved") == 0) {
    lua_pushinteger(L, obj->cl_Reserved);
    return 1;
  }
  if (strcmp(key, "cl_Super") == 0) {
    struct IClass **ud = (struct IClass **)lua_newuserdata(L, sizeof(struct IClass *));
    *ud = (struct IClass*)obj->cl_Super;
    luaL_getmetatable(L, "IClass");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "cl_ID") == 0) {
    lua_pushstring(L, obj->cl_ID);
    return 1;
  }
  if (strcmp(key, "cl_InstOffset") == 0) {
    lua_pushinteger(L, obj->cl_InstOffset);
    return 1;
  }
  if (strcmp(key, "cl_InstSize") == 0) {
    lua_pushinteger(L, obj->cl_InstSize);
    return 1;
  }
  if (strcmp(key, "cl_UserData") == 0) {
    lua_pushinteger(L, obj->cl_UserData);
    return 1;
  }
  if (strcmp(key, "cl_SubclassCount") == 0) {
    lua_pushinteger(L, obj->cl_SubclassCount);
    return 1;
  }
  if (strcmp(key, "cl_ObjectCount") == 0) {
    lua_pushinteger(L, obj->cl_ObjectCount);
    return 1;
  }
  if (strcmp(key, "cl_Flags") == 0) {
    lua_pushinteger(L, obj->cl_Flags);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct IClass));
    return 1;
}

  return 0;
}

static void
_lua_gen_IClass_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "cl_Dispatcher.h_Entry");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "cl_Dispatcher.h_SubEntry");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "cl_Dispatcher.h_Data");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "cl_Reserved");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "cl_ID");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "cl_InstOffset");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "cl_InstSize");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "cl_UserData");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "cl_SubclassCount");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "cl_ObjectCount");
  lua_rawseti(L, -2, 10);
  lua_pushstring(L, "cl_Flags");
  lua_rawseti(L, -2, 11);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_IClass(lua_State *L) {
  if (luaL_newmetatable(L, "IClass")) {
    lua_pushcfunction(L, _lua_gen_IClass_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_IClass_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_IClass_constructor);
    lua_setglobal(L, "IClass");
    _lua_gen_IClass_install_keys(L);
    lua_pushstring(L, "IClass");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_Point_newindex(lua_State *L)
{
  Point *obj = *(Point **)luaL_checkudata(L, 1, "Point");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "x") == 0) {
    obj->x = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "y") == 0) {
    obj->y = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_Point_constructor(lua_State *L)
{
  // Allocate pointer-to-Point in userdata
  Point **objp = lua_newuserdata(L, sizeof(Point *));
  *objp = malloc(sizeof(Point));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(Point));

  // Set metatable
  luaL_getmetatable(L, "Point");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_Point_index(lua_State *L)
{
  Point *obj = *(Point **)luaL_checkudata(L, 1, "Point");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "x") == 0) {
    lua_pushinteger(L, obj->x);
    return 1;
  }
  if (strcmp(key, "y") == 0) {
    lua_pushinteger(L, obj->y);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(Point));
    return 1;
}

  return 0;
}

static void
_lua_gen_Point_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "x");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "y");
  lua_rawseti(L, -2, 2);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_Point(lua_State *L) {
  if (luaL_newmetatable(L, "Point")) {
    lua_pushcfunction(L, _lua_gen_Point_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_Point_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_Point_constructor);
    lua_setglobal(L, "Point");
    _lua_gen_Point_install_keys(L);
    lua_pushstring(L, "Point");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

typedef struct {
  PLANEPTR* data;
  uint16_t count;
} lua_gen_wrapped_PLANEPTR_array_data_t;

static int _lua_gen_wrapped_PLANEPTR_array_ptr_method(lua_State* L) {
    lua_gen_wrapped_PLANEPTR_array_data_t* wrapper = luaL_checkudata(L, 1, "PLANEPTR_array_proxy");
    int index = luaL_checkinteger(L, 2);
    void* ptr = &wrapper->data[index - 1];
    lua_pushlightuserdata(L, ptr);
    return 1;
}
static int
_lua_gen_wrapped_PLANEPTR_array_index(lua_State* L)
{
  lua_gen_wrapped_PLANEPTR_array_data_t* wrapper = luaL_checkudata(L, 1, "PLANEPTR_array_proxy");
  if (lua_isinteger(L, 2)) {
    int index = lua_tointeger(L, 2);
    if (index < 1 || index > wrapper->count)
      return luaL_error(L, "index out of range (1..%d)", wrapper->count);
    lua_pushlightuserdata(L, wrapper->data[index - 1]);
    return 1;
  }

  // Not a numeric key? Try methods
  lua_getmetatable(L, 1);
  lua_getfield(L, -1, "__methods");
  lua_pushvalue(L, 2);
  lua_gettable(L, -2);
  return 1;
}

static int
_lua_gen_wrapped_PLANEPTR_array_newindex(lua_State* L)
{
  lua_gen_wrapped_PLANEPTR_array_data_t* wrapper = luaL_checkudata(L, 1, "PLANEPTR_array_proxy");
  if (!lua_isinteger(L, 2))
    return luaL_error(L, "only integer indices allowed");
  int index = lua_tointeger(L, 2);
  if (index < 1 || index > wrapper->count)
    return luaL_error(L, "index out of range (1..%d)", wrapper->count);
  PLANEPTR value = lua_touserdata(L,  3);
  wrapper->data[index - 1] = value;
  return 0;
}

static void
_lua_gen_push_PLANEPTR_array_proxy(lua_State *L,  PLANEPTR *array, int count)
{

  lua_gen_wrapped_PLANEPTR_array_data_t* wrapper = lua_newuserdata(L, sizeof(lua_gen_wrapped_PLANEPTR_array_data_t));
  wrapper->data = array;
  wrapper->count = count;

  if (luaL_newmetatable(L, "PLANEPTR_array_proxy")) {
    // Create method table
    lua_newtable(L);
    lua_pushcfunction(L, _lua_gen_wrapped_PLANEPTR_array_ptr_method);
    lua_setfield(L, -2, "ptr");
    lua_setfield(L, -2, "__methods");

    // __index handles both numeric and method lookup
    lua_pushcfunction(L, _lua_gen_wrapped_PLANEPTR_array_index);
    lua_setfield(L, -2, "__index");

    // __newindex for writing
    lua_pushcfunction(L, _lua_gen_wrapped_PLANEPTR_array_newindex);
    lua_setfield(L, -2, "__newindex");
  }

  lua_setmetatable(L, -2);  // assign to userdata

}
static int
_lua_gen_BitMap_newindex(lua_State *L)
{
  struct BitMap *obj = *(struct BitMap **)luaL_checkudata(L, 1, "BitMap");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "BytesPerRow") == 0) {
    obj->BytesPerRow = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Rows") == 0) {
    obj->Rows = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Flags") == 0) {
    obj->Flags = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Depth") == 0) {
    obj->Depth = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "pad") == 0) {
    obj->pad = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // Planes[8] proxied via the index
  return 0;
}


static int
_lua_BitMap_constructor(lua_State *L)
{
  // Allocate pointer-to-struct BitMap in userdata
  struct BitMap **objp = lua_newuserdata(L, sizeof(struct BitMap *));
  *objp = malloc(sizeof(struct BitMap));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct BitMap));

  // Set metatable
  luaL_getmetatable(L, "BitMap");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_BitMap_index(lua_State *L)
{
  struct BitMap *obj = *(struct BitMap **)luaL_checkudata(L, 1, "BitMap");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "BytesPerRow") == 0) {
    lua_pushinteger(L, obj->BytesPerRow);
    return 1;
  }
  if (strcmp(key, "Rows") == 0) {
    lua_pushinteger(L, obj->Rows);
    return 1;
  }
  if (strcmp(key, "Flags") == 0) {
    lua_pushinteger(L, obj->Flags);
    return 1;
  }
  if (strcmp(key, "Depth") == 0) {
    lua_pushinteger(L, obj->Depth);
    return 1;
  }
  if (strcmp(key, "pad") == 0) {
    lua_pushinteger(L, obj->pad);
    return 1;
  }
  if (strcmp(key, "Planes") == 0) {
    _lua_gen_push_PLANEPTR_array_proxy(L, obj->Planes, 8);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct BitMap));
    return 1;
}

  return 0;
}

static void
_lua_gen_BitMap_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "BytesPerRow");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "Rows");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "Flags");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "Depth");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "pad");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "Planes");
  lua_rawseti(L, -2, 6);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_BitMap(lua_State *L) {
  if (luaL_newmetatable(L, "BitMap")) {
    lua_pushcfunction(L, _lua_gen_BitMap_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_BitMap_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_BitMap_constructor);
    lua_setglobal(L, "BitMap");
    _lua_gen_BitMap_install_keys(L);
    lua_pushstring(L, "BitMap");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_ViewPort_newindex(lua_State *L)
{
  struct ViewPort *obj = *(struct ViewPort **)luaL_checkudata(L, 1, "ViewPort");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "Next") == 0) {
    // finder 1
    //obj->Next = *(struct ViewPort **)luaL_checkudata(L, 3, "ViewPort");
    obj->Next = (struct ViewPort *)_lua_gen_checkViewPort(L, 3);
    return 0;
  }
  if (strcmp(key, "ColorMap") == 0) {
    // finder 1
    //obj->ColorMap = *(struct ColorMap **)luaL_checkudata(L, 3, "ColorMap");
    obj->ColorMap = (struct ColorMap *)_lua_gen_checkColorMap(L, 3);
    return 0;
  }
  // Unsupported type DspIns struct CopList
  if (strcmp(key, "DspIns") == 0) {
    return luaL_error(L, "Unsupported type struct CopList for field DspIns");
  }
  // Unsupported type SprIns struct CopList
  if (strcmp(key, "SprIns") == 0) {
    return luaL_error(L, "Unsupported type struct CopList for field SprIns");
  }
  // Unsupported type ClrIns struct CopList
  if (strcmp(key, "ClrIns") == 0) {
    return luaL_error(L, "Unsupported type struct CopList for field ClrIns");
  }
  if (strcmp(key, "UCopIns") == 0) {
    obj->UCopIns = (struct UCopList *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "DWidth") == 0) {
    obj->DWidth = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DHeight") == 0) {
    obj->DHeight = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DxOffset") == 0) {
    obj->DxOffset = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DyOffset") == 0) {
    obj->DyOffset = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Modes") == 0) {
    obj->Modes = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "SpritePriorities") == 0) {
    obj->SpritePriorities = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ExtendedModes") == 0) {
    obj->ExtendedModes = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "RasInfo") == 0) {
    // finder 1
    //obj->RasInfo = *(struct RasInfo **)luaL_checkudata(L, 3, "RasInfo");
    obj->RasInfo = (struct RasInfo *)_lua_gen_checkRasInfo(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_ViewPort_constructor(lua_State *L)
{
  // Allocate pointer-to-struct ViewPort in userdata
  struct ViewPort **objp = lua_newuserdata(L, sizeof(struct ViewPort *));
  *objp = malloc(sizeof(struct ViewPort));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct ViewPort));

  // Set metatable
  luaL_getmetatable(L, "ViewPort");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_ViewPort_index(lua_State *L)
{
  struct ViewPort *obj = *(struct ViewPort **)luaL_checkudata(L, 1, "ViewPort");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "Next") == 0) {
    struct ViewPort **ud = (struct ViewPort **)lua_newuserdata(L, sizeof(struct ViewPort *));
    *ud = (struct ViewPort*)obj->Next;
    luaL_getmetatable(L, "ViewPort");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "ColorMap") == 0) {
    struct ColorMap **ud = (struct ColorMap **)lua_newuserdata(L, sizeof(struct ColorMap *));
    *ud = (struct ColorMap*)obj->ColorMap;
    luaL_getmetatable(L, "ColorMap");
    lua_setmetatable(L, -2);
    return 1;
  }
  // Unsupported DspIns struct CopList *
  if (strcmp(key, "DspIns") == 0) {
    return luaL_error(L, "Unsupported type struct CopList * for field DspIns");
  }
  // Unsupported SprIns struct CopList *
  if (strcmp(key, "SprIns") == 0) {
    return luaL_error(L, "Unsupported type struct CopList * for field SprIns");
  }
  // Unsupported ClrIns struct CopList *
  if (strcmp(key, "ClrIns") == 0) {
    return luaL_error(L, "Unsupported type struct CopList * for field ClrIns");
  }
  if (strcmp(key, "UCopIns") == 0) {
    lua_pushlightuserdata(L, obj->UCopIns);
    return 1;
  }
  if (strcmp(key, "DWidth") == 0) {
    lua_pushinteger(L, obj->DWidth);
    return 1;
  }
  if (strcmp(key, "DHeight") == 0) {
    lua_pushinteger(L, obj->DHeight);
    return 1;
  }
  if (strcmp(key, "DxOffset") == 0) {
    lua_pushinteger(L, obj->DxOffset);
    return 1;
  }
  if (strcmp(key, "DyOffset") == 0) {
    lua_pushinteger(L, obj->DyOffset);
    return 1;
  }
  if (strcmp(key, "Modes") == 0) {
    lua_pushinteger(L, obj->Modes);
    return 1;
  }
  if (strcmp(key, "SpritePriorities") == 0) {
    lua_pushinteger(L, obj->SpritePriorities);
    return 1;
  }
  if (strcmp(key, "ExtendedModes") == 0) {
    lua_pushinteger(L, obj->ExtendedModes);
    return 1;
  }
  if (strcmp(key, "RasInfo") == 0) {
    struct RasInfo **ud = (struct RasInfo **)lua_newuserdata(L, sizeof(struct RasInfo *));
    *ud = (struct RasInfo*)obj->RasInfo;
    luaL_getmetatable(L, "RasInfo");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct ViewPort));
    return 1;
}

  return 0;
}

static void
_lua_gen_ViewPort_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "DWidth");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "DHeight");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "DxOffset");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "DyOffset");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "Modes");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "SpritePriorities");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "ExtendedModes");
  lua_rawseti(L, -2, 7);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_ViewPort(lua_State *L) {
  if (luaL_newmetatable(L, "ViewPort")) {
    lua_pushcfunction(L, _lua_gen_ViewPort_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_ViewPort_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_ViewPort_constructor);
    lua_setglobal(L, "ViewPort");
    _lua_gen_ViewPort_install_keys(L);
    lua_pushstring(L, "ViewPort");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_View_newindex(lua_State *L)
{
  struct View *obj = *(struct View **)luaL_checkudata(L, 1, "View");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "ViewPort") == 0) {
    // finder 1
    //obj->ViewPort = *(struct ViewPort **)luaL_checkudata(L, 3, "ViewPort");
    obj->ViewPort = (struct ViewPort *)_lua_gen_checkViewPort(L, 3);
    return 0;
  }
  // Unsupported type LOFCprList struct cprlist
  if (strcmp(key, "LOFCprList") == 0) {
    return luaL_error(L, "Unsupported type struct cprlist for field LOFCprList");
  }
  // Unsupported type SHFCprList struct cprlist
  if (strcmp(key, "SHFCprList") == 0) {
    return luaL_error(L, "Unsupported type struct cprlist for field SHFCprList");
  }
  if (strcmp(key, "DyOffset") == 0) {
    obj->DyOffset = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DxOffset") == 0) {
    obj->DxOffset = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Modes") == 0) {
    obj->Modes = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_View_constructor(lua_State *L)
{
  // Allocate pointer-to-struct View in userdata
  struct View **objp = lua_newuserdata(L, sizeof(struct View *));
  *objp = malloc(sizeof(struct View));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct View));

  // Set metatable
  luaL_getmetatable(L, "View");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_View_index(lua_State *L)
{
  struct View *obj = *(struct View **)luaL_checkudata(L, 1, "View");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "ViewPort") == 0) {
    struct ViewPort **ud = (struct ViewPort **)lua_newuserdata(L, sizeof(struct ViewPort *));
    *ud = (struct ViewPort*)obj->ViewPort;
    luaL_getmetatable(L, "ViewPort");
    lua_setmetatable(L, -2);
    return 1;
  }
  // Unsupported LOFCprList struct cprlist *
  if (strcmp(key, "LOFCprList") == 0) {
    return luaL_error(L, "Unsupported type struct cprlist * for field LOFCprList");
  }
  // Unsupported SHFCprList struct cprlist *
  if (strcmp(key, "SHFCprList") == 0) {
    return luaL_error(L, "Unsupported type struct cprlist * for field SHFCprList");
  }
  if (strcmp(key, "DyOffset") == 0) {
    lua_pushinteger(L, obj->DyOffset);
    return 1;
  }
  if (strcmp(key, "DxOffset") == 0) {
    lua_pushinteger(L, obj->DxOffset);
    return 1;
  }
  if (strcmp(key, "Modes") == 0) {
    lua_pushinteger(L, obj->Modes);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct View));
    return 1;
}

  return 0;
}

static void
_lua_gen_View_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "DyOffset");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "DxOffset");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "Modes");
  lua_rawseti(L, -2, 3);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_View(lua_State *L) {
  if (luaL_newmetatable(L, "View")) {
    lua_pushcfunction(L, _lua_gen_View_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_View_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_View_constructor);
    lua_setglobal(L, "View");
    _lua_gen_View_install_keys(L);
    lua_pushstring(L, "View");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_ColorMap_newindex(lua_State *L)
{
  struct ColorMap *obj = *(struct ColorMap **)luaL_checkudata(L, 1, "ColorMap");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "Flags") == 0) {
    obj->Flags = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Type") == 0) {
    obj->Type = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Count") == 0) {
    obj->Count = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ColorTable") == 0) {
    obj->ColorTable = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "cm_vpe") == 0) {
    // finder 1
    //obj->cm_vpe = *(struct ViewPortExtra **)luaL_checkudata(L, 3, "ViewPortExtra");
    obj->cm_vpe = (struct ViewPortExtra *)_lua_gen_checkViewPortExtra(L, 3);
    return 0;
  }
  if (strcmp(key, "LowColorBits") == 0) {
    obj->LowColorBits = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "TransparencyPlane") == 0) {
    obj->TransparencyPlane = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "SpriteResolution") == 0) {
    obj->SpriteResolution = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "SpriteResDefault") == 0) {
    obj->SpriteResDefault = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "AuxFlags") == 0) {
    obj->AuxFlags = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "cm_vp") == 0) {
    // finder 1
    //obj->cm_vp = *(struct ViewPort **)luaL_checkudata(L, 3, "ViewPort");
    obj->cm_vp = (struct ViewPort *)_lua_gen_checkViewPort(L, 3);
    return 0;
  }
  if (strcmp(key, "NormalDisplayInfo") == 0) {
    obj->NormalDisplayInfo = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "CoerceDisplayInfo") == 0) {
    obj->CoerceDisplayInfo = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  // Unsupported type cm_batch_items struct TagItem
  if (strcmp(key, "cm_batch_items") == 0) {
    return luaL_error(L, "Unsupported type struct TagItem for field cm_batch_items");
  }
  if (strcmp(key, "VPModeID") == 0) {
    obj->VPModeID = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type PalExtra struct PaletteExtra
  if (strcmp(key, "PalExtra") == 0) {
    return luaL_error(L, "Unsupported type struct PaletteExtra for field PalExtra");
  }
  if (strcmp(key, "SpriteBase_Even") == 0) {
    obj->SpriteBase_Even = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "SpriteBase_Odd") == 0) {
    obj->SpriteBase_Odd = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Bp_0_base") == 0) {
    obj->Bp_0_base = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Bp_1_base") == 0) {
    obj->Bp_1_base = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_ColorMap_constructor(lua_State *L)
{
  // Allocate pointer-to-struct ColorMap in userdata
  struct ColorMap **objp = lua_newuserdata(L, sizeof(struct ColorMap *));
  *objp = malloc(sizeof(struct ColorMap));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct ColorMap));

  // Set metatable
  luaL_getmetatable(L, "ColorMap");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_ColorMap_index(lua_State *L)
{
  struct ColorMap *obj = *(struct ColorMap **)luaL_checkudata(L, 1, "ColorMap");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "Flags") == 0) {
    lua_pushinteger(L, obj->Flags);
    return 1;
  }
  if (strcmp(key, "Type") == 0) {
    lua_pushinteger(L, obj->Type);
    return 1;
  }
  if (strcmp(key, "Count") == 0) {
    lua_pushinteger(L, obj->Count);
    return 1;
  }
  if (strcmp(key, "ColorTable") == 0) {
    lua_pushlightuserdata(L, obj->ColorTable);
    return 1;
  }
  if (strcmp(key, "cm_vpe") == 0) {
    struct ViewPortExtra **ud = (struct ViewPortExtra **)lua_newuserdata(L, sizeof(struct ViewPortExtra *));
    *ud = (struct ViewPortExtra*)obj->cm_vpe;
    luaL_getmetatable(L, "ViewPortExtra");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "LowColorBits") == 0) {
    lua_pushlightuserdata(L, obj->LowColorBits);
    return 1;
  }
  if (strcmp(key, "TransparencyPlane") == 0) {
    lua_pushinteger(L, obj->TransparencyPlane);
    return 1;
  }
  if (strcmp(key, "SpriteResolution") == 0) {
    lua_pushinteger(L, obj->SpriteResolution);
    return 1;
  }
  if (strcmp(key, "SpriteResDefault") == 0) {
    lua_pushinteger(L, obj->SpriteResDefault);
    return 1;
  }
  if (strcmp(key, "AuxFlags") == 0) {
    lua_pushinteger(L, obj->AuxFlags);
    return 1;
  }
  if (strcmp(key, "cm_vp") == 0) {
    struct ViewPort **ud = (struct ViewPort **)lua_newuserdata(L, sizeof(struct ViewPort *));
    *ud = (struct ViewPort*)obj->cm_vp;
    luaL_getmetatable(L, "ViewPort");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "NormalDisplayInfo") == 0) {
    lua_pushlightuserdata(L, obj->NormalDisplayInfo);
    return 1;
  }
  if (strcmp(key, "CoerceDisplayInfo") == 0) {
    lua_pushlightuserdata(L, obj->CoerceDisplayInfo);
    return 1;
  }
  // Unsupported cm_batch_items struct TagItem *
  if (strcmp(key, "cm_batch_items") == 0) {
    return luaL_error(L, "Unsupported type struct TagItem * for field cm_batch_items");
  }
  if (strcmp(key, "VPModeID") == 0) {
    lua_pushinteger(L, obj->VPModeID);
    return 1;
  }
  // Unsupported PalExtra struct PaletteExtra *
  if (strcmp(key, "PalExtra") == 0) {
    return luaL_error(L, "Unsupported type struct PaletteExtra * for field PalExtra");
  }
  if (strcmp(key, "SpriteBase_Even") == 0) {
    lua_pushinteger(L, obj->SpriteBase_Even);
    return 1;
  }
  if (strcmp(key, "SpriteBase_Odd") == 0) {
    lua_pushinteger(L, obj->SpriteBase_Odd);
    return 1;
  }
  if (strcmp(key, "Bp_0_base") == 0) {
    lua_pushinteger(L, obj->Bp_0_base);
    return 1;
  }
  if (strcmp(key, "Bp_1_base") == 0) {
    lua_pushinteger(L, obj->Bp_1_base);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct ColorMap));
    return 1;
}

  return 0;
}

static void
_lua_gen_ColorMap_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "Flags");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "Type");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "Count");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "ColorTable");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "LowColorBits");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "TransparencyPlane");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "SpriteResolution");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "SpriteResDefault");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "AuxFlags");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "NormalDisplayInfo");
  lua_rawseti(L, -2, 10);
  lua_pushstring(L, "CoerceDisplayInfo");
  lua_rawseti(L, -2, 11);
  lua_pushstring(L, "VPModeID");
  lua_rawseti(L, -2, 12);
  lua_pushstring(L, "SpriteBase_Even");
  lua_rawseti(L, -2, 13);
  lua_pushstring(L, "SpriteBase_Odd");
  lua_rawseti(L, -2, 14);
  lua_pushstring(L, "Bp_0_base");
  lua_rawseti(L, -2, 15);
  lua_pushstring(L, "Bp_1_base");
  lua_rawseti(L, -2, 16);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_ColorMap(lua_State *L) {
  if (luaL_newmetatable(L, "ColorMap")) {
    lua_pushcfunction(L, _lua_gen_ColorMap_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_ColorMap_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_ColorMap_constructor);
    lua_setglobal(L, "ColorMap");
    _lua_gen_ColorMap_install_keys(L);
    lua_pushstring(L, "ColorMap");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_RasInfo_newindex(lua_State *L)
{
  struct RasInfo *obj = *(struct RasInfo **)luaL_checkudata(L, 1, "RasInfo");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "Next") == 0) {
    // finder 1
    //obj->Next = *(struct RasInfo **)luaL_checkudata(L, 3, "RasInfo");
    obj->Next = (struct RasInfo *)_lua_gen_checkRasInfo(L, 3);
    return 0;
  }
  if (strcmp(key, "BitMap") == 0) {
    // finder 1
    //obj->BitMap = *(struct BitMap **)luaL_checkudata(L, 3, "BitMap");
    obj->BitMap = (struct BitMap *)_lua_gen_checkBitMap(L, 3);
    return 0;
  }
  if (strcmp(key, "RxOffset") == 0) {
    obj->RxOffset = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "RyOffset") == 0) {
    obj->RyOffset = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_RasInfo_constructor(lua_State *L)
{
  // Allocate pointer-to-struct RasInfo in userdata
  struct RasInfo **objp = lua_newuserdata(L, sizeof(struct RasInfo *));
  *objp = malloc(sizeof(struct RasInfo));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct RasInfo));

  // Set metatable
  luaL_getmetatable(L, "RasInfo");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_RasInfo_index(lua_State *L)
{
  struct RasInfo *obj = *(struct RasInfo **)luaL_checkudata(L, 1, "RasInfo");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "Next") == 0) {
    struct RasInfo **ud = (struct RasInfo **)lua_newuserdata(L, sizeof(struct RasInfo *));
    *ud = (struct RasInfo*)obj->Next;
    luaL_getmetatable(L, "RasInfo");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "BitMap") == 0) {
    struct BitMap **ud = (struct BitMap **)lua_newuserdata(L, sizeof(struct BitMap *));
    *ud = (struct BitMap*)obj->BitMap;
    luaL_getmetatable(L, "BitMap");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "RxOffset") == 0) {
    lua_pushinteger(L, obj->RxOffset);
    return 1;
  }
  if (strcmp(key, "RyOffset") == 0) {
    lua_pushinteger(L, obj->RyOffset);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct RasInfo));
    return 1;
}

  return 0;
}

static void
_lua_gen_RasInfo_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "RxOffset");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "RyOffset");
  lua_rawseti(L, -2, 2);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_RasInfo(lua_State *L) {
  if (luaL_newmetatable(L, "RasInfo")) {
    lua_pushcfunction(L, _lua_gen_RasInfo_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_RasInfo_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_RasInfo_constructor);
    lua_setglobal(L, "RasInfo");
    _lua_gen_RasInfo_install_keys(L);
    lua_pushstring(L, "RasInfo");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

typedef struct {
  APTR* data;
  uint16_t count;
} lua_gen_wrapped_APTR_array_data_t;

static int _lua_gen_wrapped_APTR_array_ptr_method(lua_State* L) {
    lua_gen_wrapped_APTR_array_data_t* wrapper = luaL_checkudata(L, 1, "APTR_array_proxy");
    int index = luaL_checkinteger(L, 2);
    void* ptr = &wrapper->data[index - 1];
    lua_pushlightuserdata(L, ptr);
    return 1;
}
static int
_lua_gen_wrapped_APTR_array_index(lua_State* L)
{
  lua_gen_wrapped_APTR_array_data_t* wrapper = luaL_checkudata(L, 1, "APTR_array_proxy");
  if (lua_isinteger(L, 2)) {
    int index = lua_tointeger(L, 2);
    if (index < 1 || index > wrapper->count)
      return luaL_error(L, "index out of range (1..%d)", wrapper->count);
    lua_pushlightuserdata(L, wrapper->data[index - 1]);
    return 1;
  }

  // Not a numeric key? Try methods
  lua_getmetatable(L, 1);
  lua_getfield(L, -1, "__methods");
  lua_pushvalue(L, 2);
  lua_gettable(L, -2);
  return 1;
}

static int
_lua_gen_wrapped_APTR_array_newindex(lua_State* L)
{
  lua_gen_wrapped_APTR_array_data_t* wrapper = luaL_checkudata(L, 1, "APTR_array_proxy");
  if (!lua_isinteger(L, 2))
    return luaL_error(L, "only integer indices allowed");
  int index = lua_tointeger(L, 2);
  if (index < 1 || index > wrapper->count)
    return luaL_error(L, "index out of range (1..%d)", wrapper->count);
  APTR value = lua_touserdata(L,  3);
  wrapper->data[index - 1] = value;
  return 0;
}

static void
_lua_gen_push_APTR_array_proxy(lua_State *L,  APTR *array, int count)
{

  lua_gen_wrapped_APTR_array_data_t* wrapper = lua_newuserdata(L, sizeof(lua_gen_wrapped_APTR_array_data_t));
  wrapper->data = array;
  wrapper->count = count;

  if (luaL_newmetatable(L, "APTR_array_proxy")) {
    // Create method table
    lua_newtable(L);
    lua_pushcfunction(L, _lua_gen_wrapped_APTR_array_ptr_method);
    lua_setfield(L, -2, "ptr");
    lua_setfield(L, -2, "__methods");

    // __index handles both numeric and method lookup
    lua_pushcfunction(L, _lua_gen_wrapped_APTR_array_index);
    lua_setfield(L, -2, "__index");

    // __newindex for writing
    lua_pushcfunction(L, _lua_gen_wrapped_APTR_array_newindex);
    lua_setfield(L, -2, "__newindex");
  }

  lua_setmetatable(L, -2);  // assign to userdata

}
static int
_lua_gen_ViewPortExtra_newindex(lua_State *L)
{
  struct ViewPortExtra *obj = *(struct ViewPortExtra **)luaL_checkudata(L, 1, "ViewPortExtra");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  // Unsupported type n.xln_Succ struct Node
  if (strcmp(key, "n.xln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field n.xln_Succ");
  }
  // Unsupported type n.xln_Pred struct Node
  if (strcmp(key, "n.xln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field n.xln_Pred");
  }
  if (strcmp(key, "n.xln_Type") == 0) {
    obj->n.xln_Type = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "n.xln_Pri") == 0) {
    obj->n.xln_Pri = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "n.xln_Name") == 0) {
    obj->n.xln_Name = (char *)luaL_checkstring(L, 3);
    return 0;
  }
  if (strcmp(key, "n.xln_Subsystem") == 0) {
    obj->n.xln_Subsystem = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "n.xln_Subtype") == 0) {
    obj->n.xln_Subtype = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type n.xln_Library struct GfxBase
  if (strcmp(key, "n.xln_Library") == 0) {
    return luaL_error(L, "Unsupported type struct GfxBase for field n.xln_Library");
  }
  // Unsupported type n.xln_Init LONG ()(struct ExtendedNode , UWORD)
  if (strcmp(key, "n.xln_Init") == 0) {
    return luaL_error(L, "Unsupported type LONG ()(struct ExtendedNode , UWORD) for field n.xln_Init");
  }
  // Unsupported type n struct ExtendedNode
  if (strcmp(key, "n") == 0) {
    return luaL_error(L, "Unsupported type struct ExtendedNode for field n");
  }
  if (strcmp(key, "ViewPort") == 0) {
    // finder 1
    //obj->ViewPort = *(struct ViewPort **)luaL_checkudata(L, 3, "ViewPort");
    obj->ViewPort = (struct ViewPort *)_lua_gen_checkViewPort(L, 3);
    return 0;
  }
  if (strcmp(key, "DisplayClip.MinX") == 0) {
    obj->DisplayClip.MinX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DisplayClip.MinY") == 0) {
    obj->DisplayClip.MinY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DisplayClip.MaxX") == 0) {
    obj->DisplayClip.MaxX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DisplayClip.MaxY") == 0) {
    obj->DisplayClip.MaxY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type DisplayClip struct Rectangle
  if (strcmp(key, "DisplayClip") == 0) {
    return luaL_error(L, "Unsupported type struct Rectangle for field DisplayClip");
  }
  if (strcmp(key, "VecTable") == 0) {
    obj->VecTable = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  // DriverData[2] proxied via the index
  if (strcmp(key, "Flags") == 0) {
    obj->Flags = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // Origin[2] proxied via the index
  if (strcmp(key, "cop1ptr") == 0) {
    obj->cop1ptr = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "cop2ptr") == 0) {
    obj->cop2ptr = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_ViewPortExtra_constructor(lua_State *L)
{
  // Allocate pointer-to-struct ViewPortExtra in userdata
  struct ViewPortExtra **objp = lua_newuserdata(L, sizeof(struct ViewPortExtra *));
  *objp = malloc(sizeof(struct ViewPortExtra));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct ViewPortExtra));

  // Set metatable
  luaL_getmetatable(L, "ViewPortExtra");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_ViewPortExtra_index(lua_State *L)
{
  struct ViewPortExtra *obj = *(struct ViewPortExtra **)luaL_checkudata(L, 1, "ViewPortExtra");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  // Unsupported n.xln_Succ struct Node *
  if (strcmp(key, "n.xln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field n.xln_Succ");
  }
  // Unsupported n.xln_Pred struct Node *
  if (strcmp(key, "n.xln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field n.xln_Pred");
  }
  if (strcmp(key, "n.xln_Type") == 0) {
    lua_pushinteger(L, obj->n.xln_Type);
    return 1;
  }
  if (strcmp(key, "n.xln_Pri") == 0) {
    lua_pushinteger(L, obj->n.xln_Pri);
    return 1;
  }
  if (strcmp(key, "n.xln_Name") == 0) {
    lua_pushstring(L, obj->n.xln_Name);
    return 1;
  }
  if (strcmp(key, "n.xln_Subsystem") == 0) {
    lua_pushinteger(L, obj->n.xln_Subsystem);
    return 1;
  }
  if (strcmp(key, "n.xln_Subtype") == 0) {
    lua_pushinteger(L, obj->n.xln_Subtype);
    return 1;
  }
  // Unsupported n.xln_Library struct GfxBase *
  if (strcmp(key, "n.xln_Library") == 0) {
    return luaL_error(L, "Unsupported type struct GfxBase * for field n.xln_Library");
  }
  // Unsupported n.xln_Init LONG (*)(struct ExtendedNode *, UWORD)
  if (strcmp(key, "n.xln_Init") == 0) {
    return luaL_error(L, "Unsupported type LONG (*)(struct ExtendedNode *, UWORD) for field n.xln_Init");
  }
  // Unsupported n struct ExtendedNode
  if (strcmp(key, "n") == 0) {
    return luaL_error(L, "Unsupported type struct ExtendedNode for field n");
  }
  if (strcmp(key, "ViewPort") == 0) {
    struct ViewPort **ud = (struct ViewPort **)lua_newuserdata(L, sizeof(struct ViewPort *));
    *ud = (struct ViewPort*)obj->ViewPort;
    luaL_getmetatable(L, "ViewPort");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "DisplayClip.MinX") == 0) {
    lua_pushinteger(L, obj->DisplayClip.MinX);
    return 1;
  }
  if (strcmp(key, "DisplayClip.MinY") == 0) {
    lua_pushinteger(L, obj->DisplayClip.MinY);
    return 1;
  }
  if (strcmp(key, "DisplayClip.MaxX") == 0) {
    lua_pushinteger(L, obj->DisplayClip.MaxX);
    return 1;
  }
  if (strcmp(key, "DisplayClip.MaxY") == 0) {
    lua_pushinteger(L, obj->DisplayClip.MaxY);
    return 1;
  }
  // Unsupported DisplayClip struct Rectangle
  if (strcmp(key, "DisplayClip") == 0) {
    return luaL_error(L, "Unsupported type struct Rectangle for field DisplayClip");
  }
  if (strcmp(key, "VecTable") == 0) {
    lua_pushlightuserdata(L, obj->VecTable);
    return 1;
  }
  if (strcmp(key, "DriverData") == 0) {
    _lua_gen_push_APTR_array_proxy(L, obj->DriverData, 2);
    return 1;
  }
  if (strcmp(key, "Flags") == 0) {
    lua_pushinteger(L, obj->Flags);
    return 1;
  }
  if (strcmp(key, "Origin") == 0) {
     return luaL_error(L, "Unsupported array type Point");
  }
  if (strcmp(key, "cop1ptr") == 0) {
    lua_pushinteger(L, obj->cop1ptr);
    return 1;
  }
  if (strcmp(key, "cop2ptr") == 0) {
    lua_pushinteger(L, obj->cop2ptr);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct ViewPortExtra));
    return 1;
}

  return 0;
}

static void
_lua_gen_ViewPortExtra_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "n.xln_Type");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "n.xln_Pri");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "n.xln_Name");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "n.xln_Subsystem");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "n.xln_Subtype");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "n.xln_Init");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "DisplayClip.MinX");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "DisplayClip.MinY");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "DisplayClip.MaxX");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "DisplayClip.MaxY");
  lua_rawseti(L, -2, 10);
  lua_pushstring(L, "VecTable");
  lua_rawseti(L, -2, 11);
  lua_pushstring(L, "DriverData");
  lua_rawseti(L, -2, 12);
  lua_pushstring(L, "Flags");
  lua_rawseti(L, -2, 13);
  lua_pushstring(L, "Origin");
  lua_rawseti(L, -2, 14);
  lua_pushstring(L, "cop1ptr");
  lua_rawseti(L, -2, 15);
  lua_pushstring(L, "cop2ptr");
  lua_rawseti(L, -2, 16);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_ViewPortExtra(lua_State *L) {
  if (luaL_newmetatable(L, "ViewPortExtra")) {
    lua_pushcfunction(L, _lua_gen_ViewPortExtra_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_ViewPortExtra_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_ViewPortExtra_constructor);
    lua_setglobal(L, "ViewPortExtra");
    _lua_gen_ViewPortExtra_install_keys(L);
    lua_pushstring(L, "ViewPortExtra");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_DBufInfo_newindex(lua_State *L)
{
  struct DBufInfo *obj = *(struct DBufInfo **)luaL_checkudata(L, 1, "DBufInfo");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "dbi_Link1") == 0) {
    obj->dbi_Link1 = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_Count1") == 0) {
    obj->dbi_Count1 = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type dbi_SafeMessage.mn_Node.ln_Succ struct Node
  if (strcmp(key, "dbi_SafeMessage.mn_Node.ln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field dbi_SafeMessage.mn_Node.ln_Succ");
  }
  // Unsupported type dbi_SafeMessage.mn_Node.ln_Pred struct Node
  if (strcmp(key, "dbi_SafeMessage.mn_Node.ln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field dbi_SafeMessage.mn_Node.ln_Pred");
  }
  if (strcmp(key, "dbi_SafeMessage.mn_Node.ln_Type") == 0) {
    obj->dbi_SafeMessage.mn_Node.ln_Type = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_SafeMessage.mn_Node.ln_Pri") == 0) {
    obj->dbi_SafeMessage.mn_Node.ln_Pri = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_SafeMessage.mn_Node.ln_Name") == 0) {
    obj->dbi_SafeMessage.mn_Node.ln_Name = (char *)luaL_checkstring(L, 3);
    return 0;
  }
  // Unsupported type dbi_SafeMessage.mn_Node struct Node
  if (strcmp(key, "dbi_SafeMessage.mn_Node") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field dbi_SafeMessage.mn_Node");
  }
  if (strcmp(key, "dbi_SafeMessage.mn_ReplyPort") == 0) {
    // finder 1
    //obj->dbi_SafeMessage.mn_ReplyPort = *(struct MsgPort **)luaL_checkudata(L, 3, "MsgPort");
    obj->dbi_SafeMessage.mn_ReplyPort = (struct MsgPort *)_lua_gen_checkMsgPort(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_SafeMessage.mn_Length") == 0) {
    obj->dbi_SafeMessage.mn_Length = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_SafeMessage") == 0) {
    // finder 0
    struct Message *val = *(struct Message **)luaL_checkudata(L, 3, "Message");
    obj->dbi_SafeMessage = *val;
    return 0;
  }
  if (strcmp(key, "dbi_UserData1") == 0) {
    obj->dbi_UserData1 = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_Link2") == 0) {
    obj->dbi_Link2 = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_Count2") == 0) {
    obj->dbi_Count2 = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type dbi_DispMessage.mn_Node.ln_Succ struct Node
  if (strcmp(key, "dbi_DispMessage.mn_Node.ln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field dbi_DispMessage.mn_Node.ln_Succ");
  }
  // Unsupported type dbi_DispMessage.mn_Node.ln_Pred struct Node
  if (strcmp(key, "dbi_DispMessage.mn_Node.ln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field dbi_DispMessage.mn_Node.ln_Pred");
  }
  if (strcmp(key, "dbi_DispMessage.mn_Node.ln_Type") == 0) {
    obj->dbi_DispMessage.mn_Node.ln_Type = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_DispMessage.mn_Node.ln_Pri") == 0) {
    obj->dbi_DispMessage.mn_Node.ln_Pri = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_DispMessage.mn_Node.ln_Name") == 0) {
    obj->dbi_DispMessage.mn_Node.ln_Name = (char *)luaL_checkstring(L, 3);
    return 0;
  }
  // Unsupported type dbi_DispMessage.mn_Node struct Node
  if (strcmp(key, "dbi_DispMessage.mn_Node") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field dbi_DispMessage.mn_Node");
  }
  if (strcmp(key, "dbi_DispMessage.mn_ReplyPort") == 0) {
    // finder 1
    //obj->dbi_DispMessage.mn_ReplyPort = *(struct MsgPort **)luaL_checkudata(L, 3, "MsgPort");
    obj->dbi_DispMessage.mn_ReplyPort = (struct MsgPort *)_lua_gen_checkMsgPort(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_DispMessage.mn_Length") == 0) {
    obj->dbi_DispMessage.mn_Length = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_DispMessage") == 0) {
    // finder 0
    struct Message *val = *(struct Message **)luaL_checkudata(L, 3, "Message");
    obj->dbi_DispMessage = *val;
    return 0;
  }
  if (strcmp(key, "dbi_UserData2") == 0) {
    obj->dbi_UserData2 = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_MatchLong") == 0) {
    obj->dbi_MatchLong = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_CopPtr1") == 0) {
    obj->dbi_CopPtr1 = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_CopPtr2") == 0) {
    obj->dbi_CopPtr2 = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_CopPtr3") == 0) {
    obj->dbi_CopPtr3 = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_BeamPos1") == 0) {
    obj->dbi_BeamPos1 = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "dbi_BeamPos2") == 0) {
    obj->dbi_BeamPos2 = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_DBufInfo_constructor(lua_State *L)
{
  // Allocate pointer-to-struct DBufInfo in userdata
  struct DBufInfo **objp = lua_newuserdata(L, sizeof(struct DBufInfo *));
  *objp = malloc(sizeof(struct DBufInfo));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct DBufInfo));

  // Set metatable
  luaL_getmetatable(L, "DBufInfo");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_DBufInfo_index(lua_State *L)
{
  struct DBufInfo *obj = *(struct DBufInfo **)luaL_checkudata(L, 1, "DBufInfo");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "dbi_Link1") == 0) {
    lua_pushlightuserdata(L, obj->dbi_Link1);
    return 1;
  }
  if (strcmp(key, "dbi_Count1") == 0) {
    lua_pushinteger(L, obj->dbi_Count1);
    return 1;
  }
  // Unsupported dbi_SafeMessage.mn_Node.ln_Succ struct Node *
  if (strcmp(key, "dbi_SafeMessage.mn_Node.ln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field dbi_SafeMessage.mn_Node.ln_Succ");
  }
  // Unsupported dbi_SafeMessage.mn_Node.ln_Pred struct Node *
  if (strcmp(key, "dbi_SafeMessage.mn_Node.ln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field dbi_SafeMessage.mn_Node.ln_Pred");
  }
  if (strcmp(key, "dbi_SafeMessage.mn_Node.ln_Type") == 0) {
    lua_pushinteger(L, obj->dbi_SafeMessage.mn_Node.ln_Type);
    return 1;
  }
  if (strcmp(key, "dbi_SafeMessage.mn_Node.ln_Pri") == 0) {
    lua_pushinteger(L, obj->dbi_SafeMessage.mn_Node.ln_Pri);
    return 1;
  }
  if (strcmp(key, "dbi_SafeMessage.mn_Node.ln_Name") == 0) {
    lua_pushstring(L, obj->dbi_SafeMessage.mn_Node.ln_Name);
    return 1;
  }
  // Unsupported dbi_SafeMessage.mn_Node struct Node
  if (strcmp(key, "dbi_SafeMessage.mn_Node") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field dbi_SafeMessage.mn_Node");
  }
  if (strcmp(key, "dbi_SafeMessage.mn_ReplyPort") == 0) {
    struct MsgPort **ud = (struct MsgPort **)lua_newuserdata(L, sizeof(struct MsgPort *));
    *ud = (struct MsgPort*)obj->dbi_SafeMessage.mn_ReplyPort;
    luaL_getmetatable(L, "MsgPort");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "dbi_SafeMessage.mn_Length") == 0) {
    lua_pushinteger(L, obj->dbi_SafeMessage.mn_Length);
    return 1;
  }
  if (strcmp(key, "dbi_SafeMessage") == 0) {
    struct Message **ud = (struct Message **)lua_newuserdata(L, sizeof(struct Message *));
    *ud = (struct Message*)&obj->dbi_SafeMessage;
    luaL_getmetatable(L, "Message");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "dbi_UserData1") == 0) {
    lua_pushlightuserdata(L, obj->dbi_UserData1);
    return 1;
  }
  if (strcmp(key, "dbi_Link2") == 0) {
    lua_pushlightuserdata(L, obj->dbi_Link2);
    return 1;
  }
  if (strcmp(key, "dbi_Count2") == 0) {
    lua_pushinteger(L, obj->dbi_Count2);
    return 1;
  }
  // Unsupported dbi_DispMessage.mn_Node.ln_Succ struct Node *
  if (strcmp(key, "dbi_DispMessage.mn_Node.ln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field dbi_DispMessage.mn_Node.ln_Succ");
  }
  // Unsupported dbi_DispMessage.mn_Node.ln_Pred struct Node *
  if (strcmp(key, "dbi_DispMessage.mn_Node.ln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field dbi_DispMessage.mn_Node.ln_Pred");
  }
  if (strcmp(key, "dbi_DispMessage.mn_Node.ln_Type") == 0) {
    lua_pushinteger(L, obj->dbi_DispMessage.mn_Node.ln_Type);
    return 1;
  }
  if (strcmp(key, "dbi_DispMessage.mn_Node.ln_Pri") == 0) {
    lua_pushinteger(L, obj->dbi_DispMessage.mn_Node.ln_Pri);
    return 1;
  }
  if (strcmp(key, "dbi_DispMessage.mn_Node.ln_Name") == 0) {
    lua_pushstring(L, obj->dbi_DispMessage.mn_Node.ln_Name);
    return 1;
  }
  // Unsupported dbi_DispMessage.mn_Node struct Node
  if (strcmp(key, "dbi_DispMessage.mn_Node") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field dbi_DispMessage.mn_Node");
  }
  if (strcmp(key, "dbi_DispMessage.mn_ReplyPort") == 0) {
    struct MsgPort **ud = (struct MsgPort **)lua_newuserdata(L, sizeof(struct MsgPort *));
    *ud = (struct MsgPort*)obj->dbi_DispMessage.mn_ReplyPort;
    luaL_getmetatable(L, "MsgPort");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "dbi_DispMessage.mn_Length") == 0) {
    lua_pushinteger(L, obj->dbi_DispMessage.mn_Length);
    return 1;
  }
  if (strcmp(key, "dbi_DispMessage") == 0) {
    struct Message **ud = (struct Message **)lua_newuserdata(L, sizeof(struct Message *));
    *ud = (struct Message*)&obj->dbi_DispMessage;
    luaL_getmetatable(L, "Message");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "dbi_UserData2") == 0) {
    lua_pushlightuserdata(L, obj->dbi_UserData2);
    return 1;
  }
  if (strcmp(key, "dbi_MatchLong") == 0) {
    lua_pushinteger(L, obj->dbi_MatchLong);
    return 1;
  }
  if (strcmp(key, "dbi_CopPtr1") == 0) {
    lua_pushlightuserdata(L, obj->dbi_CopPtr1);
    return 1;
  }
  if (strcmp(key, "dbi_CopPtr2") == 0) {
    lua_pushlightuserdata(L, obj->dbi_CopPtr2);
    return 1;
  }
  if (strcmp(key, "dbi_CopPtr3") == 0) {
    lua_pushlightuserdata(L, obj->dbi_CopPtr3);
    return 1;
  }
  if (strcmp(key, "dbi_BeamPos1") == 0) {
    lua_pushinteger(L, obj->dbi_BeamPos1);
    return 1;
  }
  if (strcmp(key, "dbi_BeamPos2") == 0) {
    lua_pushinteger(L, obj->dbi_BeamPos2);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct DBufInfo));
    return 1;
}

  return 0;
}

static void
_lua_gen_DBufInfo_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "dbi_Link1");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "dbi_Count1");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "dbi_SafeMessage.mn_Node.ln_Type");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "dbi_SafeMessage.mn_Node.ln_Pri");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "dbi_SafeMessage.mn_Node.ln_Name");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "dbi_SafeMessage.mn_Length");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "dbi_UserData1");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "dbi_Link2");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "dbi_Count2");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "dbi_DispMessage.mn_Node.ln_Type");
  lua_rawseti(L, -2, 10);
  lua_pushstring(L, "dbi_DispMessage.mn_Node.ln_Pri");
  lua_rawseti(L, -2, 11);
  lua_pushstring(L, "dbi_DispMessage.mn_Node.ln_Name");
  lua_rawseti(L, -2, 12);
  lua_pushstring(L, "dbi_DispMessage.mn_Length");
  lua_rawseti(L, -2, 13);
  lua_pushstring(L, "dbi_UserData2");
  lua_rawseti(L, -2, 14);
  lua_pushstring(L, "dbi_MatchLong");
  lua_rawseti(L, -2, 15);
  lua_pushstring(L, "dbi_CopPtr1");
  lua_rawseti(L, -2, 16);
  lua_pushstring(L, "dbi_CopPtr2");
  lua_rawseti(L, -2, 17);
  lua_pushstring(L, "dbi_CopPtr3");
  lua_rawseti(L, -2, 18);
  lua_pushstring(L, "dbi_BeamPos1");
  lua_rawseti(L, -2, 19);
  lua_pushstring(L, "dbi_BeamPos2");
  lua_rawseti(L, -2, 20);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_DBufInfo(lua_State *L) {
  if (luaL_newmetatable(L, "DBufInfo")) {
    lua_pushcfunction(L, _lua_gen_DBufInfo_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_DBufInfo_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_DBufInfo_constructor);
    lua_setglobal(L, "DBufInfo");
    _lua_gen_DBufInfo_install_keys(L);
    lua_pushstring(L, "DBufInfo");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_Border_newindex(lua_State *L)
{
  struct Border *obj = *(struct Border **)luaL_checkudata(L, 1, "Border");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "LeftEdge") == 0) {
    obj->LeftEdge = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "TopEdge") == 0) {
    obj->TopEdge = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "FrontPen") == 0) {
    obj->FrontPen = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "BackPen") == 0) {
    obj->BackPen = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DrawMode") == 0) {
    obj->DrawMode = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Count") == 0) {
    obj->Count = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "XY") == 0) {
    obj->XY = (WORD *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "NextBorder") == 0) {
    // finder 1
    //obj->NextBorder = *(struct Border **)luaL_checkudata(L, 3, "Border");
    obj->NextBorder = (struct Border *)_lua_gen_checkBorder(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_Border_constructor(lua_State *L)
{
  // Allocate pointer-to-struct Border in userdata
  struct Border **objp = lua_newuserdata(L, sizeof(struct Border *));
  *objp = malloc(sizeof(struct Border));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct Border));

  // Set metatable
  luaL_getmetatable(L, "Border");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_Border_index(lua_State *L)
{
  struct Border *obj = *(struct Border **)luaL_checkudata(L, 1, "Border");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "LeftEdge") == 0) {
    lua_pushinteger(L, obj->LeftEdge);
    return 1;
  }
  if (strcmp(key, "TopEdge") == 0) {
    lua_pushinteger(L, obj->TopEdge);
    return 1;
  }
  if (strcmp(key, "FrontPen") == 0) {
    lua_pushinteger(L, obj->FrontPen);
    return 1;
  }
  if (strcmp(key, "BackPen") == 0) {
    lua_pushinteger(L, obj->BackPen);
    return 1;
  }
  if (strcmp(key, "DrawMode") == 0) {
    lua_pushinteger(L, obj->DrawMode);
    return 1;
  }
  if (strcmp(key, "Count") == 0) {
    lua_pushinteger(L, obj->Count);
    return 1;
  }
  if (strcmp(key, "XY") == 0) {
    lua_pushlightuserdata(L, obj->XY);
    return 1;
  }
  if (strcmp(key, "NextBorder") == 0) {
    struct Border **ud = (struct Border **)lua_newuserdata(L, sizeof(struct Border *));
    *ud = (struct Border*)obj->NextBorder;
    luaL_getmetatable(L, "Border");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct Border));
    return 1;
}

  return 0;
}

static void
_lua_gen_Border_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "LeftEdge");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "TopEdge");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "FrontPen");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "BackPen");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "DrawMode");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "Count");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "XY");
  lua_rawseti(L, -2, 7);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_Border(lua_State *L) {
  if (luaL_newmetatable(L, "Border")) {
    lua_pushcfunction(L, _lua_gen_Border_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_Border_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_Border_constructor);
    lua_setglobal(L, "Border");
    _lua_gen_Border_install_keys(L);
    lua_pushstring(L, "Border");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_ClipRect_newindex(lua_State *L)
{
  struct ClipRect *obj = *(struct ClipRect **)luaL_checkudata(L, 1, "ClipRect");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "Next") == 0) {
    // finder 1
    //obj->Next = *(struct ClipRect **)luaL_checkudata(L, 3, "ClipRect");
    obj->Next = (struct ClipRect *)_lua_gen_checkClipRect(L, 3);
    return 0;
  }
  if (strcmp(key, "reservedlink") == 0) {
    // finder 1
    //obj->reservedlink = *(struct ClipRect **)luaL_checkudata(L, 3, "ClipRect");
    obj->reservedlink = (struct ClipRect *)_lua_gen_checkClipRect(L, 3);
    return 0;
  }
  if (strcmp(key, "obscured") == 0) {
    obj->obscured = (LONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "BitMap") == 0) {
    // finder 1
    //obj->BitMap = *(struct BitMap **)luaL_checkudata(L, 3, "BitMap");
    obj->BitMap = (struct BitMap *)_lua_gen_checkBitMap(L, 3);
    return 0;
  }
  if (strcmp(key, "bounds.MinX") == 0) {
    obj->bounds.MinX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bounds.MinY") == 0) {
    obj->bounds.MinY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bounds.MaxX") == 0) {
    obj->bounds.MaxX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bounds.MaxY") == 0) {
    obj->bounds.MaxY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type bounds struct Rectangle
  if (strcmp(key, "bounds") == 0) {
    return luaL_error(L, "Unsupported type struct Rectangle for field bounds");
  }
  if (strcmp(key, "vlink") == 0) {
    // finder 1
    //obj->vlink = *(struct ClipRect **)luaL_checkudata(L, 3, "ClipRect");
    obj->vlink = (struct ClipRect *)_lua_gen_checkClipRect(L, 3);
    return 0;
  }
  if (strcmp(key, "home") == 0) {
    // finder 1
    //obj->home = *(struct Layer_Info **)luaL_checkudata(L, 3, "Layer_Info");
    obj->home = (struct Layer_Info *)_lua_gen_checkLayer_Info(L, 3);
    return 0;
  }
  if (strcmp(key, "reserved") == 0) {
    obj->reserved = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_ClipRect_constructor(lua_State *L)
{
  // Allocate pointer-to-struct ClipRect in userdata
  struct ClipRect **objp = lua_newuserdata(L, sizeof(struct ClipRect *));
  *objp = malloc(sizeof(struct ClipRect));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct ClipRect));

  // Set metatable
  luaL_getmetatable(L, "ClipRect");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_ClipRect_index(lua_State *L)
{
  struct ClipRect *obj = *(struct ClipRect **)luaL_checkudata(L, 1, "ClipRect");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "Next") == 0) {
    struct ClipRect **ud = (struct ClipRect **)lua_newuserdata(L, sizeof(struct ClipRect *));
    *ud = (struct ClipRect*)obj->Next;
    luaL_getmetatable(L, "ClipRect");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "reservedlink") == 0) {
    struct ClipRect **ud = (struct ClipRect **)lua_newuserdata(L, sizeof(struct ClipRect *));
    *ud = (struct ClipRect*)obj->reservedlink;
    luaL_getmetatable(L, "ClipRect");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "obscured") == 0) {
    lua_pushinteger(L, obj->obscured);
    return 1;
  }
  if (strcmp(key, "BitMap") == 0) {
    struct BitMap **ud = (struct BitMap **)lua_newuserdata(L, sizeof(struct BitMap *));
    *ud = (struct BitMap*)obj->BitMap;
    luaL_getmetatable(L, "BitMap");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "bounds.MinX") == 0) {
    lua_pushinteger(L, obj->bounds.MinX);
    return 1;
  }
  if (strcmp(key, "bounds.MinY") == 0) {
    lua_pushinteger(L, obj->bounds.MinY);
    return 1;
  }
  if (strcmp(key, "bounds.MaxX") == 0) {
    lua_pushinteger(L, obj->bounds.MaxX);
    return 1;
  }
  if (strcmp(key, "bounds.MaxY") == 0) {
    lua_pushinteger(L, obj->bounds.MaxY);
    return 1;
  }
  // Unsupported bounds struct Rectangle
  if (strcmp(key, "bounds") == 0) {
    return luaL_error(L, "Unsupported type struct Rectangle for field bounds");
  }
  if (strcmp(key, "vlink") == 0) {
    struct ClipRect **ud = (struct ClipRect **)lua_newuserdata(L, sizeof(struct ClipRect *));
    *ud = (struct ClipRect*)obj->vlink;
    luaL_getmetatable(L, "ClipRect");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "home") == 0) {
    struct Layer_Info **ud = (struct Layer_Info **)lua_newuserdata(L, sizeof(struct Layer_Info *));
    *ud = (struct Layer_Info*)obj->home;
    luaL_getmetatable(L, "Layer_Info");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "reserved") == 0) {
    lua_pushlightuserdata(L, obj->reserved);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct ClipRect));
    return 1;
}

  return 0;
}

static void
_lua_gen_ClipRect_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "obscured");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "bounds.MinX");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "bounds.MinY");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "bounds.MaxX");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "bounds.MaxY");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "reserved");
  lua_rawseti(L, -2, 6);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_ClipRect(lua_State *L) {
  if (luaL_newmetatable(L, "ClipRect")) {
    lua_pushcfunction(L, _lua_gen_ClipRect_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_ClipRect_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_ClipRect_constructor);
    lua_setglobal(L, "ClipRect");
    _lua_gen_ClipRect_install_keys(L);
    lua_pushstring(L, "ClipRect");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_DrawInfo_newindex(lua_State *L)
{
  struct DrawInfo *obj = *(struct DrawInfo **)luaL_checkudata(L, 1, "DrawInfo");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "dri_Version") == 0) {
    obj->dri_Version = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "dri_NumPens") == 0) {
    obj->dri_NumPens = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "dri_Pens") == 0) {
    obj->dri_Pens = (UWORD *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "dri_Font") == 0) {
    // finder 1
    //obj->dri_Font = *(struct TextFont **)luaL_checkudata(L, 3, "TextFont");
    obj->dri_Font = (struct TextFont *)_lua_gen_checkTextFont(L, 3);
    return 0;
  }
  if (strcmp(key, "dri_Depth") == 0) {
    obj->dri_Depth = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "dri_Resolution.X") == 0) {
    obj->dri_Resolution.X = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "dri_Resolution.Y") == 0) {
    obj->dri_Resolution.Y = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type dri_Resolution unnamed struct
  if (strcmp(key, "dri_Resolution") == 0) {
    return luaL_error(L, "Unsupported type unnamed struct for field dri_Resolution");
  }
  if (strcmp(key, "dri_Flags") == 0) {
    obj->dri_Flags = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "dri_CheckMark") == 0) {
    // finder 1
    //obj->dri_CheckMark = *(struct Image **)luaL_checkudata(L, 3, "Image");
    obj->dri_CheckMark = (struct Image *)_lua_gen_checkImage(L, 3);
    return 0;
  }
  if (strcmp(key, "dri_AmigaKey") == 0) {
    // finder 1
    //obj->dri_AmigaKey = *(struct Image **)luaL_checkudata(L, 3, "Image");
    obj->dri_AmigaKey = (struct Image *)_lua_gen_checkImage(L, 3);
    return 0;
  }
  if (strcmp(key, "dri_Screen") == 0) {
    // finder 1
    //obj->dri_Screen = *(struct Screen **)luaL_checkudata(L, 3, "Screen");
    obj->dri_Screen = (struct Screen *)_lua_gen_checkScreen(L, 3);
    return 0;
  }
  // dri_Reserved[4] proxied via the index
  return 0;
}


static int
_lua_DrawInfo_constructor(lua_State *L)
{
  // Allocate pointer-to-struct DrawInfo in userdata
  struct DrawInfo **objp = lua_newuserdata(L, sizeof(struct DrawInfo *));
  *objp = malloc(sizeof(struct DrawInfo));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct DrawInfo));

  // Set metatable
  luaL_getmetatable(L, "DrawInfo");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_DrawInfo_index(lua_State *L)
{
  struct DrawInfo *obj = *(struct DrawInfo **)luaL_checkudata(L, 1, "DrawInfo");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "dri_Version") == 0) {
    lua_pushinteger(L, obj->dri_Version);
    return 1;
  }
  if (strcmp(key, "dri_NumPens") == 0) {
    lua_pushinteger(L, obj->dri_NumPens);
    return 1;
  }
  if (strcmp(key, "dri_Pens") == 0) {
    lua_pushlightuserdata(L, obj->dri_Pens);
    return 1;
  }
  if (strcmp(key, "dri_Font") == 0) {
    struct TextFont **ud = (struct TextFont **)lua_newuserdata(L, sizeof(struct TextFont *));
    *ud = (struct TextFont*)obj->dri_Font;
    luaL_getmetatable(L, "TextFont");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "dri_Depth") == 0) {
    lua_pushinteger(L, obj->dri_Depth);
    return 1;
  }
  if (strcmp(key, "dri_Resolution.X") == 0) {
    lua_pushinteger(L, obj->dri_Resolution.X);
    return 1;
  }
  if (strcmp(key, "dri_Resolution.Y") == 0) {
    lua_pushinteger(L, obj->dri_Resolution.Y);
    return 1;
  }
  // Unsupported dri_Resolution unnamed struct
  if (strcmp(key, "dri_Resolution") == 0) {
    return luaL_error(L, "Unsupported type unnamed struct for field dri_Resolution");
  }
  if (strcmp(key, "dri_Flags") == 0) {
    lua_pushinteger(L, obj->dri_Flags);
    return 1;
  }
  if (strcmp(key, "dri_CheckMark") == 0) {
    struct Image **ud = (struct Image **)lua_newuserdata(L, sizeof(struct Image *));
    *ud = (struct Image*)obj->dri_CheckMark;
    luaL_getmetatable(L, "Image");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "dri_AmigaKey") == 0) {
    struct Image **ud = (struct Image **)lua_newuserdata(L, sizeof(struct Image *));
    *ud = (struct Image*)obj->dri_AmigaKey;
    luaL_getmetatable(L, "Image");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "dri_Screen") == 0) {
    struct Screen **ud = (struct Screen **)lua_newuserdata(L, sizeof(struct Screen *));
    *ud = (struct Screen*)obj->dri_Screen;
    luaL_getmetatable(L, "Screen");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "dri_Reserved") == 0) {
    _lua_gen_push_ULONG_array_proxy(L, obj->dri_Reserved, 4);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct DrawInfo));
    return 1;
}

  return 0;
}

static void
_lua_gen_DrawInfo_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "dri_Version");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "dri_NumPens");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "dri_Pens");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "dri_Depth");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "dri_Resolution.X");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "dri_Resolution.Y");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "dri_Flags");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "dri_Reserved");
  lua_rawseti(L, -2, 8);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_DrawInfo(lua_State *L) {
  if (luaL_newmetatable(L, "DrawInfo")) {
    lua_pushcfunction(L, _lua_gen_DrawInfo_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_DrawInfo_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_DrawInfo_constructor);
    lua_setglobal(L, "DrawInfo");
    _lua_gen_DrawInfo_install_keys(L);
    lua_pushstring(L, "DrawInfo");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_Gadget_newindex(lua_State *L)
{
  struct Gadget *obj = *(struct Gadget **)luaL_checkudata(L, 1, "Gadget");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "NextGadget") == 0) {
    // finder 1
    //obj->NextGadget = *(struct Gadget **)luaL_checkudata(L, 3, "Gadget");
    obj->NextGadget = (struct Gadget *)_lua_gen_checkGadget(L, 3);
    return 0;
  }
  if (strcmp(key, "LeftEdge") == 0) {
    obj->LeftEdge = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "TopEdge") == 0) {
    obj->TopEdge = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Width") == 0) {
    obj->Width = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Height") == 0) {
    obj->Height = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Flags") == 0) {
    obj->Flags = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Activation") == 0) {
    obj->Activation = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "GadgetType") == 0) {
    obj->GadgetType = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "GadgetRender") == 0) {
    obj->GadgetRender = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "SelectRender") == 0) {
    obj->SelectRender = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "GadgetText") == 0) {
    // finder 1
    //obj->GadgetText = *(struct IntuiText **)luaL_checkudata(L, 3, "IntuiText");
    obj->GadgetText = (struct IntuiText *)_lua_gen_checkIntuiText(L, 3);
    return 0;
  }
  if (strcmp(key, "MutualExclude") == 0) {
    obj->MutualExclude = (LONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "SpecialInfo") == 0) {
    obj->SpecialInfo = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "GadgetID") == 0) {
    obj->GadgetID = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "UserData") == 0) {
    obj->UserData = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_Gadget_constructor(lua_State *L)
{
  // Allocate pointer-to-struct Gadget in userdata
  struct Gadget **objp = lua_newuserdata(L, sizeof(struct Gadget *));
  *objp = malloc(sizeof(struct Gadget));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct Gadget));

  // Set metatable
  luaL_getmetatable(L, "Gadget");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_Gadget_index(lua_State *L)
{
  struct Gadget *obj = *(struct Gadget **)luaL_checkudata(L, 1, "Gadget");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "NextGadget") == 0) {
    struct Gadget **ud = (struct Gadget **)lua_newuserdata(L, sizeof(struct Gadget *));
    *ud = (struct Gadget*)obj->NextGadget;
    luaL_getmetatable(L, "Gadget");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "LeftEdge") == 0) {
    lua_pushinteger(L, obj->LeftEdge);
    return 1;
  }
  if (strcmp(key, "TopEdge") == 0) {
    lua_pushinteger(L, obj->TopEdge);
    return 1;
  }
  if (strcmp(key, "Width") == 0) {
    lua_pushinteger(L, obj->Width);
    return 1;
  }
  if (strcmp(key, "Height") == 0) {
    lua_pushinteger(L, obj->Height);
    return 1;
  }
  if (strcmp(key, "Flags") == 0) {
    lua_pushinteger(L, obj->Flags);
    return 1;
  }
  if (strcmp(key, "Activation") == 0) {
    lua_pushinteger(L, obj->Activation);
    return 1;
  }
  if (strcmp(key, "GadgetType") == 0) {
    lua_pushinteger(L, obj->GadgetType);
    return 1;
  }
  if (strcmp(key, "GadgetRender") == 0) {
    lua_pushlightuserdata(L, obj->GadgetRender);
    return 1;
  }
  if (strcmp(key, "SelectRender") == 0) {
    lua_pushlightuserdata(L, obj->SelectRender);
    return 1;
  }
  if (strcmp(key, "GadgetText") == 0) {
    struct IntuiText **ud = (struct IntuiText **)lua_newuserdata(L, sizeof(struct IntuiText *));
    *ud = (struct IntuiText*)obj->GadgetText;
    luaL_getmetatable(L, "IntuiText");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "MutualExclude") == 0) {
    lua_pushinteger(L, obj->MutualExclude);
    return 1;
  }
  if (strcmp(key, "SpecialInfo") == 0) {
    lua_pushlightuserdata(L, obj->SpecialInfo);
    return 1;
  }
  if (strcmp(key, "GadgetID") == 0) {
    lua_pushinteger(L, obj->GadgetID);
    return 1;
  }
  if (strcmp(key, "UserData") == 0) {
    lua_pushlightuserdata(L, obj->UserData);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct Gadget));
    return 1;
}

  return 0;
}

static void
_lua_gen_Gadget_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "LeftEdge");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "TopEdge");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "Width");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "Height");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "Flags");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "Activation");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "GadgetType");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "GadgetRender");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "SelectRender");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "MutualExclude");
  lua_rawseti(L, -2, 10);
  lua_pushstring(L, "SpecialInfo");
  lua_rawseti(L, -2, 11);
  lua_pushstring(L, "GadgetID");
  lua_rawseti(L, -2, 12);
  lua_pushstring(L, "UserData");
  lua_rawseti(L, -2, 13);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_Gadget(lua_State *L) {
  if (luaL_newmetatable(L, "Gadget")) {
    lua_pushcfunction(L, _lua_gen_Gadget_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_Gadget_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_Gadget_constructor);
    lua_setglobal(L, "Gadget");
    _lua_gen_Gadget_install_keys(L);
    lua_pushstring(L, "Gadget");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_Image_newindex(lua_State *L)
{
  struct Image *obj = *(struct Image **)luaL_checkudata(L, 1, "Image");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "LeftEdge") == 0) {
    obj->LeftEdge = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "TopEdge") == 0) {
    obj->TopEdge = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Width") == 0) {
    obj->Width = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Height") == 0) {
    obj->Height = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Depth") == 0) {
    obj->Depth = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ImageData") == 0) {
    obj->ImageData = (UWORD *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "PlanePick") == 0) {
    obj->PlanePick = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "PlaneOnOff") == 0) {
    obj->PlaneOnOff = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "NextImage") == 0) {
    // finder 1
    //obj->NextImage = *(struct Image **)luaL_checkudata(L, 3, "Image");
    obj->NextImage = (struct Image *)_lua_gen_checkImage(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_Image_constructor(lua_State *L)
{
  // Allocate pointer-to-struct Image in userdata
  struct Image **objp = lua_newuserdata(L, sizeof(struct Image *));
  *objp = malloc(sizeof(struct Image));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct Image));

  // Set metatable
  luaL_getmetatable(L, "Image");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_Image_index(lua_State *L)
{
  struct Image *obj = *(struct Image **)luaL_checkudata(L, 1, "Image");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "LeftEdge") == 0) {
    lua_pushinteger(L, obj->LeftEdge);
    return 1;
  }
  if (strcmp(key, "TopEdge") == 0) {
    lua_pushinteger(L, obj->TopEdge);
    return 1;
  }
  if (strcmp(key, "Width") == 0) {
    lua_pushinteger(L, obj->Width);
    return 1;
  }
  if (strcmp(key, "Height") == 0) {
    lua_pushinteger(L, obj->Height);
    return 1;
  }
  if (strcmp(key, "Depth") == 0) {
    lua_pushinteger(L, obj->Depth);
    return 1;
  }
  if (strcmp(key, "ImageData") == 0) {
    lua_pushlightuserdata(L, obj->ImageData);
    return 1;
  }
  if (strcmp(key, "PlanePick") == 0) {
    lua_pushinteger(L, obj->PlanePick);
    return 1;
  }
  if (strcmp(key, "PlaneOnOff") == 0) {
    lua_pushinteger(L, obj->PlaneOnOff);
    return 1;
  }
  if (strcmp(key, "NextImage") == 0) {
    struct Image **ud = (struct Image **)lua_newuserdata(L, sizeof(struct Image *));
    *ud = (struct Image*)obj->NextImage;
    luaL_getmetatable(L, "Image");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct Image));
    return 1;
}

  return 0;
}

static void
_lua_gen_Image_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "LeftEdge");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "TopEdge");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "Width");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "Height");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "Depth");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "ImageData");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "PlanePick");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "PlaneOnOff");
  lua_rawseti(L, -2, 8);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_Image(lua_State *L) {
  if (luaL_newmetatable(L, "Image")) {
    lua_pushcfunction(L, _lua_gen_Image_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_Image_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_Image_constructor);
    lua_setglobal(L, "Image");
    _lua_gen_Image_install_keys(L);
    lua_pushstring(L, "Image");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_IntuiText_newindex(lua_State *L)
{
  struct IntuiText *obj = *(struct IntuiText **)luaL_checkudata(L, 1, "IntuiText");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "FrontPen") == 0) {
    obj->FrontPen = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "BackPen") == 0) {
    obj->BackPen = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DrawMode") == 0) {
    obj->DrawMode = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "LeftEdge") == 0) {
    obj->LeftEdge = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "TopEdge") == 0) {
    obj->TopEdge = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ITextFont") == 0) {
    // finder 1
    //obj->ITextFont = *(struct TextAttr **)luaL_checkudata(L, 3, "TextAttr");
    obj->ITextFont = (struct TextAttr *)_lua_gen_checkTextAttr(L, 3);
    return 0;
  }
  if (strcmp(key, "IText") == 0) {
    obj->IText = (STRPTR)amiga_checkNullableString(L, 3);
    return 0;
  }
  if (strcmp(key, "NextText") == 0) {
    // finder 1
    //obj->NextText = *(struct IntuiText **)luaL_checkudata(L, 3, "IntuiText");
    obj->NextText = (struct IntuiText *)_lua_gen_checkIntuiText(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_IntuiText_constructor(lua_State *L)
{
  // Allocate pointer-to-struct IntuiText in userdata
  struct IntuiText **objp = lua_newuserdata(L, sizeof(struct IntuiText *));
  *objp = malloc(sizeof(struct IntuiText));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct IntuiText));

  // Set metatable
  luaL_getmetatable(L, "IntuiText");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_IntuiText_index(lua_State *L)
{
  struct IntuiText *obj = *(struct IntuiText **)luaL_checkudata(L, 1, "IntuiText");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "FrontPen") == 0) {
    lua_pushinteger(L, obj->FrontPen);
    return 1;
  }
  if (strcmp(key, "BackPen") == 0) {
    lua_pushinteger(L, obj->BackPen);
    return 1;
  }
  if (strcmp(key, "DrawMode") == 0) {
    lua_pushinteger(L, obj->DrawMode);
    return 1;
  }
  if (strcmp(key, "LeftEdge") == 0) {
    lua_pushinteger(L, obj->LeftEdge);
    return 1;
  }
  if (strcmp(key, "TopEdge") == 0) {
    lua_pushinteger(L, obj->TopEdge);
    return 1;
  }
  if (strcmp(key, "ITextFont") == 0) {
    struct TextAttr **ud = (struct TextAttr **)lua_newuserdata(L, sizeof(struct TextAttr *));
    *ud = (struct TextAttr*)obj->ITextFont;
    luaL_getmetatable(L, "TextAttr");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "IText") == 0) {
    lua_pushstring(L, obj->IText);
    return 1;
  }
  if (strcmp(key, "NextText") == 0) {
    struct IntuiText **ud = (struct IntuiText **)lua_newuserdata(L, sizeof(struct IntuiText *));
    *ud = (struct IntuiText*)obj->NextText;
    luaL_getmetatable(L, "IntuiText");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct IntuiText));
    return 1;
}

  return 0;
}

static void
_lua_gen_IntuiText_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "FrontPen");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "BackPen");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "DrawMode");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "LeftEdge");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "TopEdge");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "IText");
  lua_rawseti(L, -2, 6);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_IntuiText(lua_State *L) {
  if (luaL_newmetatable(L, "IntuiText")) {
    lua_pushcfunction(L, _lua_gen_IntuiText_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_IntuiText_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_IntuiText_constructor);
    lua_setglobal(L, "IntuiText");
    _lua_gen_IntuiText_install_keys(L);
    lua_pushstring(L, "IntuiText");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_KeyMap_newindex(lua_State *L)
{
  struct KeyMap *obj = *(struct KeyMap **)luaL_checkudata(L, 1, "KeyMap");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "km_LoKeyMapTypes") == 0) {
    obj->km_LoKeyMapTypes = (UBYTE *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "km_LoKeyMap") == 0) {
    obj->km_LoKeyMap = (ULONG *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "km_LoCapsable") == 0) {
    obj->km_LoCapsable = (UBYTE *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "km_LoRepeatable") == 0) {
    obj->km_LoRepeatable = (UBYTE *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "km_HiKeyMapTypes") == 0) {
    obj->km_HiKeyMapTypes = (UBYTE *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "km_HiKeyMap") == 0) {
    obj->km_HiKeyMap = (ULONG *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "km_HiCapsable") == 0) {
    obj->km_HiCapsable = (UBYTE *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "km_HiRepeatable") == 0) {
    obj->km_HiRepeatable = (UBYTE *)lua_touserdata(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_KeyMap_constructor(lua_State *L)
{
  // Allocate pointer-to-struct KeyMap in userdata
  struct KeyMap **objp = lua_newuserdata(L, sizeof(struct KeyMap *));
  *objp = malloc(sizeof(struct KeyMap));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct KeyMap));

  // Set metatable
  luaL_getmetatable(L, "KeyMap");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_KeyMap_index(lua_State *L)
{
  struct KeyMap *obj = *(struct KeyMap **)luaL_checkudata(L, 1, "KeyMap");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "km_LoKeyMapTypes") == 0) {
    lua_pushlightuserdata(L, obj->km_LoKeyMapTypes);
    return 1;
  }
  if (strcmp(key, "km_LoKeyMap") == 0) {
    lua_pushlightuserdata(L, obj->km_LoKeyMap);
    return 1;
  }
  if (strcmp(key, "km_LoCapsable") == 0) {
    lua_pushlightuserdata(L, obj->km_LoCapsable);
    return 1;
  }
  if (strcmp(key, "km_LoRepeatable") == 0) {
    lua_pushlightuserdata(L, obj->km_LoRepeatable);
    return 1;
  }
  if (strcmp(key, "km_HiKeyMapTypes") == 0) {
    lua_pushlightuserdata(L, obj->km_HiKeyMapTypes);
    return 1;
  }
  if (strcmp(key, "km_HiKeyMap") == 0) {
    lua_pushlightuserdata(L, obj->km_HiKeyMap);
    return 1;
  }
  if (strcmp(key, "km_HiCapsable") == 0) {
    lua_pushlightuserdata(L, obj->km_HiCapsable);
    return 1;
  }
  if (strcmp(key, "km_HiRepeatable") == 0) {
    lua_pushlightuserdata(L, obj->km_HiRepeatable);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct KeyMap));
    return 1;
}

  return 0;
}

static void
_lua_gen_KeyMap_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "km_LoKeyMapTypes");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "km_LoKeyMap");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "km_LoCapsable");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "km_LoRepeatable");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "km_HiKeyMapTypes");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "km_HiKeyMap");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "km_HiCapsable");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "km_HiRepeatable");
  lua_rawseti(L, -2, 8);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_KeyMap(lua_State *L) {
  if (luaL_newmetatable(L, "KeyMap")) {
    lua_pushcfunction(L, _lua_gen_KeyMap_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_KeyMap_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_KeyMap_constructor);
    lua_setglobal(L, "KeyMap");
    _lua_gen_KeyMap_install_keys(L);
    lua_pushstring(L, "KeyMap");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

typedef struct {
  UBYTE* data;
  uint16_t count;
} lua_gen_wrapped_UBYTE_array_data_t;

static int _lua_gen_wrapped_UBYTE_array_ptr_method(lua_State* L) {
    lua_gen_wrapped_UBYTE_array_data_t* wrapper = luaL_checkudata(L, 1, "UBYTE_array_proxy");
    int index = luaL_checkinteger(L, 2);
    void* ptr = &wrapper->data[index - 1];
    lua_pushlightuserdata(L, ptr);
    return 1;
}
static int
_lua_gen_wrapped_UBYTE_array_index(lua_State* L)
{
  lua_gen_wrapped_UBYTE_array_data_t* wrapper = luaL_checkudata(L, 1, "UBYTE_array_proxy");
  if (lua_isinteger(L, 2)) {
    int index = lua_tointeger(L, 2);
    if (index < 1 || index > wrapper->count)
      return luaL_error(L, "index out of range (1..%d)", wrapper->count);
    lua_pushinteger(L, wrapper->data[index - 1]);
    return 1;
  }

  // Not a numeric key? Try methods
  lua_getmetatable(L, 1);
  lua_getfield(L, -1, "__methods");
  lua_pushvalue(L, 2);
  lua_gettable(L, -2);
  return 1;
}

static int
_lua_gen_wrapped_UBYTE_array_newindex(lua_State* L)
{
  lua_gen_wrapped_UBYTE_array_data_t* wrapper = luaL_checkudata(L, 1, "UBYTE_array_proxy");
  if (!lua_isinteger(L, 2))
    return luaL_error(L, "only integer indices allowed");
  int index = lua_tointeger(L, 2);
  if (index < 1 || index > wrapper->count)
    return luaL_error(L, "index out of range (1..%d)", wrapper->count);
  UBYTE value = luaL_checkinteger(L,  3);
  wrapper->data[index - 1] = value;
  return 0;
}

static void
_lua_gen_push_UBYTE_array_proxy(lua_State *L,  UBYTE *array, int count)
{

  lua_gen_wrapped_UBYTE_array_data_t* wrapper = lua_newuserdata(L, sizeof(lua_gen_wrapped_UBYTE_array_data_t));
  wrapper->data = array;
  wrapper->count = count;

  if (luaL_newmetatable(L, "UBYTE_array_proxy")) {
    // Create method table
    lua_newtable(L);
    lua_pushcfunction(L, _lua_gen_wrapped_UBYTE_array_ptr_method);
    lua_setfield(L, -2, "ptr");
    lua_setfield(L, -2, "__methods");

    // __index handles both numeric and method lookup
    lua_pushcfunction(L, _lua_gen_wrapped_UBYTE_array_index);
    lua_setfield(L, -2, "__index");

    // __newindex for writing
    lua_pushcfunction(L, _lua_gen_wrapped_UBYTE_array_newindex);
    lua_setfield(L, -2, "__newindex");
  }

  lua_setmetatable(L, -2);  // assign to userdata

}
static int
_lua_gen_Layer_newindex(lua_State *L)
{
  struct Layer *obj = *(struct Layer **)luaL_checkudata(L, 1, "Layer");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "front") == 0) {
    // finder 1
    //obj->front = *(struct Layer **)luaL_checkudata(L, 3, "Layer");
    obj->front = (struct Layer *)_lua_gen_checkLayer(L, 3);
    return 0;
  }
  if (strcmp(key, "back") == 0) {
    // finder 1
    //obj->back = *(struct Layer **)luaL_checkudata(L, 3, "Layer");
    obj->back = (struct Layer *)_lua_gen_checkLayer(L, 3);
    return 0;
  }
  if (strcmp(key, "ClipRect") == 0) {
    // finder 1
    //obj->ClipRect = *(struct ClipRect **)luaL_checkudata(L, 3, "ClipRect");
    obj->ClipRect = (struct ClipRect *)_lua_gen_checkClipRect(L, 3);
    return 0;
  }
  if (strcmp(key, "rp") == 0) {
    // finder 1
    //obj->rp = *(struct RastPort **)luaL_checkudata(L, 3, "RastPort");
    obj->rp = (struct RastPort *)_lua_gen_checkRastPort(L, 3);
    return 0;
  }
  if (strcmp(key, "bounds.MinX") == 0) {
    obj->bounds.MinX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bounds.MinY") == 0) {
    obj->bounds.MinY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bounds.MaxX") == 0) {
    obj->bounds.MaxX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bounds.MaxY") == 0) {
    obj->bounds.MaxY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type bounds struct Rectangle
  if (strcmp(key, "bounds") == 0) {
    return luaL_error(L, "Unsupported type struct Rectangle for field bounds");
  }
  if (strcmp(key, "nlink") == 0) {
    // finder 1
    //obj->nlink = *(struct Layer **)luaL_checkudata(L, 3, "Layer");
    obj->nlink = (struct Layer *)_lua_gen_checkLayer(L, 3);
    return 0;
  }
  if (strcmp(key, "priority") == 0) {
    obj->priority = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Flags") == 0) {
    obj->Flags = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "SuperBitMap") == 0) {
    // finder 1
    //obj->SuperBitMap = *(struct BitMap **)luaL_checkudata(L, 3, "BitMap");
    obj->SuperBitMap = (struct BitMap *)_lua_gen_checkBitMap(L, 3);
    return 0;
  }
  if (strcmp(key, "SuperClipRect") == 0) {
    // finder 1
    //obj->SuperClipRect = *(struct ClipRect **)luaL_checkudata(L, 3, "ClipRect");
    obj->SuperClipRect = (struct ClipRect *)_lua_gen_checkClipRect(L, 3);
    return 0;
  }
  if (strcmp(key, "Window") == 0) {
    obj->Window = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "Scroll_X") == 0) {
    obj->Scroll_X = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Scroll_Y") == 0) {
    obj->Scroll_Y = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "OnScreen") == 0) {
    // finder 1
    //obj->OnScreen = *(struct ClipRect **)luaL_checkudata(L, 3, "ClipRect");
    obj->OnScreen = (struct ClipRect *)_lua_gen_checkClipRect(L, 3);
    return 0;
  }
  if (strcmp(key, "OffScreen") == 0) {
    // finder 1
    //obj->OffScreen = *(struct ClipRect **)luaL_checkudata(L, 3, "ClipRect");
    obj->OffScreen = (struct ClipRect *)_lua_gen_checkClipRect(L, 3);
    return 0;
  }
  if (strcmp(key, "Backup") == 0) {
    // finder 1
    //obj->Backup = *(struct ClipRect **)luaL_checkudata(L, 3, "ClipRect");
    obj->Backup = (struct ClipRect *)_lua_gen_checkClipRect(L, 3);
    return 0;
  }
  if (strcmp(key, "SuperSaveClipRects") == 0) {
    // finder 1
    //obj->SuperSaveClipRects = *(struct ClipRect **)luaL_checkudata(L, 3, "ClipRect");
    obj->SuperSaveClipRects = (struct ClipRect *)_lua_gen_checkClipRect(L, 3);
    return 0;
  }
  if (strcmp(key, "Undamaged") == 0) {
    // finder 1
    //obj->Undamaged = *(struct ClipRect **)luaL_checkudata(L, 3, "ClipRect");
    obj->Undamaged = (struct ClipRect *)_lua_gen_checkClipRect(L, 3);
    return 0;
  }
  if (strcmp(key, "LayerInfo") == 0) {
    // finder 1
    //obj->LayerInfo = *(struct Layer_Info **)luaL_checkudata(L, 3, "Layer_Info");
    obj->LayerInfo = (struct Layer_Info *)_lua_gen_checkLayer_Info(L, 3);
    return 0;
  }
  // Unsupported type Lock.ss_Link.ln_Succ struct Node
  if (strcmp(key, "Lock.ss_Link.ln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field Lock.ss_Link.ln_Succ");
  }
  // Unsupported type Lock.ss_Link.ln_Pred struct Node
  if (strcmp(key, "Lock.ss_Link.ln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field Lock.ss_Link.ln_Pred");
  }
  if (strcmp(key, "Lock.ss_Link.ln_Type") == 0) {
    obj->Lock.ss_Link.ln_Type = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Lock.ss_Link.ln_Pri") == 0) {
    obj->Lock.ss_Link.ln_Pri = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Lock.ss_Link.ln_Name") == 0) {
    obj->Lock.ss_Link.ln_Name = (char *)luaL_checkstring(L, 3);
    return 0;
  }
  // Unsupported type Lock.ss_Link struct Node
  if (strcmp(key, "Lock.ss_Link") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field Lock.ss_Link");
  }
  if (strcmp(key, "Lock.ss_NestCount") == 0) {
    obj->Lock.ss_NestCount = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Lock.ss_WaitQueue.mlh_Head") == 0) {
    // finder 1
    //obj->Lock.ss_WaitQueue.mlh_Head = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->Lock.ss_WaitQueue.mlh_Head = (struct MinNode *)_lua_gen_checkMinNode(L, 3);
    return 0;
  }
  if (strcmp(key, "Lock.ss_WaitQueue.mlh_Tail") == 0) {
    // finder 1
    //obj->Lock.ss_WaitQueue.mlh_Tail = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->Lock.ss_WaitQueue.mlh_Tail = (struct MinNode *)_lua_gen_checkMinNode(L, 3);
    return 0;
  }
  if (strcmp(key, "Lock.ss_WaitQueue.mlh_TailPred") == 0) {
    // finder 1
    //obj->Lock.ss_WaitQueue.mlh_TailPred = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->Lock.ss_WaitQueue.mlh_TailPred = (struct MinNode *)_lua_gen_checkMinNode(L, 3);
    return 0;
  }
  // Unsupported type Lock.ss_WaitQueue struct MinList
  if (strcmp(key, "Lock.ss_WaitQueue") == 0) {
    return luaL_error(L, "Unsupported type struct MinList for field Lock.ss_WaitQueue");
  }
  if (strcmp(key, "Lock.ss_MultipleLink.sr_Link.mln_Succ") == 0) {
    // finder 1
    //obj->Lock.ss_MultipleLink.sr_Link.mln_Succ = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->Lock.ss_MultipleLink.sr_Link.mln_Succ = (struct MinNode *)_lua_gen_checkMinNode(L, 3);
    return 0;
  }
  if (strcmp(key, "Lock.ss_MultipleLink.sr_Link.mln_Pred") == 0) {
    // finder 1
    //obj->Lock.ss_MultipleLink.sr_Link.mln_Pred = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->Lock.ss_MultipleLink.sr_Link.mln_Pred = (struct MinNode *)_lua_gen_checkMinNode(L, 3);
    return 0;
  }
  if (strcmp(key, "Lock.ss_MultipleLink.sr_Link") == 0) {
    // finder 0
    struct MinNode *val = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->Lock.ss_MultipleLink.sr_Link = *val;
    return 0;
  }
  // Unsupported type Lock.ss_MultipleLink.sr_Waiter struct Task
  if (strcmp(key, "Lock.ss_MultipleLink.sr_Waiter") == 0) {
    return luaL_error(L, "Unsupported type struct Task for field Lock.ss_MultipleLink.sr_Waiter");
  }
  // Unsupported type Lock.ss_MultipleLink struct SemaphoreRequest
  if (strcmp(key, "Lock.ss_MultipleLink") == 0) {
    return luaL_error(L, "Unsupported type struct SemaphoreRequest for field Lock.ss_MultipleLink");
  }
  // Unsupported type Lock.ss_Owner struct Task
  if (strcmp(key, "Lock.ss_Owner") == 0) {
    return luaL_error(L, "Unsupported type struct Task for field Lock.ss_Owner");
  }
  if (strcmp(key, "Lock.ss_QueueCount") == 0) {
    obj->Lock.ss_QueueCount = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type Lock struct SignalSemaphore
  if (strcmp(key, "Lock") == 0) {
    return luaL_error(L, "Unsupported type struct SignalSemaphore for field Lock");
  }
  if (strcmp(key, "BackFill") == 0) {
    // finder 1
    //obj->BackFill = *(struct Hook **)luaL_checkudata(L, 3, "Hook");
    obj->BackFill = (struct Hook *)_lua_gen_checkHook(L, 3);
    return 0;
  }
  if (strcmp(key, "reserved1") == 0) {
    obj->reserved1 = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type ClipRegion struct Region
  if (strcmp(key, "ClipRegion") == 0) {
    return luaL_error(L, "Unsupported type struct Region for field ClipRegion");
  }
  if (strcmp(key, "clipped") == 0) {
    // finder 1
    //obj->clipped = *(struct ClipRect **)luaL_checkudata(L, 3, "ClipRect");
    obj->clipped = (struct ClipRect *)_lua_gen_checkClipRect(L, 3);
    return 0;
  }
  if (strcmp(key, "Width") == 0) {
    obj->Width = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Height") == 0) {
    obj->Height = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // reserved2[18] proxied via the index
  // Unsupported type DamageList struct Region
  if (strcmp(key, "DamageList") == 0) {
    return luaL_error(L, "Unsupported type struct Region for field DamageList");
  }
  return 0;
}


static int
_lua_Layer_constructor(lua_State *L)
{
  // Allocate pointer-to-struct Layer in userdata
  struct Layer **objp = lua_newuserdata(L, sizeof(struct Layer *));
  *objp = malloc(sizeof(struct Layer));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct Layer));

  // Set metatable
  luaL_getmetatable(L, "Layer");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_Layer_index(lua_State *L)
{
  struct Layer *obj = *(struct Layer **)luaL_checkudata(L, 1, "Layer");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "front") == 0) {
    struct Layer **ud = (struct Layer **)lua_newuserdata(L, sizeof(struct Layer *));
    *ud = (struct Layer*)obj->front;
    luaL_getmetatable(L, "Layer");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "back") == 0) {
    struct Layer **ud = (struct Layer **)lua_newuserdata(L, sizeof(struct Layer *));
    *ud = (struct Layer*)obj->back;
    luaL_getmetatable(L, "Layer");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "ClipRect") == 0) {
    struct ClipRect **ud = (struct ClipRect **)lua_newuserdata(L, sizeof(struct ClipRect *));
    *ud = (struct ClipRect*)obj->ClipRect;
    luaL_getmetatable(L, "ClipRect");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "rp") == 0) {
    struct RastPort **ud = (struct RastPort **)lua_newuserdata(L, sizeof(struct RastPort *));
    *ud = (struct RastPort*)obj->rp;
    luaL_getmetatable(L, "RastPort");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "bounds.MinX") == 0) {
    lua_pushinteger(L, obj->bounds.MinX);
    return 1;
  }
  if (strcmp(key, "bounds.MinY") == 0) {
    lua_pushinteger(L, obj->bounds.MinY);
    return 1;
  }
  if (strcmp(key, "bounds.MaxX") == 0) {
    lua_pushinteger(L, obj->bounds.MaxX);
    return 1;
  }
  if (strcmp(key, "bounds.MaxY") == 0) {
    lua_pushinteger(L, obj->bounds.MaxY);
    return 1;
  }
  // Unsupported bounds struct Rectangle
  if (strcmp(key, "bounds") == 0) {
    return luaL_error(L, "Unsupported type struct Rectangle for field bounds");
  }
  if (strcmp(key, "nlink") == 0) {
    struct Layer **ud = (struct Layer **)lua_newuserdata(L, sizeof(struct Layer *));
    *ud = (struct Layer*)obj->nlink;
    luaL_getmetatable(L, "Layer");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "priority") == 0) {
    lua_pushinteger(L, obj->priority);
    return 1;
  }
  if (strcmp(key, "Flags") == 0) {
    lua_pushinteger(L, obj->Flags);
    return 1;
  }
  if (strcmp(key, "SuperBitMap") == 0) {
    struct BitMap **ud = (struct BitMap **)lua_newuserdata(L, sizeof(struct BitMap *));
    *ud = (struct BitMap*)obj->SuperBitMap;
    luaL_getmetatable(L, "BitMap");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "SuperClipRect") == 0) {
    struct ClipRect **ud = (struct ClipRect **)lua_newuserdata(L, sizeof(struct ClipRect *));
    *ud = (struct ClipRect*)obj->SuperClipRect;
    luaL_getmetatable(L, "ClipRect");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "Window") == 0) {
    lua_pushlightuserdata(L, obj->Window);
    return 1;
  }
  if (strcmp(key, "Scroll_X") == 0) {
    lua_pushinteger(L, obj->Scroll_X);
    return 1;
  }
  if (strcmp(key, "Scroll_Y") == 0) {
    lua_pushinteger(L, obj->Scroll_Y);
    return 1;
  }
  if (strcmp(key, "OnScreen") == 0) {
    struct ClipRect **ud = (struct ClipRect **)lua_newuserdata(L, sizeof(struct ClipRect *));
    *ud = (struct ClipRect*)obj->OnScreen;
    luaL_getmetatable(L, "ClipRect");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "OffScreen") == 0) {
    struct ClipRect **ud = (struct ClipRect **)lua_newuserdata(L, sizeof(struct ClipRect *));
    *ud = (struct ClipRect*)obj->OffScreen;
    luaL_getmetatable(L, "ClipRect");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "Backup") == 0) {
    struct ClipRect **ud = (struct ClipRect **)lua_newuserdata(L, sizeof(struct ClipRect *));
    *ud = (struct ClipRect*)obj->Backup;
    luaL_getmetatable(L, "ClipRect");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "SuperSaveClipRects") == 0) {
    struct ClipRect **ud = (struct ClipRect **)lua_newuserdata(L, sizeof(struct ClipRect *));
    *ud = (struct ClipRect*)obj->SuperSaveClipRects;
    luaL_getmetatable(L, "ClipRect");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "Undamaged") == 0) {
    struct ClipRect **ud = (struct ClipRect **)lua_newuserdata(L, sizeof(struct ClipRect *));
    *ud = (struct ClipRect*)obj->Undamaged;
    luaL_getmetatable(L, "ClipRect");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "LayerInfo") == 0) {
    struct Layer_Info **ud = (struct Layer_Info **)lua_newuserdata(L, sizeof(struct Layer_Info *));
    *ud = (struct Layer_Info*)obj->LayerInfo;
    luaL_getmetatable(L, "Layer_Info");
    lua_setmetatable(L, -2);
    return 1;
  }
  // Unsupported Lock.ss_Link.ln_Succ struct Node *
  if (strcmp(key, "Lock.ss_Link.ln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field Lock.ss_Link.ln_Succ");
  }
  // Unsupported Lock.ss_Link.ln_Pred struct Node *
  if (strcmp(key, "Lock.ss_Link.ln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field Lock.ss_Link.ln_Pred");
  }
  if (strcmp(key, "Lock.ss_Link.ln_Type") == 0) {
    lua_pushinteger(L, obj->Lock.ss_Link.ln_Type);
    return 1;
  }
  if (strcmp(key, "Lock.ss_Link.ln_Pri") == 0) {
    lua_pushinteger(L, obj->Lock.ss_Link.ln_Pri);
    return 1;
  }
  if (strcmp(key, "Lock.ss_Link.ln_Name") == 0) {
    lua_pushstring(L, obj->Lock.ss_Link.ln_Name);
    return 1;
  }
  // Unsupported Lock.ss_Link struct Node
  if (strcmp(key, "Lock.ss_Link") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field Lock.ss_Link");
  }
  if (strcmp(key, "Lock.ss_NestCount") == 0) {
    lua_pushinteger(L, obj->Lock.ss_NestCount);
    return 1;
  }
  if (strcmp(key, "Lock.ss_WaitQueue.mlh_Head") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)obj->Lock.ss_WaitQueue.mlh_Head;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "Lock.ss_WaitQueue.mlh_Tail") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)obj->Lock.ss_WaitQueue.mlh_Tail;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "Lock.ss_WaitQueue.mlh_TailPred") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)obj->Lock.ss_WaitQueue.mlh_TailPred;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  // Unsupported Lock.ss_WaitQueue struct MinList
  if (strcmp(key, "Lock.ss_WaitQueue") == 0) {
    return luaL_error(L, "Unsupported type struct MinList for field Lock.ss_WaitQueue");
  }
  if (strcmp(key, "Lock.ss_MultipleLink.sr_Link.mln_Succ") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)obj->Lock.ss_MultipleLink.sr_Link.mln_Succ;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "Lock.ss_MultipleLink.sr_Link.mln_Pred") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)obj->Lock.ss_MultipleLink.sr_Link.mln_Pred;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "Lock.ss_MultipleLink.sr_Link") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)&obj->Lock.ss_MultipleLink.sr_Link;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  // Unsupported Lock.ss_MultipleLink.sr_Waiter struct Task *
  if (strcmp(key, "Lock.ss_MultipleLink.sr_Waiter") == 0) {
    return luaL_error(L, "Unsupported type struct Task * for field Lock.ss_MultipleLink.sr_Waiter");
  }
  // Unsupported Lock.ss_MultipleLink struct SemaphoreRequest
  if (strcmp(key, "Lock.ss_MultipleLink") == 0) {
    return luaL_error(L, "Unsupported type struct SemaphoreRequest for field Lock.ss_MultipleLink");
  }
  // Unsupported Lock.ss_Owner struct Task *
  if (strcmp(key, "Lock.ss_Owner") == 0) {
    return luaL_error(L, "Unsupported type struct Task * for field Lock.ss_Owner");
  }
  if (strcmp(key, "Lock.ss_QueueCount") == 0) {
    lua_pushinteger(L, obj->Lock.ss_QueueCount);
    return 1;
  }
  // Unsupported Lock struct SignalSemaphore
  if (strcmp(key, "Lock") == 0) {
    return luaL_error(L, "Unsupported type struct SignalSemaphore for field Lock");
  }
  if (strcmp(key, "BackFill") == 0) {
    struct Hook **ud = (struct Hook **)lua_newuserdata(L, sizeof(struct Hook *));
    *ud = (struct Hook*)obj->BackFill;
    luaL_getmetatable(L, "Hook");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "reserved1") == 0) {
    lua_pushinteger(L, obj->reserved1);
    return 1;
  }
  // Unsupported ClipRegion struct Region *
  if (strcmp(key, "ClipRegion") == 0) {
    return luaL_error(L, "Unsupported type struct Region * for field ClipRegion");
  }
  if (strcmp(key, "clipped") == 0) {
    struct ClipRect **ud = (struct ClipRect **)lua_newuserdata(L, sizeof(struct ClipRect *));
    *ud = (struct ClipRect*)obj->clipped;
    luaL_getmetatable(L, "ClipRect");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "Width") == 0) {
    lua_pushinteger(L, obj->Width);
    return 1;
  }
  if (strcmp(key, "Height") == 0) {
    lua_pushinteger(L, obj->Height);
    return 1;
  }
  if (strcmp(key, "reserved2") == 0) {
    _lua_gen_push_UBYTE_array_proxy(L, obj->reserved2, 18);
    return 1;
  }
  // Unsupported DamageList struct Region *
  if (strcmp(key, "DamageList") == 0) {
    return luaL_error(L, "Unsupported type struct Region * for field DamageList");
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct Layer));
    return 1;
}

  return 0;
}

static void
_lua_gen_Layer_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "bounds.MinX");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "bounds.MinY");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "bounds.MaxX");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "bounds.MaxY");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "priority");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "Flags");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "Window");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "Scroll_X");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "Scroll_Y");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "Lock.ss_Link.ln_Type");
  lua_rawseti(L, -2, 10);
  lua_pushstring(L, "Lock.ss_Link.ln_Pri");
  lua_rawseti(L, -2, 11);
  lua_pushstring(L, "Lock.ss_Link.ln_Name");
  lua_rawseti(L, -2, 12);
  lua_pushstring(L, "Lock.ss_NestCount");
  lua_rawseti(L, -2, 13);
  lua_pushstring(L, "Lock.ss_QueueCount");
  lua_rawseti(L, -2, 14);
  lua_pushstring(L, "reserved1");
  lua_rawseti(L, -2, 15);
  lua_pushstring(L, "Width");
  lua_rawseti(L, -2, 16);
  lua_pushstring(L, "Height");
  lua_rawseti(L, -2, 17);
  lua_pushstring(L, "reserved2");
  lua_rawseti(L, -2, 18);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_Layer(lua_State *L) {
  if (luaL_newmetatable(L, "Layer")) {
    lua_pushcfunction(L, _lua_gen_Layer_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_Layer_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_Layer_constructor);
    lua_setglobal(L, "Layer");
    _lua_gen_Layer_install_keys(L);
    lua_pushstring(L, "Layer");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_Layer_Info_newindex(lua_State *L)
{
  struct Layer_Info *obj = *(struct Layer_Info **)luaL_checkudata(L, 1, "Layer_Info");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "top_layer") == 0) {
    // finder 1
    //obj->top_layer = *(struct Layer **)luaL_checkudata(L, 3, "Layer");
    obj->top_layer = (struct Layer *)_lua_gen_checkLayer(L, 3);
    return 0;
  }
  if (strcmp(key, "resPtr1") == 0) {
    obj->resPtr1 = (void *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "resPtr2") == 0) {
    obj->resPtr2 = (void *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "FreeClipRects") == 0) {
    // finder 1
    //obj->FreeClipRects = *(struct ClipRect **)luaL_checkudata(L, 3, "ClipRect");
    obj->FreeClipRects = (struct ClipRect *)_lua_gen_checkClipRect(L, 3);
    return 0;
  }
  if (strcmp(key, "bounds.MinX") == 0) {
    obj->bounds.MinX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bounds.MinY") == 0) {
    obj->bounds.MinY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bounds.MaxX") == 0) {
    obj->bounds.MaxX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "bounds.MaxY") == 0) {
    obj->bounds.MaxY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type bounds struct Rectangle
  if (strcmp(key, "bounds") == 0) {
    return luaL_error(L, "Unsupported type struct Rectangle for field bounds");
  }
  // Unsupported type Lock.ss_Link.ln_Succ struct Node
  if (strcmp(key, "Lock.ss_Link.ln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field Lock.ss_Link.ln_Succ");
  }
  // Unsupported type Lock.ss_Link.ln_Pred struct Node
  if (strcmp(key, "Lock.ss_Link.ln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field Lock.ss_Link.ln_Pred");
  }
  if (strcmp(key, "Lock.ss_Link.ln_Type") == 0) {
    obj->Lock.ss_Link.ln_Type = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Lock.ss_Link.ln_Pri") == 0) {
    obj->Lock.ss_Link.ln_Pri = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Lock.ss_Link.ln_Name") == 0) {
    obj->Lock.ss_Link.ln_Name = (char *)luaL_checkstring(L, 3);
    return 0;
  }
  // Unsupported type Lock.ss_Link struct Node
  if (strcmp(key, "Lock.ss_Link") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field Lock.ss_Link");
  }
  if (strcmp(key, "Lock.ss_NestCount") == 0) {
    obj->Lock.ss_NestCount = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Lock.ss_WaitQueue.mlh_Head") == 0) {
    // finder 1
    //obj->Lock.ss_WaitQueue.mlh_Head = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->Lock.ss_WaitQueue.mlh_Head = (struct MinNode *)_lua_gen_checkMinNode(L, 3);
    return 0;
  }
  if (strcmp(key, "Lock.ss_WaitQueue.mlh_Tail") == 0) {
    // finder 1
    //obj->Lock.ss_WaitQueue.mlh_Tail = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->Lock.ss_WaitQueue.mlh_Tail = (struct MinNode *)_lua_gen_checkMinNode(L, 3);
    return 0;
  }
  if (strcmp(key, "Lock.ss_WaitQueue.mlh_TailPred") == 0) {
    // finder 1
    //obj->Lock.ss_WaitQueue.mlh_TailPred = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->Lock.ss_WaitQueue.mlh_TailPred = (struct MinNode *)_lua_gen_checkMinNode(L, 3);
    return 0;
  }
  // Unsupported type Lock.ss_WaitQueue struct MinList
  if (strcmp(key, "Lock.ss_WaitQueue") == 0) {
    return luaL_error(L, "Unsupported type struct MinList for field Lock.ss_WaitQueue");
  }
  if (strcmp(key, "Lock.ss_MultipleLink.sr_Link.mln_Succ") == 0) {
    // finder 1
    //obj->Lock.ss_MultipleLink.sr_Link.mln_Succ = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->Lock.ss_MultipleLink.sr_Link.mln_Succ = (struct MinNode *)_lua_gen_checkMinNode(L, 3);
    return 0;
  }
  if (strcmp(key, "Lock.ss_MultipleLink.sr_Link.mln_Pred") == 0) {
    // finder 1
    //obj->Lock.ss_MultipleLink.sr_Link.mln_Pred = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->Lock.ss_MultipleLink.sr_Link.mln_Pred = (struct MinNode *)_lua_gen_checkMinNode(L, 3);
    return 0;
  }
  if (strcmp(key, "Lock.ss_MultipleLink.sr_Link") == 0) {
    // finder 0
    struct MinNode *val = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->Lock.ss_MultipleLink.sr_Link = *val;
    return 0;
  }
  // Unsupported type Lock.ss_MultipleLink.sr_Waiter struct Task
  if (strcmp(key, "Lock.ss_MultipleLink.sr_Waiter") == 0) {
    return luaL_error(L, "Unsupported type struct Task for field Lock.ss_MultipleLink.sr_Waiter");
  }
  // Unsupported type Lock.ss_MultipleLink struct SemaphoreRequest
  if (strcmp(key, "Lock.ss_MultipleLink") == 0) {
    return luaL_error(L, "Unsupported type struct SemaphoreRequest for field Lock.ss_MultipleLink");
  }
  // Unsupported type Lock.ss_Owner struct Task
  if (strcmp(key, "Lock.ss_Owner") == 0) {
    return luaL_error(L, "Unsupported type struct Task for field Lock.ss_Owner");
  }
  if (strcmp(key, "Lock.ss_QueueCount") == 0) {
    obj->Lock.ss_QueueCount = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type Lock struct SignalSemaphore
  if (strcmp(key, "Lock") == 0) {
    return luaL_error(L, "Unsupported type struct SignalSemaphore for field Lock");
  }
  if (strcmp(key, "gs_Head.mlh_Head") == 0) {
    // finder 1
    //obj->gs_Head.mlh_Head = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->gs_Head.mlh_Head = (struct MinNode *)_lua_gen_checkMinNode(L, 3);
    return 0;
  }
  if (strcmp(key, "gs_Head.mlh_Tail") == 0) {
    // finder 1
    //obj->gs_Head.mlh_Tail = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->gs_Head.mlh_Tail = (struct MinNode *)_lua_gen_checkMinNode(L, 3);
    return 0;
  }
  if (strcmp(key, "gs_Head.mlh_TailPred") == 0) {
    // finder 1
    //obj->gs_Head.mlh_TailPred = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->gs_Head.mlh_TailPred = (struct MinNode *)_lua_gen_checkMinNode(L, 3);
    return 0;
  }
  // Unsupported type gs_Head struct MinList
  if (strcmp(key, "gs_Head") == 0) {
    return luaL_error(L, "Unsupported type struct MinList for field gs_Head");
  }
  if (strcmp(key, "PrivateReserve3") == 0) {
    obj->PrivateReserve3 = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "PrivateReserve4") == 0) {
    obj->PrivateReserve4 = (void *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "Flags") == 0) {
    obj->Flags = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "res_count") == 0) {
    obj->res_count = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "LockLayersCount") == 0) {
    obj->LockLayersCount = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "PrivateReserve5") == 0) {
    obj->PrivateReserve5 = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "UserClipRectsCount") == 0) {
    obj->UserClipRectsCount = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "BlankHook") == 0) {
    // finder 1
    //obj->BlankHook = *(struct Hook **)luaL_checkudata(L, 3, "Hook");
    obj->BlankHook = (struct Hook *)_lua_gen_checkHook(L, 3);
    return 0;
  }
  if (strcmp(key, "resPtr5") == 0) {
    obj->resPtr5 = (void *)lua_touserdata(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_Layer_Info_constructor(lua_State *L)
{
  // Allocate pointer-to-struct Layer_Info in userdata
  struct Layer_Info **objp = lua_newuserdata(L, sizeof(struct Layer_Info *));
  *objp = malloc(sizeof(struct Layer_Info));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct Layer_Info));

  // Set metatable
  luaL_getmetatable(L, "Layer_Info");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_Layer_Info_index(lua_State *L)
{
  struct Layer_Info *obj = *(struct Layer_Info **)luaL_checkudata(L, 1, "Layer_Info");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "top_layer") == 0) {
    struct Layer **ud = (struct Layer **)lua_newuserdata(L, sizeof(struct Layer *));
    *ud = (struct Layer*)obj->top_layer;
    luaL_getmetatable(L, "Layer");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "resPtr1") == 0) {
    lua_pushlightuserdata(L, obj->resPtr1);
    return 1;
  }
  if (strcmp(key, "resPtr2") == 0) {
    lua_pushlightuserdata(L, obj->resPtr2);
    return 1;
  }
  if (strcmp(key, "FreeClipRects") == 0) {
    struct ClipRect **ud = (struct ClipRect **)lua_newuserdata(L, sizeof(struct ClipRect *));
    *ud = (struct ClipRect*)obj->FreeClipRects;
    luaL_getmetatable(L, "ClipRect");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "bounds.MinX") == 0) {
    lua_pushinteger(L, obj->bounds.MinX);
    return 1;
  }
  if (strcmp(key, "bounds.MinY") == 0) {
    lua_pushinteger(L, obj->bounds.MinY);
    return 1;
  }
  if (strcmp(key, "bounds.MaxX") == 0) {
    lua_pushinteger(L, obj->bounds.MaxX);
    return 1;
  }
  if (strcmp(key, "bounds.MaxY") == 0) {
    lua_pushinteger(L, obj->bounds.MaxY);
    return 1;
  }
  // Unsupported bounds struct Rectangle
  if (strcmp(key, "bounds") == 0) {
    return luaL_error(L, "Unsupported type struct Rectangle for field bounds");
  }
  // Unsupported Lock.ss_Link.ln_Succ struct Node *
  if (strcmp(key, "Lock.ss_Link.ln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field Lock.ss_Link.ln_Succ");
  }
  // Unsupported Lock.ss_Link.ln_Pred struct Node *
  if (strcmp(key, "Lock.ss_Link.ln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field Lock.ss_Link.ln_Pred");
  }
  if (strcmp(key, "Lock.ss_Link.ln_Type") == 0) {
    lua_pushinteger(L, obj->Lock.ss_Link.ln_Type);
    return 1;
  }
  if (strcmp(key, "Lock.ss_Link.ln_Pri") == 0) {
    lua_pushinteger(L, obj->Lock.ss_Link.ln_Pri);
    return 1;
  }
  if (strcmp(key, "Lock.ss_Link.ln_Name") == 0) {
    lua_pushstring(L, obj->Lock.ss_Link.ln_Name);
    return 1;
  }
  // Unsupported Lock.ss_Link struct Node
  if (strcmp(key, "Lock.ss_Link") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field Lock.ss_Link");
  }
  if (strcmp(key, "Lock.ss_NestCount") == 0) {
    lua_pushinteger(L, obj->Lock.ss_NestCount);
    return 1;
  }
  if (strcmp(key, "Lock.ss_WaitQueue.mlh_Head") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)obj->Lock.ss_WaitQueue.mlh_Head;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "Lock.ss_WaitQueue.mlh_Tail") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)obj->Lock.ss_WaitQueue.mlh_Tail;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "Lock.ss_WaitQueue.mlh_TailPred") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)obj->Lock.ss_WaitQueue.mlh_TailPred;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  // Unsupported Lock.ss_WaitQueue struct MinList
  if (strcmp(key, "Lock.ss_WaitQueue") == 0) {
    return luaL_error(L, "Unsupported type struct MinList for field Lock.ss_WaitQueue");
  }
  if (strcmp(key, "Lock.ss_MultipleLink.sr_Link.mln_Succ") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)obj->Lock.ss_MultipleLink.sr_Link.mln_Succ;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "Lock.ss_MultipleLink.sr_Link.mln_Pred") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)obj->Lock.ss_MultipleLink.sr_Link.mln_Pred;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "Lock.ss_MultipleLink.sr_Link") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)&obj->Lock.ss_MultipleLink.sr_Link;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  // Unsupported Lock.ss_MultipleLink.sr_Waiter struct Task *
  if (strcmp(key, "Lock.ss_MultipleLink.sr_Waiter") == 0) {
    return luaL_error(L, "Unsupported type struct Task * for field Lock.ss_MultipleLink.sr_Waiter");
  }
  // Unsupported Lock.ss_MultipleLink struct SemaphoreRequest
  if (strcmp(key, "Lock.ss_MultipleLink") == 0) {
    return luaL_error(L, "Unsupported type struct SemaphoreRequest for field Lock.ss_MultipleLink");
  }
  // Unsupported Lock.ss_Owner struct Task *
  if (strcmp(key, "Lock.ss_Owner") == 0) {
    return luaL_error(L, "Unsupported type struct Task * for field Lock.ss_Owner");
  }
  if (strcmp(key, "Lock.ss_QueueCount") == 0) {
    lua_pushinteger(L, obj->Lock.ss_QueueCount);
    return 1;
  }
  // Unsupported Lock struct SignalSemaphore
  if (strcmp(key, "Lock") == 0) {
    return luaL_error(L, "Unsupported type struct SignalSemaphore for field Lock");
  }
  if (strcmp(key, "gs_Head.mlh_Head") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)obj->gs_Head.mlh_Head;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "gs_Head.mlh_Tail") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)obj->gs_Head.mlh_Tail;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "gs_Head.mlh_TailPred") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)obj->gs_Head.mlh_TailPred;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  // Unsupported gs_Head struct MinList
  if (strcmp(key, "gs_Head") == 0) {
    return luaL_error(L, "Unsupported type struct MinList for field gs_Head");
  }
  if (strcmp(key, "PrivateReserve3") == 0) {
    lua_pushinteger(L, obj->PrivateReserve3);
    return 1;
  }
  if (strcmp(key, "PrivateReserve4") == 0) {
    lua_pushlightuserdata(L, obj->PrivateReserve4);
    return 1;
  }
  if (strcmp(key, "Flags") == 0) {
    lua_pushinteger(L, obj->Flags);
    return 1;
  }
  if (strcmp(key, "res_count") == 0) {
    lua_pushinteger(L, obj->res_count);
    return 1;
  }
  if (strcmp(key, "LockLayersCount") == 0) {
    lua_pushinteger(L, obj->LockLayersCount);
    return 1;
  }
  if (strcmp(key, "PrivateReserve5") == 0) {
    lua_pushinteger(L, obj->PrivateReserve5);
    return 1;
  }
  if (strcmp(key, "UserClipRectsCount") == 0) {
    lua_pushinteger(L, obj->UserClipRectsCount);
    return 1;
  }
  if (strcmp(key, "BlankHook") == 0) {
    struct Hook **ud = (struct Hook **)lua_newuserdata(L, sizeof(struct Hook *));
    *ud = (struct Hook*)obj->BlankHook;
    luaL_getmetatable(L, "Hook");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "resPtr5") == 0) {
    lua_pushlightuserdata(L, obj->resPtr5);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct Layer_Info));
    return 1;
}

  return 0;
}

static void
_lua_gen_Layer_Info_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "bounds.MinX");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "bounds.MinY");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "bounds.MaxX");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "bounds.MaxY");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "Lock.ss_Link.ln_Type");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "Lock.ss_Link.ln_Pri");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "Lock.ss_Link.ln_Name");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "Lock.ss_NestCount");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "Lock.ss_QueueCount");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "PrivateReserve3");
  lua_rawseti(L, -2, 10);
  lua_pushstring(L, "Flags");
  lua_rawseti(L, -2, 11);
  lua_pushstring(L, "res_count");
  lua_rawseti(L, -2, 12);
  lua_pushstring(L, "LockLayersCount");
  lua_rawseti(L, -2, 13);
  lua_pushstring(L, "PrivateReserve5");
  lua_rawseti(L, -2, 14);
  lua_pushstring(L, "UserClipRectsCount");
  lua_rawseti(L, -2, 15);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_Layer_Info(lua_State *L) {
  if (luaL_newmetatable(L, "Layer_Info")) {
    lua_pushcfunction(L, _lua_gen_Layer_Info_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_Layer_Info_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_Layer_Info_constructor);
    lua_setglobal(L, "Layer_Info");
    _lua_gen_Layer_Info_install_keys(L);
    lua_pushstring(L, "Layer_Info");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_Menu_newindex(lua_State *L)
{
  struct Menu *obj = *(struct Menu **)luaL_checkudata(L, 1, "Menu");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "NextMenu") == 0) {
    // finder 1
    //obj->NextMenu = *(struct Menu **)luaL_checkudata(L, 3, "Menu");
    obj->NextMenu = (struct Menu *)_lua_gen_checkMenu(L, 3);
    return 0;
  }
  if (strcmp(key, "LeftEdge") == 0) {
    obj->LeftEdge = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "TopEdge") == 0) {
    obj->TopEdge = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Width") == 0) {
    obj->Width = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Height") == 0) {
    obj->Height = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Flags") == 0) {
    obj->Flags = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "MenuName") == 0) {
    obj->MenuName = (CONST_STRPTR)amiga_checkConstNullableString(L, 3);
    return 0;
  }
  if (strcmp(key, "FirstItem") == 0) {
    // finder 1
    //obj->FirstItem = *(struct MenuItem **)luaL_checkudata(L, 3, "MenuItem");
    obj->FirstItem = (struct MenuItem *)_lua_gen_checkMenuItem(L, 3);
    return 0;
  }
  if (strcmp(key, "JazzX") == 0) {
    obj->JazzX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "JazzY") == 0) {
    obj->JazzY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "BeatX") == 0) {
    obj->BeatX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "BeatY") == 0) {
    obj->BeatY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_Menu_constructor(lua_State *L)
{
  // Allocate pointer-to-struct Menu in userdata
  struct Menu **objp = lua_newuserdata(L, sizeof(struct Menu *));
  *objp = malloc(sizeof(struct Menu));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct Menu));

  // Set metatable
  luaL_getmetatable(L, "Menu");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_Menu_index(lua_State *L)
{
  struct Menu *obj = *(struct Menu **)luaL_checkudata(L, 1, "Menu");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "NextMenu") == 0) {
    struct Menu **ud = (struct Menu **)lua_newuserdata(L, sizeof(struct Menu *));
    *ud = (struct Menu*)obj->NextMenu;
    luaL_getmetatable(L, "Menu");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "LeftEdge") == 0) {
    lua_pushinteger(L, obj->LeftEdge);
    return 1;
  }
  if (strcmp(key, "TopEdge") == 0) {
    lua_pushinteger(L, obj->TopEdge);
    return 1;
  }
  if (strcmp(key, "Width") == 0) {
    lua_pushinteger(L, obj->Width);
    return 1;
  }
  if (strcmp(key, "Height") == 0) {
    lua_pushinteger(L, obj->Height);
    return 1;
  }
  if (strcmp(key, "Flags") == 0) {
    lua_pushinteger(L, obj->Flags);
    return 1;
  }
  if (strcmp(key, "MenuName") == 0) {
    lua_pushstring(L, obj->MenuName);
    return 1;
  }
  if (strcmp(key, "FirstItem") == 0) {
    struct MenuItem **ud = (struct MenuItem **)lua_newuserdata(L, sizeof(struct MenuItem *));
    *ud = (struct MenuItem*)obj->FirstItem;
    luaL_getmetatable(L, "MenuItem");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "JazzX") == 0) {
    lua_pushinteger(L, obj->JazzX);
    return 1;
  }
  if (strcmp(key, "JazzY") == 0) {
    lua_pushinteger(L, obj->JazzY);
    return 1;
  }
  if (strcmp(key, "BeatX") == 0) {
    lua_pushinteger(L, obj->BeatX);
    return 1;
  }
  if (strcmp(key, "BeatY") == 0) {
    lua_pushinteger(L, obj->BeatY);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct Menu));
    return 1;
}

  return 0;
}

static void
_lua_gen_Menu_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "LeftEdge");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "TopEdge");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "Width");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "Height");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "Flags");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "MenuName");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "JazzX");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "JazzY");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "BeatX");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "BeatY");
  lua_rawseti(L, -2, 10);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_Menu(lua_State *L) {
  if (luaL_newmetatable(L, "Menu")) {
    lua_pushcfunction(L, _lua_gen_Menu_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_Menu_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_Menu_constructor);
    lua_setglobal(L, "Menu");
    _lua_gen_Menu_install_keys(L);
    lua_pushstring(L, "Menu");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_MenuItem_newindex(lua_State *L)
{
  struct MenuItem *obj = *(struct MenuItem **)luaL_checkudata(L, 1, "MenuItem");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "NextItem") == 0) {
    // finder 1
    //obj->NextItem = *(struct MenuItem **)luaL_checkudata(L, 3, "MenuItem");
    obj->NextItem = (struct MenuItem *)_lua_gen_checkMenuItem(L, 3);
    return 0;
  }
  if (strcmp(key, "LeftEdge") == 0) {
    obj->LeftEdge = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "TopEdge") == 0) {
    obj->TopEdge = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Width") == 0) {
    obj->Width = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Height") == 0) {
    obj->Height = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Flags") == 0) {
    obj->Flags = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "MutualExclude") == 0) {
    obj->MutualExclude = (LONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ItemFill") == 0) {
    obj->ItemFill = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "SelectFill") == 0) {
    obj->SelectFill = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "Command") == 0) {
    obj->Command = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "SubItem") == 0) {
    // finder 1
    //obj->SubItem = *(struct MenuItem **)luaL_checkudata(L, 3, "MenuItem");
    obj->SubItem = (struct MenuItem *)_lua_gen_checkMenuItem(L, 3);
    return 0;
  }
  if (strcmp(key, "NextSelect") == 0) {
    obj->NextSelect = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_MenuItem_constructor(lua_State *L)
{
  // Allocate pointer-to-struct MenuItem in userdata
  struct MenuItem **objp = lua_newuserdata(L, sizeof(struct MenuItem *));
  *objp = malloc(sizeof(struct MenuItem));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct MenuItem));

  // Set metatable
  luaL_getmetatable(L, "MenuItem");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_MenuItem_index(lua_State *L)
{
  struct MenuItem *obj = *(struct MenuItem **)luaL_checkudata(L, 1, "MenuItem");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "NextItem") == 0) {
    struct MenuItem **ud = (struct MenuItem **)lua_newuserdata(L, sizeof(struct MenuItem *));
    *ud = (struct MenuItem*)obj->NextItem;
    luaL_getmetatable(L, "MenuItem");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "LeftEdge") == 0) {
    lua_pushinteger(L, obj->LeftEdge);
    return 1;
  }
  if (strcmp(key, "TopEdge") == 0) {
    lua_pushinteger(L, obj->TopEdge);
    return 1;
  }
  if (strcmp(key, "Width") == 0) {
    lua_pushinteger(L, obj->Width);
    return 1;
  }
  if (strcmp(key, "Height") == 0) {
    lua_pushinteger(L, obj->Height);
    return 1;
  }
  if (strcmp(key, "Flags") == 0) {
    lua_pushinteger(L, obj->Flags);
    return 1;
  }
  if (strcmp(key, "MutualExclude") == 0) {
    lua_pushinteger(L, obj->MutualExclude);
    return 1;
  }
  if (strcmp(key, "ItemFill") == 0) {
    lua_pushlightuserdata(L, obj->ItemFill);
    return 1;
  }
  if (strcmp(key, "SelectFill") == 0) {
    lua_pushlightuserdata(L, obj->SelectFill);
    return 1;
  }
  if (strcmp(key, "Command") == 0) {
    lua_pushinteger(L, obj->Command);
    return 1;
  }
  if (strcmp(key, "SubItem") == 0) {
    struct MenuItem **ud = (struct MenuItem **)lua_newuserdata(L, sizeof(struct MenuItem *));
    *ud = (struct MenuItem*)obj->SubItem;
    luaL_getmetatable(L, "MenuItem");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "NextSelect") == 0) {
    lua_pushinteger(L, obj->NextSelect);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct MenuItem));
    return 1;
}

  return 0;
}

static void
_lua_gen_MenuItem_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "LeftEdge");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "TopEdge");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "Width");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "Height");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "Flags");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "MutualExclude");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "ItemFill");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "SelectFill");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "Command");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "NextSelect");
  lua_rawseti(L, -2, 10);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_MenuItem(lua_State *L) {
  if (luaL_newmetatable(L, "MenuItem")) {
    lua_pushcfunction(L, _lua_gen_MenuItem_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_MenuItem_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_MenuItem_constructor);
    lua_setglobal(L, "MenuItem");
    _lua_gen_MenuItem_install_keys(L);
    lua_pushstring(L, "MenuItem");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_NewGadget_newindex(lua_State *L)
{
  struct NewGadget *obj = *(struct NewGadget **)luaL_checkudata(L, 1, "NewGadget");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "ng_LeftEdge") == 0) {
    obj->ng_LeftEdge = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ng_TopEdge") == 0) {
    obj->ng_TopEdge = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ng_Width") == 0) {
    obj->ng_Width = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ng_Height") == 0) {
    obj->ng_Height = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ng_GadgetText") == 0) {
    obj->ng_GadgetText = (CONST_STRPTR)amiga_checkConstNullableString(L, 3);
    return 0;
  }
  if (strcmp(key, "ng_TextAttr") == 0) {
    // finder 1
    //obj->ng_TextAttr = *(struct TextAttr **)luaL_checkudata(L, 3, "TextAttr");
    obj->ng_TextAttr = (struct TextAttr *)_lua_gen_checkTextAttr(L, 3);
    return 0;
  }
  if (strcmp(key, "ng_GadgetID") == 0) {
    obj->ng_GadgetID = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ng_Flags") == 0) {
    obj->ng_Flags = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ng_VisualInfo") == 0) {
    obj->ng_VisualInfo = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "ng_UserData") == 0) {
    obj->ng_UserData = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_NewGadget_constructor(lua_State *L)
{
  // Allocate pointer-to-struct NewGadget in userdata
  struct NewGadget **objp = lua_newuserdata(L, sizeof(struct NewGadget *));
  *objp = malloc(sizeof(struct NewGadget));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct NewGadget));

  // Set metatable
  luaL_getmetatable(L, "NewGadget");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_NewGadget_index(lua_State *L)
{
  struct NewGadget *obj = *(struct NewGadget **)luaL_checkudata(L, 1, "NewGadget");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "ng_LeftEdge") == 0) {
    lua_pushinteger(L, obj->ng_LeftEdge);
    return 1;
  }
  if (strcmp(key, "ng_TopEdge") == 0) {
    lua_pushinteger(L, obj->ng_TopEdge);
    return 1;
  }
  if (strcmp(key, "ng_Width") == 0) {
    lua_pushinteger(L, obj->ng_Width);
    return 1;
  }
  if (strcmp(key, "ng_Height") == 0) {
    lua_pushinteger(L, obj->ng_Height);
    return 1;
  }
  if (strcmp(key, "ng_GadgetText") == 0) {
    lua_pushstring(L, obj->ng_GadgetText);
    return 1;
  }
  if (strcmp(key, "ng_TextAttr") == 0) {
    struct TextAttr **ud = (struct TextAttr **)lua_newuserdata(L, sizeof(struct TextAttr *));
    *ud = (struct TextAttr*)obj->ng_TextAttr;
    luaL_getmetatable(L, "TextAttr");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "ng_GadgetID") == 0) {
    lua_pushinteger(L, obj->ng_GadgetID);
    return 1;
  }
  if (strcmp(key, "ng_Flags") == 0) {
    lua_pushinteger(L, obj->ng_Flags);
    return 1;
  }
  if (strcmp(key, "ng_VisualInfo") == 0) {
    lua_pushlightuserdata(L, obj->ng_VisualInfo);
    return 1;
  }
  if (strcmp(key, "ng_UserData") == 0) {
    lua_pushlightuserdata(L, obj->ng_UserData);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct NewGadget));
    return 1;
}

  return 0;
}

static void
_lua_gen_NewGadget_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "ng_LeftEdge");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "ng_TopEdge");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "ng_Width");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "ng_Height");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "ng_GadgetText");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "ng_GadgetID");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "ng_Flags");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "ng_VisualInfo");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "ng_UserData");
  lua_rawseti(L, -2, 9);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_NewGadget(lua_State *L) {
  if (luaL_newmetatable(L, "NewGadget")) {
    lua_pushcfunction(L, _lua_gen_NewGadget_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_NewGadget_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_NewGadget_constructor);
    lua_setglobal(L, "NewGadget");
    _lua_gen_NewGadget_install_keys(L);
    lua_pushstring(L, "NewGadget");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_NewMenu_newindex(lua_State *L)
{
  struct NewMenu *obj = *(struct NewMenu **)luaL_checkudata(L, 1, "NewMenu");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "nm_Type") == 0) {
    obj->nm_Type = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "nm_Label") == 0) {
    obj->nm_Label = (CONST_STRPTR)amiga_checkConstNullableString(L, 3);
    return 0;
  }
  if (strcmp(key, "nm_CommKey") == 0) {
    obj->nm_CommKey = (CONST_STRPTR)amiga_checkConstNullableString(L, 3);
    return 0;
  }
  if (strcmp(key, "nm_Flags") == 0) {
    obj->nm_Flags = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "nm_MutualExclude") == 0) {
    obj->nm_MutualExclude = (LONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "nm_UserData") == 0) {
    obj->nm_UserData = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_NewMenu_constructor(lua_State *L)
{
  // Allocate pointer-to-struct NewMenu in userdata
  struct NewMenu **objp = lua_newuserdata(L, sizeof(struct NewMenu *));
  *objp = malloc(sizeof(struct NewMenu));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct NewMenu));

  // Set metatable
  luaL_getmetatable(L, "NewMenu");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_NewMenu_index(lua_State *L)
{
  struct NewMenu *obj = *(struct NewMenu **)luaL_checkudata(L, 1, "NewMenu");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "nm_Type") == 0) {
    lua_pushinteger(L, obj->nm_Type);
    return 1;
  }
  if (strcmp(key, "nm_Label") == 0) {
    lua_pushstring(L, obj->nm_Label);
    return 1;
  }
  if (strcmp(key, "nm_CommKey") == 0) {
    lua_pushstring(L, obj->nm_CommKey);
    return 1;
  }
  if (strcmp(key, "nm_Flags") == 0) {
    lua_pushinteger(L, obj->nm_Flags);
    return 1;
  }
  if (strcmp(key, "nm_MutualExclude") == 0) {
    lua_pushinteger(L, obj->nm_MutualExclude);
    return 1;
  }
  if (strcmp(key, "nm_UserData") == 0) {
    lua_pushlightuserdata(L, obj->nm_UserData);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct NewMenu));
    return 1;
}

  return 0;
}

static void
_lua_gen_NewMenu_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "nm_Type");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "nm_Label");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "nm_CommKey");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "nm_Flags");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "nm_MutualExclude");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "nm_UserData");
  lua_rawseti(L, -2, 6);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_NewMenu(lua_State *L) {
  if (luaL_newmetatable(L, "NewMenu")) {
    lua_pushcfunction(L, _lua_gen_NewMenu_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_NewMenu_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_NewMenu_constructor);
    lua_setglobal(L, "NewMenu");
    _lua_gen_NewMenu_install_keys(L);
    lua_pushstring(L, "NewMenu");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_NewScreen_newindex(lua_State *L)
{
  struct NewScreen *obj = *(struct NewScreen **)luaL_checkudata(L, 1, "NewScreen");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "LeftEdge") == 0) {
    obj->LeftEdge = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "TopEdge") == 0) {
    obj->TopEdge = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Width") == 0) {
    obj->Width = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Height") == 0) {
    obj->Height = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Depth") == 0) {
    obj->Depth = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DetailPen") == 0) {
    obj->DetailPen = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "BlockPen") == 0) {
    obj->BlockPen = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ViewModes") == 0) {
    obj->ViewModes = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Type") == 0) {
    obj->Type = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Font") == 0) {
    // finder 1
    //obj->Font = *(struct TextAttr **)luaL_checkudata(L, 3, "TextAttr");
    obj->Font = (struct TextAttr *)_lua_gen_checkTextAttr(L, 3);
    return 0;
  }
  if (strcmp(key, "DefaultTitle") == 0) {
    obj->DefaultTitle = (STRPTR)amiga_checkNullableString(L, 3);
    return 0;
  }
  if (strcmp(key, "Gadgets") == 0) {
    // finder 1
    //obj->Gadgets = *(struct Gadget **)luaL_checkudata(L, 3, "Gadget");
    obj->Gadgets = (struct Gadget *)_lua_gen_checkGadget(L, 3);
    return 0;
  }
  if (strcmp(key, "CustomBitMap") == 0) {
    // finder 1
    //obj->CustomBitMap = *(struct BitMap **)luaL_checkudata(L, 3, "BitMap");
    obj->CustomBitMap = (struct BitMap *)_lua_gen_checkBitMap(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_NewScreen_constructor(lua_State *L)
{
  // Allocate pointer-to-struct NewScreen in userdata
  struct NewScreen **objp = lua_newuserdata(L, sizeof(struct NewScreen *));
  *objp = malloc(sizeof(struct NewScreen));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct NewScreen));

  // Set metatable
  luaL_getmetatable(L, "NewScreen");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_NewScreen_index(lua_State *L)
{
  struct NewScreen *obj = *(struct NewScreen **)luaL_checkudata(L, 1, "NewScreen");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "LeftEdge") == 0) {
    lua_pushinteger(L, obj->LeftEdge);
    return 1;
  }
  if (strcmp(key, "TopEdge") == 0) {
    lua_pushinteger(L, obj->TopEdge);
    return 1;
  }
  if (strcmp(key, "Width") == 0) {
    lua_pushinteger(L, obj->Width);
    return 1;
  }
  if (strcmp(key, "Height") == 0) {
    lua_pushinteger(L, obj->Height);
    return 1;
  }
  if (strcmp(key, "Depth") == 0) {
    lua_pushinteger(L, obj->Depth);
    return 1;
  }
  if (strcmp(key, "DetailPen") == 0) {
    lua_pushinteger(L, obj->DetailPen);
    return 1;
  }
  if (strcmp(key, "BlockPen") == 0) {
    lua_pushinteger(L, obj->BlockPen);
    return 1;
  }
  if (strcmp(key, "ViewModes") == 0) {
    lua_pushinteger(L, obj->ViewModes);
    return 1;
  }
  if (strcmp(key, "Type") == 0) {
    lua_pushinteger(L, obj->Type);
    return 1;
  }
  if (strcmp(key, "Font") == 0) {
    struct TextAttr **ud = (struct TextAttr **)lua_newuserdata(L, sizeof(struct TextAttr *));
    *ud = (struct TextAttr*)obj->Font;
    luaL_getmetatable(L, "TextAttr");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "DefaultTitle") == 0) {
    lua_pushstring(L, obj->DefaultTitle);
    return 1;
  }
  if (strcmp(key, "Gadgets") == 0) {
    struct Gadget **ud = (struct Gadget **)lua_newuserdata(L, sizeof(struct Gadget *));
    *ud = (struct Gadget*)obj->Gadgets;
    luaL_getmetatable(L, "Gadget");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "CustomBitMap") == 0) {
    struct BitMap **ud = (struct BitMap **)lua_newuserdata(L, sizeof(struct BitMap *));
    *ud = (struct BitMap*)obj->CustomBitMap;
    luaL_getmetatable(L, "BitMap");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct NewScreen));
    return 1;
}

  return 0;
}

static void
_lua_gen_NewScreen_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "LeftEdge");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "TopEdge");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "Width");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "Height");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "Depth");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "DetailPen");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "BlockPen");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "ViewModes");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "Type");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "DefaultTitle");
  lua_rawseti(L, -2, 10);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_NewScreen(lua_State *L) {
  if (luaL_newmetatable(L, "NewScreen")) {
    lua_pushcfunction(L, _lua_gen_NewScreen_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_NewScreen_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_NewScreen_constructor);
    lua_setglobal(L, "NewScreen");
    _lua_gen_NewScreen_install_keys(L);
    lua_pushstring(L, "NewScreen");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_NewWindow_newindex(lua_State *L)
{
  struct NewWindow *obj = *(struct NewWindow **)luaL_checkudata(L, 1, "NewWindow");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "LeftEdge") == 0) {
    obj->LeftEdge = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "TopEdge") == 0) {
    obj->TopEdge = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Width") == 0) {
    obj->Width = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Height") == 0) {
    obj->Height = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DetailPen") == 0) {
    obj->DetailPen = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "BlockPen") == 0) {
    obj->BlockPen = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "IDCMPFlags") == 0) {
    obj->IDCMPFlags = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Flags") == 0) {
    obj->Flags = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "FirstGadget") == 0) {
    // finder 1
    //obj->FirstGadget = *(struct Gadget **)luaL_checkudata(L, 3, "Gadget");
    obj->FirstGadget = (struct Gadget *)_lua_gen_checkGadget(L, 3);
    return 0;
  }
  if (strcmp(key, "CheckMark") == 0) {
    // finder 1
    //obj->CheckMark = *(struct Image **)luaL_checkudata(L, 3, "Image");
    obj->CheckMark = (struct Image *)_lua_gen_checkImage(L, 3);
    return 0;
  }
  if (strcmp(key, "Title") == 0) {
    obj->Title = (STRPTR)amiga_checkNullableString(L, 3);
    return 0;
  }
  if (strcmp(key, "Screen") == 0) {
    // finder 1
    //obj->Screen = *(struct Screen **)luaL_checkudata(L, 3, "Screen");
    obj->Screen = (struct Screen *)_lua_gen_checkScreen(L, 3);
    return 0;
  }
  if (strcmp(key, "BitMap") == 0) {
    // finder 1
    //obj->BitMap = *(struct BitMap **)luaL_checkudata(L, 3, "BitMap");
    obj->BitMap = (struct BitMap *)_lua_gen_checkBitMap(L, 3);
    return 0;
  }
  if (strcmp(key, "MinWidth") == 0) {
    obj->MinWidth = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "MinHeight") == 0) {
    obj->MinHeight = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "MaxWidth") == 0) {
    obj->MaxWidth = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "MaxHeight") == 0) {
    obj->MaxHeight = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Type") == 0) {
    obj->Type = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_NewWindow_constructor(lua_State *L)
{
  // Allocate pointer-to-struct NewWindow in userdata
  struct NewWindow **objp = lua_newuserdata(L, sizeof(struct NewWindow *));
  *objp = malloc(sizeof(struct NewWindow));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct NewWindow));

  // Set metatable
  luaL_getmetatable(L, "NewWindow");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_NewWindow_index(lua_State *L)
{
  struct NewWindow *obj = *(struct NewWindow **)luaL_checkudata(L, 1, "NewWindow");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "LeftEdge") == 0) {
    lua_pushinteger(L, obj->LeftEdge);
    return 1;
  }
  if (strcmp(key, "TopEdge") == 0) {
    lua_pushinteger(L, obj->TopEdge);
    return 1;
  }
  if (strcmp(key, "Width") == 0) {
    lua_pushinteger(L, obj->Width);
    return 1;
  }
  if (strcmp(key, "Height") == 0) {
    lua_pushinteger(L, obj->Height);
    return 1;
  }
  if (strcmp(key, "DetailPen") == 0) {
    lua_pushinteger(L, obj->DetailPen);
    return 1;
  }
  if (strcmp(key, "BlockPen") == 0) {
    lua_pushinteger(L, obj->BlockPen);
    return 1;
  }
  if (strcmp(key, "IDCMPFlags") == 0) {
    lua_pushinteger(L, obj->IDCMPFlags);
    return 1;
  }
  if (strcmp(key, "Flags") == 0) {
    lua_pushinteger(L, obj->Flags);
    return 1;
  }
  if (strcmp(key, "FirstGadget") == 0) {
    struct Gadget **ud = (struct Gadget **)lua_newuserdata(L, sizeof(struct Gadget *));
    *ud = (struct Gadget*)obj->FirstGadget;
    luaL_getmetatable(L, "Gadget");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "CheckMark") == 0) {
    struct Image **ud = (struct Image **)lua_newuserdata(L, sizeof(struct Image *));
    *ud = (struct Image*)obj->CheckMark;
    luaL_getmetatable(L, "Image");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "Title") == 0) {
    lua_pushstring(L, obj->Title);
    return 1;
  }
  if (strcmp(key, "Screen") == 0) {
    struct Screen **ud = (struct Screen **)lua_newuserdata(L, sizeof(struct Screen *));
    *ud = (struct Screen*)obj->Screen;
    luaL_getmetatable(L, "Screen");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "BitMap") == 0) {
    struct BitMap **ud = (struct BitMap **)lua_newuserdata(L, sizeof(struct BitMap *));
    *ud = (struct BitMap*)obj->BitMap;
    luaL_getmetatable(L, "BitMap");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "MinWidth") == 0) {
    lua_pushinteger(L, obj->MinWidth);
    return 1;
  }
  if (strcmp(key, "MinHeight") == 0) {
    lua_pushinteger(L, obj->MinHeight);
    return 1;
  }
  if (strcmp(key, "MaxWidth") == 0) {
    lua_pushinteger(L, obj->MaxWidth);
    return 1;
  }
  if (strcmp(key, "MaxHeight") == 0) {
    lua_pushinteger(L, obj->MaxHeight);
    return 1;
  }
  if (strcmp(key, "Type") == 0) {
    lua_pushinteger(L, obj->Type);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct NewWindow));
    return 1;
}

  return 0;
}

static void
_lua_gen_NewWindow_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "LeftEdge");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "TopEdge");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "Width");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "Height");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "DetailPen");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "BlockPen");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "IDCMPFlags");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "Flags");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "Title");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "MinWidth");
  lua_rawseti(L, -2, 10);
  lua_pushstring(L, "MinHeight");
  lua_rawseti(L, -2, 11);
  lua_pushstring(L, "MaxWidth");
  lua_rawseti(L, -2, 12);
  lua_pushstring(L, "MaxHeight");
  lua_rawseti(L, -2, 13);
  lua_pushstring(L, "Type");
  lua_rawseti(L, -2, 14);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_NewWindow(lua_State *L) {
  if (luaL_newmetatable(L, "NewWindow")) {
    lua_pushcfunction(L, _lua_gen_NewWindow_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_NewWindow_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_NewWindow_constructor);
    lua_setglobal(L, "NewWindow");
    _lua_gen_NewWindow_install_keys(L);
    lua_pushstring(L, "NewWindow");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

typedef struct {
  UWORD* data;
  uint16_t count;
} lua_gen_wrapped_UWORD_array_data_t;

static int _lua_gen_wrapped_UWORD_array_ptr_method(lua_State* L) {
    lua_gen_wrapped_UWORD_array_data_t* wrapper = luaL_checkudata(L, 1, "UWORD_array_proxy");
    int index = luaL_checkinteger(L, 2);
    void* ptr = &wrapper->data[index - 1];
    lua_pushlightuserdata(L, ptr);
    return 1;
}
static int
_lua_gen_wrapped_UWORD_array_index(lua_State* L)
{
  lua_gen_wrapped_UWORD_array_data_t* wrapper = luaL_checkudata(L, 1, "UWORD_array_proxy");
  if (lua_isinteger(L, 2)) {
    int index = lua_tointeger(L, 2);
    if (index < 1 || index > wrapper->count)
      return luaL_error(L, "index out of range (1..%d)", wrapper->count);
    lua_pushinteger(L, wrapper->data[index - 1]);
    return 1;
  }

  // Not a numeric key? Try methods
  lua_getmetatable(L, 1);
  lua_getfield(L, -1, "__methods");
  lua_pushvalue(L, 2);
  lua_gettable(L, -2);
  return 1;
}

static int
_lua_gen_wrapped_UWORD_array_newindex(lua_State* L)
{
  lua_gen_wrapped_UWORD_array_data_t* wrapper = luaL_checkudata(L, 1, "UWORD_array_proxy");
  if (!lua_isinteger(L, 2))
    return luaL_error(L, "only integer indices allowed");
  int index = lua_tointeger(L, 2);
  if (index < 1 || index > wrapper->count)
    return luaL_error(L, "index out of range (1..%d)", wrapper->count);
  UWORD value = luaL_checkinteger(L,  3);
  wrapper->data[index - 1] = value;
  return 0;
}

static void
_lua_gen_push_UWORD_array_proxy(lua_State *L,  UWORD *array, int count)
{

  lua_gen_wrapped_UWORD_array_data_t* wrapper = lua_newuserdata(L, sizeof(lua_gen_wrapped_UWORD_array_data_t));
  wrapper->data = array;
  wrapper->count = count;

  if (luaL_newmetatable(L, "UWORD_array_proxy")) {
    // Create method table
    lua_newtable(L);
    lua_pushcfunction(L, _lua_gen_wrapped_UWORD_array_ptr_method);
    lua_setfield(L, -2, "ptr");
    lua_setfield(L, -2, "__methods");

    // __index handles both numeric and method lookup
    lua_pushcfunction(L, _lua_gen_wrapped_UWORD_array_index);
    lua_setfield(L, -2, "__index");

    // __newindex for writing
    lua_pushcfunction(L, _lua_gen_wrapped_UWORD_array_newindex);
    lua_setfield(L, -2, "__newindex");
  }

  lua_setmetatable(L, -2);  // assign to userdata

}
static int
_lua_gen_RastPort_newindex(lua_State *L)
{
  struct RastPort *obj = *(struct RastPort **)luaL_checkudata(L, 1, "RastPort");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "Layer") == 0) {
    // finder 1
    //obj->Layer = *(struct Layer **)luaL_checkudata(L, 3, "Layer");
    obj->Layer = (struct Layer *)_lua_gen_checkLayer(L, 3);
    return 0;
  }
  if (strcmp(key, "BitMap") == 0) {
    // finder 1
    //obj->BitMap = *(struct BitMap **)luaL_checkudata(L, 3, "BitMap");
    obj->BitMap = (struct BitMap *)_lua_gen_checkBitMap(L, 3);
    return 0;
  }
  if (strcmp(key, "AreaPtrn") == 0) {
    obj->AreaPtrn = (UWORD *)lua_touserdata(L, 3);
    return 0;
  }
  // Unsupported type TmpRas struct TmpRas
  if (strcmp(key, "TmpRas") == 0) {
    return luaL_error(L, "Unsupported type struct TmpRas for field TmpRas");
  }
  // Unsupported type AreaInfo struct AreaInfo
  if (strcmp(key, "AreaInfo") == 0) {
    return luaL_error(L, "Unsupported type struct AreaInfo for field AreaInfo");
  }
  if (strcmp(key, "GelsInfo") == 0) {
    // finder 1
    //obj->GelsInfo = *(struct GelsInfo **)luaL_checkudata(L, 3, "GelsInfo");
    obj->GelsInfo = (struct GelsInfo *)_lua_gen_checkGelsInfo(L, 3);
    return 0;
  }
  if (strcmp(key, "Mask") == 0) {
    obj->Mask = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "FgPen") == 0) {
    obj->FgPen = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "BgPen") == 0) {
    obj->BgPen = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "AOlPen") == 0) {
    obj->AOlPen = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DrawMode") == 0) {
    obj->DrawMode = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "AreaPtSz") == 0) {
    obj->AreaPtSz = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "linpatcnt") == 0) {
    obj->linpatcnt = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "dummy") == 0) {
    obj->dummy = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Flags") == 0) {
    obj->Flags = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "LinePtrn") == 0) {
    obj->LinePtrn = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "cp_x") == 0) {
    obj->cp_x = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "cp_y") == 0) {
    obj->cp_y = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // minterms[8] proxied via the index
  if (strcmp(key, "PenWidth") == 0) {
    obj->PenWidth = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "PenHeight") == 0) {
    obj->PenHeight = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Font") == 0) {
    // finder 1
    //obj->Font = *(struct TextFont **)luaL_checkudata(L, 3, "TextFont");
    obj->Font = (struct TextFont *)_lua_gen_checkTextFont(L, 3);
    return 0;
  }
  if (strcmp(key, "AlgoStyle") == 0) {
    obj->AlgoStyle = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "TxFlags") == 0) {
    obj->TxFlags = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "TxHeight") == 0) {
    obj->TxHeight = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "TxWidth") == 0) {
    obj->TxWidth = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "TxBaseline") == 0) {
    obj->TxBaseline = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "TxSpacing") == 0) {
    obj->TxSpacing = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "RP_User") == 0) {
    obj->RP_User = (APTR *)lua_touserdata(L, 3);
    return 0;
  }
  // longreserved[2] proxied via the index
  // wordreserved[7] proxied via the index
  // reserved[8] proxied via the index
  return 0;
}


static int
_lua_RastPort_constructor(lua_State *L)
{
  // Allocate pointer-to-struct RastPort in userdata
  struct RastPort **objp = lua_newuserdata(L, sizeof(struct RastPort *));
  *objp = malloc(sizeof(struct RastPort));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct RastPort));

  // Set metatable
  luaL_getmetatable(L, "RastPort");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_RastPort_index(lua_State *L)
{
  struct RastPort *obj = *(struct RastPort **)luaL_checkudata(L, 1, "RastPort");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "Layer") == 0) {
    struct Layer **ud = (struct Layer **)lua_newuserdata(L, sizeof(struct Layer *));
    *ud = (struct Layer*)obj->Layer;
    luaL_getmetatable(L, "Layer");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "BitMap") == 0) {
    struct BitMap **ud = (struct BitMap **)lua_newuserdata(L, sizeof(struct BitMap *));
    *ud = (struct BitMap*)obj->BitMap;
    luaL_getmetatable(L, "BitMap");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "AreaPtrn") == 0) {
    lua_pushlightuserdata(L, obj->AreaPtrn);
    return 1;
  }
  // Unsupported TmpRas struct TmpRas *
  if (strcmp(key, "TmpRas") == 0) {
    return luaL_error(L, "Unsupported type struct TmpRas * for field TmpRas");
  }
  // Unsupported AreaInfo struct AreaInfo *
  if (strcmp(key, "AreaInfo") == 0) {
    return luaL_error(L, "Unsupported type struct AreaInfo * for field AreaInfo");
  }
  if (strcmp(key, "GelsInfo") == 0) {
    struct GelsInfo **ud = (struct GelsInfo **)lua_newuserdata(L, sizeof(struct GelsInfo *));
    *ud = (struct GelsInfo*)obj->GelsInfo;
    luaL_getmetatable(L, "GelsInfo");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "Mask") == 0) {
    lua_pushinteger(L, obj->Mask);
    return 1;
  }
  if (strcmp(key, "FgPen") == 0) {
    lua_pushinteger(L, obj->FgPen);
    return 1;
  }
  if (strcmp(key, "BgPen") == 0) {
    lua_pushinteger(L, obj->BgPen);
    return 1;
  }
  if (strcmp(key, "AOlPen") == 0) {
    lua_pushinteger(L, obj->AOlPen);
    return 1;
  }
  if (strcmp(key, "DrawMode") == 0) {
    lua_pushinteger(L, obj->DrawMode);
    return 1;
  }
  if (strcmp(key, "AreaPtSz") == 0) {
    lua_pushinteger(L, obj->AreaPtSz);
    return 1;
  }
  if (strcmp(key, "linpatcnt") == 0) {
    lua_pushinteger(L, obj->linpatcnt);
    return 1;
  }
  if (strcmp(key, "dummy") == 0) {
    lua_pushinteger(L, obj->dummy);
    return 1;
  }
  if (strcmp(key, "Flags") == 0) {
    lua_pushinteger(L, obj->Flags);
    return 1;
  }
  if (strcmp(key, "LinePtrn") == 0) {
    lua_pushinteger(L, obj->LinePtrn);
    return 1;
  }
  if (strcmp(key, "cp_x") == 0) {
    lua_pushinteger(L, obj->cp_x);
    return 1;
  }
  if (strcmp(key, "cp_y") == 0) {
    lua_pushinteger(L, obj->cp_y);
    return 1;
  }
  if (strcmp(key, "minterms") == 0) {
    _lua_gen_push_UBYTE_array_proxy(L, obj->minterms, 8);
    return 1;
  }
  if (strcmp(key, "PenWidth") == 0) {
    lua_pushinteger(L, obj->PenWidth);
    return 1;
  }
  if (strcmp(key, "PenHeight") == 0) {
    lua_pushinteger(L, obj->PenHeight);
    return 1;
  }
  if (strcmp(key, "Font") == 0) {
    struct TextFont **ud = (struct TextFont **)lua_newuserdata(L, sizeof(struct TextFont *));
    *ud = (struct TextFont*)obj->Font;
    luaL_getmetatable(L, "TextFont");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "AlgoStyle") == 0) {
    lua_pushinteger(L, obj->AlgoStyle);
    return 1;
  }
  if (strcmp(key, "TxFlags") == 0) {
    lua_pushinteger(L, obj->TxFlags);
    return 1;
  }
  if (strcmp(key, "TxHeight") == 0) {
    lua_pushinteger(L, obj->TxHeight);
    return 1;
  }
  if (strcmp(key, "TxWidth") == 0) {
    lua_pushinteger(L, obj->TxWidth);
    return 1;
  }
  if (strcmp(key, "TxBaseline") == 0) {
    lua_pushinteger(L, obj->TxBaseline);
    return 1;
  }
  if (strcmp(key, "TxSpacing") == 0) {
    lua_pushinteger(L, obj->TxSpacing);
    return 1;
  }
  if (strcmp(key, "RP_User") == 0) {
    lua_pushlightuserdata(L, obj->RP_User);
    return 1;
  }
  if (strcmp(key, "longreserved") == 0) {
    _lua_gen_push_ULONG_array_proxy(L, obj->longreserved, 2);
    return 1;
  }
  if (strcmp(key, "wordreserved") == 0) {
    _lua_gen_push_UWORD_array_proxy(L, obj->wordreserved, 7);
    return 1;
  }
  if (strcmp(key, "reserved") == 0) {
    _lua_gen_push_UBYTE_array_proxy(L, obj->reserved, 8);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct RastPort));
    return 1;
}

  return 0;
}

static void
_lua_gen_RastPort_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "AreaPtrn");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "Mask");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "FgPen");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "BgPen");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "AOlPen");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "DrawMode");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "AreaPtSz");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "linpatcnt");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "dummy");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "Flags");
  lua_rawseti(L, -2, 10);
  lua_pushstring(L, "LinePtrn");
  lua_rawseti(L, -2, 11);
  lua_pushstring(L, "cp_x");
  lua_rawseti(L, -2, 12);
  lua_pushstring(L, "cp_y");
  lua_rawseti(L, -2, 13);
  lua_pushstring(L, "minterms");
  lua_rawseti(L, -2, 14);
  lua_pushstring(L, "PenWidth");
  lua_rawseti(L, -2, 15);
  lua_pushstring(L, "PenHeight");
  lua_rawseti(L, -2, 16);
  lua_pushstring(L, "AlgoStyle");
  lua_rawseti(L, -2, 17);
  lua_pushstring(L, "TxFlags");
  lua_rawseti(L, -2, 18);
  lua_pushstring(L, "TxHeight");
  lua_rawseti(L, -2, 19);
  lua_pushstring(L, "TxWidth");
  lua_rawseti(L, -2, 20);
  lua_pushstring(L, "TxBaseline");
  lua_rawseti(L, -2, 21);
  lua_pushstring(L, "TxSpacing");
  lua_rawseti(L, -2, 22);
  lua_pushstring(L, "RP_User");
  lua_rawseti(L, -2, 23);
  lua_pushstring(L, "longreserved");
  lua_rawseti(L, -2, 24);
  lua_pushstring(L, "wordreserved");
  lua_rawseti(L, -2, 25);
  lua_pushstring(L, "reserved");
  lua_rawseti(L, -2, 26);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_RastPort(lua_State *L) {
  if (luaL_newmetatable(L, "RastPort")) {
    lua_pushcfunction(L, _lua_gen_RastPort_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_RastPort_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_RastPort_constructor);
    lua_setglobal(L, "RastPort");
    _lua_gen_RastPort_install_keys(L);
    lua_pushstring(L, "RastPort");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_Requester_newindex(lua_State *L)
{
  struct Requester *obj = *(struct Requester **)luaL_checkudata(L, 1, "Requester");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "OlderRequest") == 0) {
    // finder 1
    //obj->OlderRequest = *(struct Requester **)luaL_checkudata(L, 3, "Requester");
    obj->OlderRequest = (struct Requester *)_lua_gen_checkRequester(L, 3);
    return 0;
  }
  if (strcmp(key, "LeftEdge") == 0) {
    obj->LeftEdge = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "TopEdge") == 0) {
    obj->TopEdge = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Width") == 0) {
    obj->Width = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Height") == 0) {
    obj->Height = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "RelLeft") == 0) {
    obj->RelLeft = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "RelTop") == 0) {
    obj->RelTop = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ReqGadget") == 0) {
    // finder 1
    //obj->ReqGadget = *(struct Gadget **)luaL_checkudata(L, 3, "Gadget");
    obj->ReqGadget = (struct Gadget *)_lua_gen_checkGadget(L, 3);
    return 0;
  }
  if (strcmp(key, "ReqBorder") == 0) {
    // finder 1
    //obj->ReqBorder = *(struct Border **)luaL_checkudata(L, 3, "Border");
    obj->ReqBorder = (struct Border *)_lua_gen_checkBorder(L, 3);
    return 0;
  }
  if (strcmp(key, "ReqText") == 0) {
    // finder 1
    //obj->ReqText = *(struct IntuiText **)luaL_checkudata(L, 3, "IntuiText");
    obj->ReqText = (struct IntuiText *)_lua_gen_checkIntuiText(L, 3);
    return 0;
  }
  if (strcmp(key, "Flags") == 0) {
    obj->Flags = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "BackFill") == 0) {
    obj->BackFill = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ReqLayer") == 0) {
    // finder 1
    //obj->ReqLayer = *(struct Layer **)luaL_checkudata(L, 3, "Layer");
    obj->ReqLayer = (struct Layer *)_lua_gen_checkLayer(L, 3);
    return 0;
  }
  // ReqPad1[32] proxied via the index
  if (strcmp(key, "ImageBMap") == 0) {
    // finder 1
    //obj->ImageBMap = *(struct BitMap **)luaL_checkudata(L, 3, "BitMap");
    obj->ImageBMap = (struct BitMap *)_lua_gen_checkBitMap(L, 3);
    return 0;
  }
  if (strcmp(key, "RWindow") == 0) {
    // finder 1
    //obj->RWindow = *(struct Window **)luaL_checkudata(L, 3, "Window");
    obj->RWindow = (struct Window *)_lua_gen_checkWindow(L, 3);
    return 0;
  }
  if (strcmp(key, "ReqImage") == 0) {
    // finder 1
    //obj->ReqImage = *(struct Image **)luaL_checkudata(L, 3, "Image");
    obj->ReqImage = (struct Image *)_lua_gen_checkImage(L, 3);
    return 0;
  }
  // ReqPad2[32] proxied via the index
  return 0;
}


static int
_lua_Requester_constructor(lua_State *L)
{
  // Allocate pointer-to-struct Requester in userdata
  struct Requester **objp = lua_newuserdata(L, sizeof(struct Requester *));
  *objp = malloc(sizeof(struct Requester));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct Requester));

  // Set metatable
  luaL_getmetatable(L, "Requester");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_Requester_index(lua_State *L)
{
  struct Requester *obj = *(struct Requester **)luaL_checkudata(L, 1, "Requester");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "OlderRequest") == 0) {
    struct Requester **ud = (struct Requester **)lua_newuserdata(L, sizeof(struct Requester *));
    *ud = (struct Requester*)obj->OlderRequest;
    luaL_getmetatable(L, "Requester");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "LeftEdge") == 0) {
    lua_pushinteger(L, obj->LeftEdge);
    return 1;
  }
  if (strcmp(key, "TopEdge") == 0) {
    lua_pushinteger(L, obj->TopEdge);
    return 1;
  }
  if (strcmp(key, "Width") == 0) {
    lua_pushinteger(L, obj->Width);
    return 1;
  }
  if (strcmp(key, "Height") == 0) {
    lua_pushinteger(L, obj->Height);
    return 1;
  }
  if (strcmp(key, "RelLeft") == 0) {
    lua_pushinteger(L, obj->RelLeft);
    return 1;
  }
  if (strcmp(key, "RelTop") == 0) {
    lua_pushinteger(L, obj->RelTop);
    return 1;
  }
  if (strcmp(key, "ReqGadget") == 0) {
    struct Gadget **ud = (struct Gadget **)lua_newuserdata(L, sizeof(struct Gadget *));
    *ud = (struct Gadget*)obj->ReqGadget;
    luaL_getmetatable(L, "Gadget");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "ReqBorder") == 0) {
    struct Border **ud = (struct Border **)lua_newuserdata(L, sizeof(struct Border *));
    *ud = (struct Border*)obj->ReqBorder;
    luaL_getmetatable(L, "Border");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "ReqText") == 0) {
    struct IntuiText **ud = (struct IntuiText **)lua_newuserdata(L, sizeof(struct IntuiText *));
    *ud = (struct IntuiText*)obj->ReqText;
    luaL_getmetatable(L, "IntuiText");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "Flags") == 0) {
    lua_pushinteger(L, obj->Flags);
    return 1;
  }
  if (strcmp(key, "BackFill") == 0) {
    lua_pushinteger(L, obj->BackFill);
    return 1;
  }
  if (strcmp(key, "ReqLayer") == 0) {
    struct Layer **ud = (struct Layer **)lua_newuserdata(L, sizeof(struct Layer *));
    *ud = (struct Layer*)obj->ReqLayer;
    luaL_getmetatable(L, "Layer");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "ReqPad1") == 0) {
    _lua_gen_push_UBYTE_array_proxy(L, obj->ReqPad1, 32);
    return 1;
  }
  if (strcmp(key, "ImageBMap") == 0) {
    struct BitMap **ud = (struct BitMap **)lua_newuserdata(L, sizeof(struct BitMap *));
    *ud = (struct BitMap*)obj->ImageBMap;
    luaL_getmetatable(L, "BitMap");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "RWindow") == 0) {
    struct Window **ud = (struct Window **)lua_newuserdata(L, sizeof(struct Window *));
    *ud = (struct Window*)obj->RWindow;
    luaL_getmetatable(L, "Window");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "ReqImage") == 0) {
    struct Image **ud = (struct Image **)lua_newuserdata(L, sizeof(struct Image *));
    *ud = (struct Image*)obj->ReqImage;
    luaL_getmetatable(L, "Image");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "ReqPad2") == 0) {
    _lua_gen_push_UBYTE_array_proxy(L, obj->ReqPad2, 32);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct Requester));
    return 1;
}

  return 0;
}

static void
_lua_gen_Requester_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "LeftEdge");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "TopEdge");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "Width");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "Height");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "RelLeft");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "RelTop");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "Flags");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "BackFill");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "ReqPad1");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "ReqPad2");
  lua_rawseti(L, -2, 10);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_Requester(lua_State *L) {
  if (luaL_newmetatable(L, "Requester")) {
    lua_pushcfunction(L, _lua_gen_Requester_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_Requester_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_Requester_constructor);
    lua_setglobal(L, "Requester");
    _lua_gen_Requester_install_keys(L);
    lua_pushstring(L, "Requester");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_Screen_newindex(lua_State *L)
{
  struct Screen *obj = *(struct Screen **)luaL_checkudata(L, 1, "Screen");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "NextScreen") == 0) {
    // finder 1
    //obj->NextScreen = *(struct Screen **)luaL_checkudata(L, 3, "Screen");
    obj->NextScreen = (struct Screen *)_lua_gen_checkScreen(L, 3);
    return 0;
  }
  if (strcmp(key, "FirstWindow") == 0) {
    // finder 1
    //obj->FirstWindow = *(struct Window **)luaL_checkudata(L, 3, "Window");
    obj->FirstWindow = (struct Window *)_lua_gen_checkWindow(L, 3);
    return 0;
  }
  if (strcmp(key, "LeftEdge") == 0) {
    obj->LeftEdge = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "TopEdge") == 0) {
    obj->TopEdge = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Width") == 0) {
    obj->Width = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Height") == 0) {
    obj->Height = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "MouseY") == 0) {
    obj->MouseY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "MouseX") == 0) {
    obj->MouseX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Flags") == 0) {
    obj->Flags = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Title") == 0) {
    obj->Title = (STRPTR)amiga_checkNullableString(L, 3);
    return 0;
  }
  if (strcmp(key, "DefaultTitle") == 0) {
    obj->DefaultTitle = (STRPTR)amiga_checkNullableString(L, 3);
    return 0;
  }
  if (strcmp(key, "BarHeight") == 0) {
    obj->BarHeight = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "BarVBorder") == 0) {
    obj->BarVBorder = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "BarHBorder") == 0) {
    obj->BarHBorder = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "MenuVBorder") == 0) {
    obj->MenuVBorder = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "MenuHBorder") == 0) {
    obj->MenuHBorder = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "WBorTop") == 0) {
    obj->WBorTop = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "WBorLeft") == 0) {
    obj->WBorLeft = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "WBorRight") == 0) {
    obj->WBorRight = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "WBorBottom") == 0) {
    obj->WBorBottom = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Font") == 0) {
    // finder 1
    //obj->Font = *(struct TextAttr **)luaL_checkudata(L, 3, "TextAttr");
    obj->Font = (struct TextAttr *)_lua_gen_checkTextAttr(L, 3);
    return 0;
  }
  if (strcmp(key, "ViewPort.Next") == 0) {
    // finder 1
    //obj->ViewPort.Next = *(struct ViewPort **)luaL_checkudata(L, 3, "ViewPort");
    obj->ViewPort.Next = (struct ViewPort *)_lua_gen_checkViewPort(L, 3);
    return 0;
  }
  if (strcmp(key, "ViewPort.ColorMap") == 0) {
    // finder 1
    //obj->ViewPort.ColorMap = *(struct ColorMap **)luaL_checkudata(L, 3, "ColorMap");
    obj->ViewPort.ColorMap = (struct ColorMap *)_lua_gen_checkColorMap(L, 3);
    return 0;
  }
  // Unsupported type ViewPort.DspIns struct CopList
  if (strcmp(key, "ViewPort.DspIns") == 0) {
    return luaL_error(L, "Unsupported type struct CopList for field ViewPort.DspIns");
  }
  // Unsupported type ViewPort.SprIns struct CopList
  if (strcmp(key, "ViewPort.SprIns") == 0) {
    return luaL_error(L, "Unsupported type struct CopList for field ViewPort.SprIns");
  }
  // Unsupported type ViewPort.ClrIns struct CopList
  if (strcmp(key, "ViewPort.ClrIns") == 0) {
    return luaL_error(L, "Unsupported type struct CopList for field ViewPort.ClrIns");
  }
  if (strcmp(key, "ViewPort.UCopIns") == 0) {
    obj->ViewPort.UCopIns = (struct UCopList *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "ViewPort.DWidth") == 0) {
    obj->ViewPort.DWidth = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ViewPort.DHeight") == 0) {
    obj->ViewPort.DHeight = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ViewPort.DxOffset") == 0) {
    obj->ViewPort.DxOffset = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ViewPort.DyOffset") == 0) {
    obj->ViewPort.DyOffset = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ViewPort.Modes") == 0) {
    obj->ViewPort.Modes = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ViewPort.SpritePriorities") == 0) {
    obj->ViewPort.SpritePriorities = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ViewPort.ExtendedModes") == 0) {
    obj->ViewPort.ExtendedModes = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ViewPort.RasInfo") == 0) {
    // finder 1
    //obj->ViewPort.RasInfo = *(struct RasInfo **)luaL_checkudata(L, 3, "RasInfo");
    obj->ViewPort.RasInfo = (struct RasInfo *)_lua_gen_checkRasInfo(L, 3);
    return 0;
  }
  if (strcmp(key, "ViewPort") == 0) {
    // finder 0
    struct ViewPort *val = *(struct ViewPort **)luaL_checkudata(L, 3, "ViewPort");
    obj->ViewPort = *val;
    return 0;
  }
  if (strcmp(key, "RastPort.Layer") == 0) {
    // finder 1
    //obj->RastPort.Layer = *(struct Layer **)luaL_checkudata(L, 3, "Layer");
    obj->RastPort.Layer = (struct Layer *)_lua_gen_checkLayer(L, 3);
    return 0;
  }
  if (strcmp(key, "RastPort.BitMap") == 0) {
    // finder 1
    //obj->RastPort.BitMap = *(struct BitMap **)luaL_checkudata(L, 3, "BitMap");
    obj->RastPort.BitMap = (struct BitMap *)_lua_gen_checkBitMap(L, 3);
    return 0;
  }
  if (strcmp(key, "RastPort.AreaPtrn") == 0) {
    obj->RastPort.AreaPtrn = (UWORD *)lua_touserdata(L, 3);
    return 0;
  }
  // Unsupported type RastPort.TmpRas struct TmpRas
  if (strcmp(key, "RastPort.TmpRas") == 0) {
    return luaL_error(L, "Unsupported type struct TmpRas for field RastPort.TmpRas");
  }
  // Unsupported type RastPort.AreaInfo struct AreaInfo
  if (strcmp(key, "RastPort.AreaInfo") == 0) {
    return luaL_error(L, "Unsupported type struct AreaInfo for field RastPort.AreaInfo");
  }
  if (strcmp(key, "RastPort.GelsInfo") == 0) {
    // finder 1
    //obj->RastPort.GelsInfo = *(struct GelsInfo **)luaL_checkudata(L, 3, "GelsInfo");
    obj->RastPort.GelsInfo = (struct GelsInfo *)_lua_gen_checkGelsInfo(L, 3);
    return 0;
  }
  if (strcmp(key, "RastPort.Mask") == 0) {
    obj->RastPort.Mask = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "RastPort.FgPen") == 0) {
    obj->RastPort.FgPen = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "RastPort.BgPen") == 0) {
    obj->RastPort.BgPen = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "RastPort.AOlPen") == 0) {
    obj->RastPort.AOlPen = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "RastPort.DrawMode") == 0) {
    obj->RastPort.DrawMode = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "RastPort.AreaPtSz") == 0) {
    obj->RastPort.AreaPtSz = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "RastPort.linpatcnt") == 0) {
    obj->RastPort.linpatcnt = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "RastPort.dummy") == 0) {
    obj->RastPort.dummy = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "RastPort.Flags") == 0) {
    obj->RastPort.Flags = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "RastPort.LinePtrn") == 0) {
    obj->RastPort.LinePtrn = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "RastPort.cp_x") == 0) {
    obj->RastPort.cp_x = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "RastPort.cp_y") == 0) {
    obj->RastPort.cp_y = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // RastPort.minterms[8] proxied via the index
  if (strcmp(key, "RastPort.PenWidth") == 0) {
    obj->RastPort.PenWidth = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "RastPort.PenHeight") == 0) {
    obj->RastPort.PenHeight = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "RastPort.Font") == 0) {
    // finder 1
    //obj->RastPort.Font = *(struct TextFont **)luaL_checkudata(L, 3, "TextFont");
    obj->RastPort.Font = (struct TextFont *)_lua_gen_checkTextFont(L, 3);
    return 0;
  }
  if (strcmp(key, "RastPort.AlgoStyle") == 0) {
    obj->RastPort.AlgoStyle = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "RastPort.TxFlags") == 0) {
    obj->RastPort.TxFlags = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "RastPort.TxHeight") == 0) {
    obj->RastPort.TxHeight = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "RastPort.TxWidth") == 0) {
    obj->RastPort.TxWidth = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "RastPort.TxBaseline") == 0) {
    obj->RastPort.TxBaseline = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "RastPort.TxSpacing") == 0) {
    obj->RastPort.TxSpacing = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "RastPort.RP_User") == 0) {
    obj->RastPort.RP_User = (APTR *)lua_touserdata(L, 3);
    return 0;
  }
  // RastPort.longreserved[2] proxied via the index
  // RastPort.wordreserved[7] proxied via the index
  // RastPort.reserved[8] proxied via the index
  if (strcmp(key, "RastPort") == 0) {
    // finder 0
    struct RastPort *val = *(struct RastPort **)luaL_checkudata(L, 3, "RastPort");
    obj->RastPort = *val;
    return 0;
  }
  if (strcmp(key, "BitMap.BytesPerRow") == 0) {
    obj->BitMap.BytesPerRow = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "BitMap.Rows") == 0) {
    obj->BitMap.Rows = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "BitMap.Flags") == 0) {
    obj->BitMap.Flags = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "BitMap.Depth") == 0) {
    obj->BitMap.Depth = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "BitMap.pad") == 0) {
    obj->BitMap.pad = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // BitMap.Planes[8] proxied via the index
  if (strcmp(key, "BitMap") == 0) {
    // finder 0
    struct BitMap *val = *(struct BitMap **)luaL_checkudata(L, 3, "BitMap");
    obj->BitMap = *val;
    return 0;
  }
  if (strcmp(key, "LayerInfo.top_layer") == 0) {
    // finder 1
    //obj->LayerInfo.top_layer = *(struct Layer **)luaL_checkudata(L, 3, "Layer");
    obj->LayerInfo.top_layer = (struct Layer *)_lua_gen_checkLayer(L, 3);
    return 0;
  }
  if (strcmp(key, "LayerInfo.resPtr1") == 0) {
    obj->LayerInfo.resPtr1 = (void *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "LayerInfo.resPtr2") == 0) {
    obj->LayerInfo.resPtr2 = (void *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "LayerInfo.FreeClipRects") == 0) {
    // finder 1
    //obj->LayerInfo.FreeClipRects = *(struct ClipRect **)luaL_checkudata(L, 3, "ClipRect");
    obj->LayerInfo.FreeClipRects = (struct ClipRect *)_lua_gen_checkClipRect(L, 3);
    return 0;
  }
  if (strcmp(key, "LayerInfo.bounds.MinX") == 0) {
    obj->LayerInfo.bounds.MinX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "LayerInfo.bounds.MinY") == 0) {
    obj->LayerInfo.bounds.MinY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "LayerInfo.bounds.MaxX") == 0) {
    obj->LayerInfo.bounds.MaxX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "LayerInfo.bounds.MaxY") == 0) {
    obj->LayerInfo.bounds.MaxY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type LayerInfo.bounds struct Rectangle
  if (strcmp(key, "LayerInfo.bounds") == 0) {
    return luaL_error(L, "Unsupported type struct Rectangle for field LayerInfo.bounds");
  }
  // Unsupported type LayerInfo.Lock.ss_Link.ln_Succ struct Node
  if (strcmp(key, "LayerInfo.Lock.ss_Link.ln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field LayerInfo.Lock.ss_Link.ln_Succ");
  }
  // Unsupported type LayerInfo.Lock.ss_Link.ln_Pred struct Node
  if (strcmp(key, "LayerInfo.Lock.ss_Link.ln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field LayerInfo.Lock.ss_Link.ln_Pred");
  }
  if (strcmp(key, "LayerInfo.Lock.ss_Link.ln_Type") == 0) {
    obj->LayerInfo.Lock.ss_Link.ln_Type = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "LayerInfo.Lock.ss_Link.ln_Pri") == 0) {
    obj->LayerInfo.Lock.ss_Link.ln_Pri = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "LayerInfo.Lock.ss_Link.ln_Name") == 0) {
    obj->LayerInfo.Lock.ss_Link.ln_Name = (char *)luaL_checkstring(L, 3);
    return 0;
  }
  // Unsupported type LayerInfo.Lock.ss_Link struct Node
  if (strcmp(key, "LayerInfo.Lock.ss_Link") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field LayerInfo.Lock.ss_Link");
  }
  if (strcmp(key, "LayerInfo.Lock.ss_NestCount") == 0) {
    obj->LayerInfo.Lock.ss_NestCount = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "LayerInfo.Lock.ss_WaitQueue.mlh_Head") == 0) {
    // finder 1
    //obj->LayerInfo.Lock.ss_WaitQueue.mlh_Head = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->LayerInfo.Lock.ss_WaitQueue.mlh_Head = (struct MinNode *)_lua_gen_checkMinNode(L, 3);
    return 0;
  }
  if (strcmp(key, "LayerInfo.Lock.ss_WaitQueue.mlh_Tail") == 0) {
    // finder 1
    //obj->LayerInfo.Lock.ss_WaitQueue.mlh_Tail = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->LayerInfo.Lock.ss_WaitQueue.mlh_Tail = (struct MinNode *)_lua_gen_checkMinNode(L, 3);
    return 0;
  }
  if (strcmp(key, "LayerInfo.Lock.ss_WaitQueue.mlh_TailPred") == 0) {
    // finder 1
    //obj->LayerInfo.Lock.ss_WaitQueue.mlh_TailPred = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->LayerInfo.Lock.ss_WaitQueue.mlh_TailPred = (struct MinNode *)_lua_gen_checkMinNode(L, 3);
    return 0;
  }
  // Unsupported type LayerInfo.Lock.ss_WaitQueue struct MinList
  if (strcmp(key, "LayerInfo.Lock.ss_WaitQueue") == 0) {
    return luaL_error(L, "Unsupported type struct MinList for field LayerInfo.Lock.ss_WaitQueue");
  }
  if (strcmp(key, "LayerInfo.Lock.ss_MultipleLink.sr_Link.mln_Succ") == 0) {
    // finder 1
    //obj->LayerInfo.Lock.ss_MultipleLink.sr_Link.mln_Succ = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->LayerInfo.Lock.ss_MultipleLink.sr_Link.mln_Succ = (struct MinNode *)_lua_gen_checkMinNode(L, 3);
    return 0;
  }
  if (strcmp(key, "LayerInfo.Lock.ss_MultipleLink.sr_Link.mln_Pred") == 0) {
    // finder 1
    //obj->LayerInfo.Lock.ss_MultipleLink.sr_Link.mln_Pred = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->LayerInfo.Lock.ss_MultipleLink.sr_Link.mln_Pred = (struct MinNode *)_lua_gen_checkMinNode(L, 3);
    return 0;
  }
  if (strcmp(key, "LayerInfo.Lock.ss_MultipleLink.sr_Link") == 0) {
    // finder 0
    struct MinNode *val = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->LayerInfo.Lock.ss_MultipleLink.sr_Link = *val;
    return 0;
  }
  // Unsupported type LayerInfo.Lock.ss_MultipleLink.sr_Waiter struct Task
  if (strcmp(key, "LayerInfo.Lock.ss_MultipleLink.sr_Waiter") == 0) {
    return luaL_error(L, "Unsupported type struct Task for field LayerInfo.Lock.ss_MultipleLink.sr_Waiter");
  }
  // Unsupported type LayerInfo.Lock.ss_MultipleLink struct SemaphoreRequest
  if (strcmp(key, "LayerInfo.Lock.ss_MultipleLink") == 0) {
    return luaL_error(L, "Unsupported type struct SemaphoreRequest for field LayerInfo.Lock.ss_MultipleLink");
  }
  // Unsupported type LayerInfo.Lock.ss_Owner struct Task
  if (strcmp(key, "LayerInfo.Lock.ss_Owner") == 0) {
    return luaL_error(L, "Unsupported type struct Task for field LayerInfo.Lock.ss_Owner");
  }
  if (strcmp(key, "LayerInfo.Lock.ss_QueueCount") == 0) {
    obj->LayerInfo.Lock.ss_QueueCount = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  // Unsupported type LayerInfo.Lock struct SignalSemaphore
  if (strcmp(key, "LayerInfo.Lock") == 0) {
    return luaL_error(L, "Unsupported type struct SignalSemaphore for field LayerInfo.Lock");
  }
  if (strcmp(key, "LayerInfo.gs_Head.mlh_Head") == 0) {
    // finder 1
    //obj->LayerInfo.gs_Head.mlh_Head = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->LayerInfo.gs_Head.mlh_Head = (struct MinNode *)_lua_gen_checkMinNode(L, 3);
    return 0;
  }
  if (strcmp(key, "LayerInfo.gs_Head.mlh_Tail") == 0) {
    // finder 1
    //obj->LayerInfo.gs_Head.mlh_Tail = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->LayerInfo.gs_Head.mlh_Tail = (struct MinNode *)_lua_gen_checkMinNode(L, 3);
    return 0;
  }
  if (strcmp(key, "LayerInfo.gs_Head.mlh_TailPred") == 0) {
    // finder 1
    //obj->LayerInfo.gs_Head.mlh_TailPred = *(struct MinNode **)luaL_checkudata(L, 3, "MinNode");
    obj->LayerInfo.gs_Head.mlh_TailPred = (struct MinNode *)_lua_gen_checkMinNode(L, 3);
    return 0;
  }
  // Unsupported type LayerInfo.gs_Head struct MinList
  if (strcmp(key, "LayerInfo.gs_Head") == 0) {
    return luaL_error(L, "Unsupported type struct MinList for field LayerInfo.gs_Head");
  }
  if (strcmp(key, "LayerInfo.PrivateReserve3") == 0) {
    obj->LayerInfo.PrivateReserve3 = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "LayerInfo.PrivateReserve4") == 0) {
    obj->LayerInfo.PrivateReserve4 = (void *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "LayerInfo.Flags") == 0) {
    obj->LayerInfo.Flags = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "LayerInfo.res_count") == 0) {
    obj->LayerInfo.res_count = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "LayerInfo.LockLayersCount") == 0) {
    obj->LayerInfo.LockLayersCount = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "LayerInfo.PrivateReserve5") == 0) {
    obj->LayerInfo.PrivateReserve5 = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "LayerInfo.UserClipRectsCount") == 0) {
    obj->LayerInfo.UserClipRectsCount = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "LayerInfo.BlankHook") == 0) {
    // finder 1
    //obj->LayerInfo.BlankHook = *(struct Hook **)luaL_checkudata(L, 3, "Hook");
    obj->LayerInfo.BlankHook = (struct Hook *)_lua_gen_checkHook(L, 3);
    return 0;
  }
  if (strcmp(key, "LayerInfo.resPtr5") == 0) {
    obj->LayerInfo.resPtr5 = (void *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "LayerInfo") == 0) {
    // finder 0
    struct Layer_Info *val = *(struct Layer_Info **)luaL_checkudata(L, 3, "Layer_Info");
    obj->LayerInfo = *val;
    return 0;
  }
  if (strcmp(key, "FirstGadget") == 0) {
    // finder 1
    //obj->FirstGadget = *(struct Gadget **)luaL_checkudata(L, 3, "Gadget");
    obj->FirstGadget = (struct Gadget *)_lua_gen_checkGadget(L, 3);
    return 0;
  }
  if (strcmp(key, "DetailPen") == 0) {
    obj->DetailPen = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "BlockPen") == 0) {
    obj->BlockPen = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "SaveColor0") == 0) {
    obj->SaveColor0 = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "BarLayer") == 0) {
    // finder 1
    //obj->BarLayer = *(struct Layer **)luaL_checkudata(L, 3, "Layer");
    obj->BarLayer = (struct Layer *)_lua_gen_checkLayer(L, 3);
    return 0;
  }
  if (strcmp(key, "ExtData") == 0) {
    obj->ExtData = (UBYTE *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "UserData") == 0) {
    obj->UserData = (UBYTE *)lua_touserdata(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_Screen_constructor(lua_State *L)
{
  // Allocate pointer-to-struct Screen in userdata
  struct Screen **objp = lua_newuserdata(L, sizeof(struct Screen *));
  *objp = malloc(sizeof(struct Screen));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct Screen));

  // Set metatable
  luaL_getmetatable(L, "Screen");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_Screen_index(lua_State *L)
{
  struct Screen *obj = *(struct Screen **)luaL_checkudata(L, 1, "Screen");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "NextScreen") == 0) {
    struct Screen **ud = (struct Screen **)lua_newuserdata(L, sizeof(struct Screen *));
    *ud = (struct Screen*)obj->NextScreen;
    luaL_getmetatable(L, "Screen");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "FirstWindow") == 0) {
    struct Window **ud = (struct Window **)lua_newuserdata(L, sizeof(struct Window *));
    *ud = (struct Window*)obj->FirstWindow;
    luaL_getmetatable(L, "Window");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "LeftEdge") == 0) {
    lua_pushinteger(L, obj->LeftEdge);
    return 1;
  }
  if (strcmp(key, "TopEdge") == 0) {
    lua_pushinteger(L, obj->TopEdge);
    return 1;
  }
  if (strcmp(key, "Width") == 0) {
    lua_pushinteger(L, obj->Width);
    return 1;
  }
  if (strcmp(key, "Height") == 0) {
    lua_pushinteger(L, obj->Height);
    return 1;
  }
  if (strcmp(key, "MouseY") == 0) {
    lua_pushinteger(L, obj->MouseY);
    return 1;
  }
  if (strcmp(key, "MouseX") == 0) {
    lua_pushinteger(L, obj->MouseX);
    return 1;
  }
  if (strcmp(key, "Flags") == 0) {
    lua_pushinteger(L, obj->Flags);
    return 1;
  }
  if (strcmp(key, "Title") == 0) {
    lua_pushstring(L, obj->Title);
    return 1;
  }
  if (strcmp(key, "DefaultTitle") == 0) {
    lua_pushstring(L, obj->DefaultTitle);
    return 1;
  }
  if (strcmp(key, "BarHeight") == 0) {
    lua_pushinteger(L, obj->BarHeight);
    return 1;
  }
  if (strcmp(key, "BarVBorder") == 0) {
    lua_pushinteger(L, obj->BarVBorder);
    return 1;
  }
  if (strcmp(key, "BarHBorder") == 0) {
    lua_pushinteger(L, obj->BarHBorder);
    return 1;
  }
  if (strcmp(key, "MenuVBorder") == 0) {
    lua_pushinteger(L, obj->MenuVBorder);
    return 1;
  }
  if (strcmp(key, "MenuHBorder") == 0) {
    lua_pushinteger(L, obj->MenuHBorder);
    return 1;
  }
  if (strcmp(key, "WBorTop") == 0) {
    lua_pushinteger(L, obj->WBorTop);
    return 1;
  }
  if (strcmp(key, "WBorLeft") == 0) {
    lua_pushinteger(L, obj->WBorLeft);
    return 1;
  }
  if (strcmp(key, "WBorRight") == 0) {
    lua_pushinteger(L, obj->WBorRight);
    return 1;
  }
  if (strcmp(key, "WBorBottom") == 0) {
    lua_pushinteger(L, obj->WBorBottom);
    return 1;
  }
  if (strcmp(key, "Font") == 0) {
    struct TextAttr **ud = (struct TextAttr **)lua_newuserdata(L, sizeof(struct TextAttr *));
    *ud = (struct TextAttr*)obj->Font;
    luaL_getmetatable(L, "TextAttr");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "ViewPort.Next") == 0) {
    struct ViewPort **ud = (struct ViewPort **)lua_newuserdata(L, sizeof(struct ViewPort *));
    *ud = (struct ViewPort*)obj->ViewPort.Next;
    luaL_getmetatable(L, "ViewPort");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "ViewPort.ColorMap") == 0) {
    struct ColorMap **ud = (struct ColorMap **)lua_newuserdata(L, sizeof(struct ColorMap *));
    *ud = (struct ColorMap*)obj->ViewPort.ColorMap;
    luaL_getmetatable(L, "ColorMap");
    lua_setmetatable(L, -2);
    return 1;
  }
  // Unsupported ViewPort.DspIns struct CopList *
  if (strcmp(key, "ViewPort.DspIns") == 0) {
    return luaL_error(L, "Unsupported type struct CopList * for field ViewPort.DspIns");
  }
  // Unsupported ViewPort.SprIns struct CopList *
  if (strcmp(key, "ViewPort.SprIns") == 0) {
    return luaL_error(L, "Unsupported type struct CopList * for field ViewPort.SprIns");
  }
  // Unsupported ViewPort.ClrIns struct CopList *
  if (strcmp(key, "ViewPort.ClrIns") == 0) {
    return luaL_error(L, "Unsupported type struct CopList * for field ViewPort.ClrIns");
  }
  if (strcmp(key, "ViewPort.UCopIns") == 0) {
    lua_pushlightuserdata(L, obj->ViewPort.UCopIns);
    return 1;
  }
  if (strcmp(key, "ViewPort.DWidth") == 0) {
    lua_pushinteger(L, obj->ViewPort.DWidth);
    return 1;
  }
  if (strcmp(key, "ViewPort.DHeight") == 0) {
    lua_pushinteger(L, obj->ViewPort.DHeight);
    return 1;
  }
  if (strcmp(key, "ViewPort.DxOffset") == 0) {
    lua_pushinteger(L, obj->ViewPort.DxOffset);
    return 1;
  }
  if (strcmp(key, "ViewPort.DyOffset") == 0) {
    lua_pushinteger(L, obj->ViewPort.DyOffset);
    return 1;
  }
  if (strcmp(key, "ViewPort.Modes") == 0) {
    lua_pushinteger(L, obj->ViewPort.Modes);
    return 1;
  }
  if (strcmp(key, "ViewPort.SpritePriorities") == 0) {
    lua_pushinteger(L, obj->ViewPort.SpritePriorities);
    return 1;
  }
  if (strcmp(key, "ViewPort.ExtendedModes") == 0) {
    lua_pushinteger(L, obj->ViewPort.ExtendedModes);
    return 1;
  }
  if (strcmp(key, "ViewPort.RasInfo") == 0) {
    struct RasInfo **ud = (struct RasInfo **)lua_newuserdata(L, sizeof(struct RasInfo *));
    *ud = (struct RasInfo*)obj->ViewPort.RasInfo;
    luaL_getmetatable(L, "RasInfo");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "ViewPort") == 0) {
    struct ViewPort **ud = (struct ViewPort **)lua_newuserdata(L, sizeof(struct ViewPort *));
    *ud = (struct ViewPort*)&obj->ViewPort;
    luaL_getmetatable(L, "ViewPort");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "RastPort.Layer") == 0) {
    struct Layer **ud = (struct Layer **)lua_newuserdata(L, sizeof(struct Layer *));
    *ud = (struct Layer*)obj->RastPort.Layer;
    luaL_getmetatable(L, "Layer");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "RastPort.BitMap") == 0) {
    struct BitMap **ud = (struct BitMap **)lua_newuserdata(L, sizeof(struct BitMap *));
    *ud = (struct BitMap*)obj->RastPort.BitMap;
    luaL_getmetatable(L, "BitMap");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "RastPort.AreaPtrn") == 0) {
    lua_pushlightuserdata(L, obj->RastPort.AreaPtrn);
    return 1;
  }
  // Unsupported RastPort.TmpRas struct TmpRas *
  if (strcmp(key, "RastPort.TmpRas") == 0) {
    return luaL_error(L, "Unsupported type struct TmpRas * for field RastPort.TmpRas");
  }
  // Unsupported RastPort.AreaInfo struct AreaInfo *
  if (strcmp(key, "RastPort.AreaInfo") == 0) {
    return luaL_error(L, "Unsupported type struct AreaInfo * for field RastPort.AreaInfo");
  }
  if (strcmp(key, "RastPort.GelsInfo") == 0) {
    struct GelsInfo **ud = (struct GelsInfo **)lua_newuserdata(L, sizeof(struct GelsInfo *));
    *ud = (struct GelsInfo*)obj->RastPort.GelsInfo;
    luaL_getmetatable(L, "GelsInfo");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "RastPort.Mask") == 0) {
    lua_pushinteger(L, obj->RastPort.Mask);
    return 1;
  }
  if (strcmp(key, "RastPort.FgPen") == 0) {
    lua_pushinteger(L, obj->RastPort.FgPen);
    return 1;
  }
  if (strcmp(key, "RastPort.BgPen") == 0) {
    lua_pushinteger(L, obj->RastPort.BgPen);
    return 1;
  }
  if (strcmp(key, "RastPort.AOlPen") == 0) {
    lua_pushinteger(L, obj->RastPort.AOlPen);
    return 1;
  }
  if (strcmp(key, "RastPort.DrawMode") == 0) {
    lua_pushinteger(L, obj->RastPort.DrawMode);
    return 1;
  }
  if (strcmp(key, "RastPort.AreaPtSz") == 0) {
    lua_pushinteger(L, obj->RastPort.AreaPtSz);
    return 1;
  }
  if (strcmp(key, "RastPort.linpatcnt") == 0) {
    lua_pushinteger(L, obj->RastPort.linpatcnt);
    return 1;
  }
  if (strcmp(key, "RastPort.dummy") == 0) {
    lua_pushinteger(L, obj->RastPort.dummy);
    return 1;
  }
  if (strcmp(key, "RastPort.Flags") == 0) {
    lua_pushinteger(L, obj->RastPort.Flags);
    return 1;
  }
  if (strcmp(key, "RastPort.LinePtrn") == 0) {
    lua_pushinteger(L, obj->RastPort.LinePtrn);
    return 1;
  }
  if (strcmp(key, "RastPort.cp_x") == 0) {
    lua_pushinteger(L, obj->RastPort.cp_x);
    return 1;
  }
  if (strcmp(key, "RastPort.cp_y") == 0) {
    lua_pushinteger(L, obj->RastPort.cp_y);
    return 1;
  }
  if (strcmp(key, "RastPort.minterms") == 0) {
    _lua_gen_push_UBYTE_array_proxy(L, obj->RastPort.minterms, 8);
    return 1;
  }
  if (strcmp(key, "RastPort.PenWidth") == 0) {
    lua_pushinteger(L, obj->RastPort.PenWidth);
    return 1;
  }
  if (strcmp(key, "RastPort.PenHeight") == 0) {
    lua_pushinteger(L, obj->RastPort.PenHeight);
    return 1;
  }
  if (strcmp(key, "RastPort.Font") == 0) {
    struct TextFont **ud = (struct TextFont **)lua_newuserdata(L, sizeof(struct TextFont *));
    *ud = (struct TextFont*)obj->RastPort.Font;
    luaL_getmetatable(L, "TextFont");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "RastPort.AlgoStyle") == 0) {
    lua_pushinteger(L, obj->RastPort.AlgoStyle);
    return 1;
  }
  if (strcmp(key, "RastPort.TxFlags") == 0) {
    lua_pushinteger(L, obj->RastPort.TxFlags);
    return 1;
  }
  if (strcmp(key, "RastPort.TxHeight") == 0) {
    lua_pushinteger(L, obj->RastPort.TxHeight);
    return 1;
  }
  if (strcmp(key, "RastPort.TxWidth") == 0) {
    lua_pushinteger(L, obj->RastPort.TxWidth);
    return 1;
  }
  if (strcmp(key, "RastPort.TxBaseline") == 0) {
    lua_pushinteger(L, obj->RastPort.TxBaseline);
    return 1;
  }
  if (strcmp(key, "RastPort.TxSpacing") == 0) {
    lua_pushinteger(L, obj->RastPort.TxSpacing);
    return 1;
  }
  if (strcmp(key, "RastPort.RP_User") == 0) {
    lua_pushlightuserdata(L, obj->RastPort.RP_User);
    return 1;
  }
  if (strcmp(key, "RastPort.longreserved") == 0) {
    _lua_gen_push_ULONG_array_proxy(L, obj->RastPort.longreserved, 2);
    return 1;
  }
  if (strcmp(key, "RastPort.wordreserved") == 0) {
    _lua_gen_push_UWORD_array_proxy(L, obj->RastPort.wordreserved, 7);
    return 1;
  }
  if (strcmp(key, "RastPort.reserved") == 0) {
    _lua_gen_push_UBYTE_array_proxy(L, obj->RastPort.reserved, 8);
    return 1;
  }
  if (strcmp(key, "RastPort") == 0) {
    struct RastPort **ud = (struct RastPort **)lua_newuserdata(L, sizeof(struct RastPort *));
    *ud = (struct RastPort*)&obj->RastPort;
    luaL_getmetatable(L, "RastPort");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "BitMap.BytesPerRow") == 0) {
    lua_pushinteger(L, obj->BitMap.BytesPerRow);
    return 1;
  }
  if (strcmp(key, "BitMap.Rows") == 0) {
    lua_pushinteger(L, obj->BitMap.Rows);
    return 1;
  }
  if (strcmp(key, "BitMap.Flags") == 0) {
    lua_pushinteger(L, obj->BitMap.Flags);
    return 1;
  }
  if (strcmp(key, "BitMap.Depth") == 0) {
    lua_pushinteger(L, obj->BitMap.Depth);
    return 1;
  }
  if (strcmp(key, "BitMap.pad") == 0) {
    lua_pushinteger(L, obj->BitMap.pad);
    return 1;
  }
  if (strcmp(key, "BitMap.Planes") == 0) {
    _lua_gen_push_PLANEPTR_array_proxy(L, obj->BitMap.Planes, 8);
    return 1;
  }
  if (strcmp(key, "BitMap") == 0) {
    struct BitMap **ud = (struct BitMap **)lua_newuserdata(L, sizeof(struct BitMap *));
    *ud = (struct BitMap*)&obj->BitMap;
    luaL_getmetatable(L, "BitMap");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "LayerInfo.top_layer") == 0) {
    struct Layer **ud = (struct Layer **)lua_newuserdata(L, sizeof(struct Layer *));
    *ud = (struct Layer*)obj->LayerInfo.top_layer;
    luaL_getmetatable(L, "Layer");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "LayerInfo.resPtr1") == 0) {
    lua_pushlightuserdata(L, obj->LayerInfo.resPtr1);
    return 1;
  }
  if (strcmp(key, "LayerInfo.resPtr2") == 0) {
    lua_pushlightuserdata(L, obj->LayerInfo.resPtr2);
    return 1;
  }
  if (strcmp(key, "LayerInfo.FreeClipRects") == 0) {
    struct ClipRect **ud = (struct ClipRect **)lua_newuserdata(L, sizeof(struct ClipRect *));
    *ud = (struct ClipRect*)obj->LayerInfo.FreeClipRects;
    luaL_getmetatable(L, "ClipRect");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "LayerInfo.bounds.MinX") == 0) {
    lua_pushinteger(L, obj->LayerInfo.bounds.MinX);
    return 1;
  }
  if (strcmp(key, "LayerInfo.bounds.MinY") == 0) {
    lua_pushinteger(L, obj->LayerInfo.bounds.MinY);
    return 1;
  }
  if (strcmp(key, "LayerInfo.bounds.MaxX") == 0) {
    lua_pushinteger(L, obj->LayerInfo.bounds.MaxX);
    return 1;
  }
  if (strcmp(key, "LayerInfo.bounds.MaxY") == 0) {
    lua_pushinteger(L, obj->LayerInfo.bounds.MaxY);
    return 1;
  }
  // Unsupported LayerInfo.bounds struct Rectangle
  if (strcmp(key, "LayerInfo.bounds") == 0) {
    return luaL_error(L, "Unsupported type struct Rectangle for field LayerInfo.bounds");
  }
  // Unsupported LayerInfo.Lock.ss_Link.ln_Succ struct Node *
  if (strcmp(key, "LayerInfo.Lock.ss_Link.ln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field LayerInfo.Lock.ss_Link.ln_Succ");
  }
  // Unsupported LayerInfo.Lock.ss_Link.ln_Pred struct Node *
  if (strcmp(key, "LayerInfo.Lock.ss_Link.ln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field LayerInfo.Lock.ss_Link.ln_Pred");
  }
  if (strcmp(key, "LayerInfo.Lock.ss_Link.ln_Type") == 0) {
    lua_pushinteger(L, obj->LayerInfo.Lock.ss_Link.ln_Type);
    return 1;
  }
  if (strcmp(key, "LayerInfo.Lock.ss_Link.ln_Pri") == 0) {
    lua_pushinteger(L, obj->LayerInfo.Lock.ss_Link.ln_Pri);
    return 1;
  }
  if (strcmp(key, "LayerInfo.Lock.ss_Link.ln_Name") == 0) {
    lua_pushstring(L, obj->LayerInfo.Lock.ss_Link.ln_Name);
    return 1;
  }
  // Unsupported LayerInfo.Lock.ss_Link struct Node
  if (strcmp(key, "LayerInfo.Lock.ss_Link") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field LayerInfo.Lock.ss_Link");
  }
  if (strcmp(key, "LayerInfo.Lock.ss_NestCount") == 0) {
    lua_pushinteger(L, obj->LayerInfo.Lock.ss_NestCount);
    return 1;
  }
  if (strcmp(key, "LayerInfo.Lock.ss_WaitQueue.mlh_Head") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)obj->LayerInfo.Lock.ss_WaitQueue.mlh_Head;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "LayerInfo.Lock.ss_WaitQueue.mlh_Tail") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)obj->LayerInfo.Lock.ss_WaitQueue.mlh_Tail;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "LayerInfo.Lock.ss_WaitQueue.mlh_TailPred") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)obj->LayerInfo.Lock.ss_WaitQueue.mlh_TailPred;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  // Unsupported LayerInfo.Lock.ss_WaitQueue struct MinList
  if (strcmp(key, "LayerInfo.Lock.ss_WaitQueue") == 0) {
    return luaL_error(L, "Unsupported type struct MinList for field LayerInfo.Lock.ss_WaitQueue");
  }
  if (strcmp(key, "LayerInfo.Lock.ss_MultipleLink.sr_Link.mln_Succ") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)obj->LayerInfo.Lock.ss_MultipleLink.sr_Link.mln_Succ;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "LayerInfo.Lock.ss_MultipleLink.sr_Link.mln_Pred") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)obj->LayerInfo.Lock.ss_MultipleLink.sr_Link.mln_Pred;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "LayerInfo.Lock.ss_MultipleLink.sr_Link") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)&obj->LayerInfo.Lock.ss_MultipleLink.sr_Link;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  // Unsupported LayerInfo.Lock.ss_MultipleLink.sr_Waiter struct Task *
  if (strcmp(key, "LayerInfo.Lock.ss_MultipleLink.sr_Waiter") == 0) {
    return luaL_error(L, "Unsupported type struct Task * for field LayerInfo.Lock.ss_MultipleLink.sr_Waiter");
  }
  // Unsupported LayerInfo.Lock.ss_MultipleLink struct SemaphoreRequest
  if (strcmp(key, "LayerInfo.Lock.ss_MultipleLink") == 0) {
    return luaL_error(L, "Unsupported type struct SemaphoreRequest for field LayerInfo.Lock.ss_MultipleLink");
  }
  // Unsupported LayerInfo.Lock.ss_Owner struct Task *
  if (strcmp(key, "LayerInfo.Lock.ss_Owner") == 0) {
    return luaL_error(L, "Unsupported type struct Task * for field LayerInfo.Lock.ss_Owner");
  }
  if (strcmp(key, "LayerInfo.Lock.ss_QueueCount") == 0) {
    lua_pushinteger(L, obj->LayerInfo.Lock.ss_QueueCount);
    return 1;
  }
  // Unsupported LayerInfo.Lock struct SignalSemaphore
  if (strcmp(key, "LayerInfo.Lock") == 0) {
    return luaL_error(L, "Unsupported type struct SignalSemaphore for field LayerInfo.Lock");
  }
  if (strcmp(key, "LayerInfo.gs_Head.mlh_Head") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)obj->LayerInfo.gs_Head.mlh_Head;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "LayerInfo.gs_Head.mlh_Tail") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)obj->LayerInfo.gs_Head.mlh_Tail;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "LayerInfo.gs_Head.mlh_TailPred") == 0) {
    struct MinNode **ud = (struct MinNode **)lua_newuserdata(L, sizeof(struct MinNode *));
    *ud = (struct MinNode*)obj->LayerInfo.gs_Head.mlh_TailPred;
    luaL_getmetatable(L, "MinNode");
    lua_setmetatable(L, -2);
    return 1;
  }
  // Unsupported LayerInfo.gs_Head struct MinList
  if (strcmp(key, "LayerInfo.gs_Head") == 0) {
    return luaL_error(L, "Unsupported type struct MinList for field LayerInfo.gs_Head");
  }
  if (strcmp(key, "LayerInfo.PrivateReserve3") == 0) {
    lua_pushinteger(L, obj->LayerInfo.PrivateReserve3);
    return 1;
  }
  if (strcmp(key, "LayerInfo.PrivateReserve4") == 0) {
    lua_pushlightuserdata(L, obj->LayerInfo.PrivateReserve4);
    return 1;
  }
  if (strcmp(key, "LayerInfo.Flags") == 0) {
    lua_pushinteger(L, obj->LayerInfo.Flags);
    return 1;
  }
  if (strcmp(key, "LayerInfo.res_count") == 0) {
    lua_pushinteger(L, obj->LayerInfo.res_count);
    return 1;
  }
  if (strcmp(key, "LayerInfo.LockLayersCount") == 0) {
    lua_pushinteger(L, obj->LayerInfo.LockLayersCount);
    return 1;
  }
  if (strcmp(key, "LayerInfo.PrivateReserve5") == 0) {
    lua_pushinteger(L, obj->LayerInfo.PrivateReserve5);
    return 1;
  }
  if (strcmp(key, "LayerInfo.UserClipRectsCount") == 0) {
    lua_pushinteger(L, obj->LayerInfo.UserClipRectsCount);
    return 1;
  }
  if (strcmp(key, "LayerInfo.BlankHook") == 0) {
    struct Hook **ud = (struct Hook **)lua_newuserdata(L, sizeof(struct Hook *));
    *ud = (struct Hook*)obj->LayerInfo.BlankHook;
    luaL_getmetatable(L, "Hook");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "LayerInfo.resPtr5") == 0) {
    lua_pushlightuserdata(L, obj->LayerInfo.resPtr5);
    return 1;
  }
  if (strcmp(key, "LayerInfo") == 0) {
    struct Layer_Info **ud = (struct Layer_Info **)lua_newuserdata(L, sizeof(struct Layer_Info *));
    *ud = (struct Layer_Info*)&obj->LayerInfo;
    luaL_getmetatable(L, "Layer_Info");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "FirstGadget") == 0) {
    struct Gadget **ud = (struct Gadget **)lua_newuserdata(L, sizeof(struct Gadget *));
    *ud = (struct Gadget*)obj->FirstGadget;
    luaL_getmetatable(L, "Gadget");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "DetailPen") == 0) {
    lua_pushinteger(L, obj->DetailPen);
    return 1;
  }
  if (strcmp(key, "BlockPen") == 0) {
    lua_pushinteger(L, obj->BlockPen);
    return 1;
  }
  if (strcmp(key, "SaveColor0") == 0) {
    lua_pushinteger(L, obj->SaveColor0);
    return 1;
  }
  if (strcmp(key, "BarLayer") == 0) {
    struct Layer **ud = (struct Layer **)lua_newuserdata(L, sizeof(struct Layer *));
    *ud = (struct Layer*)obj->BarLayer;
    luaL_getmetatable(L, "Layer");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "ExtData") == 0) {
    lua_pushlightuserdata(L, obj->ExtData);
    return 1;
  }
  if (strcmp(key, "UserData") == 0) {
    lua_pushlightuserdata(L, obj->UserData);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct Screen));
    return 1;
}

  return 0;
}

static void
_lua_gen_Screen_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "LeftEdge");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "TopEdge");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "Width");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "Height");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "MouseY");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "MouseX");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "Flags");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "Title");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "DefaultTitle");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "BarHeight");
  lua_rawseti(L, -2, 10);
  lua_pushstring(L, "BarVBorder");
  lua_rawseti(L, -2, 11);
  lua_pushstring(L, "BarHBorder");
  lua_rawseti(L, -2, 12);
  lua_pushstring(L, "MenuVBorder");
  lua_rawseti(L, -2, 13);
  lua_pushstring(L, "MenuHBorder");
  lua_rawseti(L, -2, 14);
  lua_pushstring(L, "WBorTop");
  lua_rawseti(L, -2, 15);
  lua_pushstring(L, "WBorLeft");
  lua_rawseti(L, -2, 16);
  lua_pushstring(L, "WBorRight");
  lua_rawseti(L, -2, 17);
  lua_pushstring(L, "WBorBottom");
  lua_rawseti(L, -2, 18);
  lua_pushstring(L, "ViewPort.DWidth");
  lua_rawseti(L, -2, 19);
  lua_pushstring(L, "ViewPort.DHeight");
  lua_rawseti(L, -2, 20);
  lua_pushstring(L, "ViewPort.DxOffset");
  lua_rawseti(L, -2, 21);
  lua_pushstring(L, "ViewPort.DyOffset");
  lua_rawseti(L, -2, 22);
  lua_pushstring(L, "ViewPort.Modes");
  lua_rawseti(L, -2, 23);
  lua_pushstring(L, "ViewPort.SpritePriorities");
  lua_rawseti(L, -2, 24);
  lua_pushstring(L, "ViewPort.ExtendedModes");
  lua_rawseti(L, -2, 25);
  lua_pushstring(L, "RastPort.AreaPtrn");
  lua_rawseti(L, -2, 26);
  lua_pushstring(L, "RastPort.Mask");
  lua_rawseti(L, -2, 27);
  lua_pushstring(L, "RastPort.FgPen");
  lua_rawseti(L, -2, 28);
  lua_pushstring(L, "RastPort.BgPen");
  lua_rawseti(L, -2, 29);
  lua_pushstring(L, "RastPort.AOlPen");
  lua_rawseti(L, -2, 30);
  lua_pushstring(L, "RastPort.DrawMode");
  lua_rawseti(L, -2, 31);
  lua_pushstring(L, "RastPort.AreaPtSz");
  lua_rawseti(L, -2, 32);
  lua_pushstring(L, "RastPort.linpatcnt");
  lua_rawseti(L, -2, 33);
  lua_pushstring(L, "RastPort.dummy");
  lua_rawseti(L, -2, 34);
  lua_pushstring(L, "RastPort.Flags");
  lua_rawseti(L, -2, 35);
  lua_pushstring(L, "RastPort.LinePtrn");
  lua_rawseti(L, -2, 36);
  lua_pushstring(L, "RastPort.cp_x");
  lua_rawseti(L, -2, 37);
  lua_pushstring(L, "RastPort.cp_y");
  lua_rawseti(L, -2, 38);
  lua_pushstring(L, "RastPort.minterms");
  lua_rawseti(L, -2, 39);
  lua_pushstring(L, "RastPort.PenWidth");
  lua_rawseti(L, -2, 40);
  lua_pushstring(L, "RastPort.PenHeight");
  lua_rawseti(L, -2, 41);
  lua_pushstring(L, "RastPort.AlgoStyle");
  lua_rawseti(L, -2, 42);
  lua_pushstring(L, "RastPort.TxFlags");
  lua_rawseti(L, -2, 43);
  lua_pushstring(L, "RastPort.TxHeight");
  lua_rawseti(L, -2, 44);
  lua_pushstring(L, "RastPort.TxWidth");
  lua_rawseti(L, -2, 45);
  lua_pushstring(L, "RastPort.TxBaseline");
  lua_rawseti(L, -2, 46);
  lua_pushstring(L, "RastPort.TxSpacing");
  lua_rawseti(L, -2, 47);
  lua_pushstring(L, "RastPort.RP_User");
  lua_rawseti(L, -2, 48);
  lua_pushstring(L, "RastPort.longreserved");
  lua_rawseti(L, -2, 49);
  lua_pushstring(L, "RastPort.wordreserved");
  lua_rawseti(L, -2, 50);
  lua_pushstring(L, "RastPort.reserved");
  lua_rawseti(L, -2, 51);
  lua_pushstring(L, "BitMap.BytesPerRow");
  lua_rawseti(L, -2, 52);
  lua_pushstring(L, "BitMap.Rows");
  lua_rawseti(L, -2, 53);
  lua_pushstring(L, "BitMap.Flags");
  lua_rawseti(L, -2, 54);
  lua_pushstring(L, "BitMap.Depth");
  lua_rawseti(L, -2, 55);
  lua_pushstring(L, "BitMap.pad");
  lua_rawseti(L, -2, 56);
  lua_pushstring(L, "BitMap.Planes");
  lua_rawseti(L, -2, 57);
  lua_pushstring(L, "LayerInfo.bounds.MinX");
  lua_rawseti(L, -2, 58);
  lua_pushstring(L, "LayerInfo.bounds.MinY");
  lua_rawseti(L, -2, 59);
  lua_pushstring(L, "LayerInfo.bounds.MaxX");
  lua_rawseti(L, -2, 60);
  lua_pushstring(L, "LayerInfo.bounds.MaxY");
  lua_rawseti(L, -2, 61);
  lua_pushstring(L, "LayerInfo.Lock.ss_Link.ln_Type");
  lua_rawseti(L, -2, 62);
  lua_pushstring(L, "LayerInfo.Lock.ss_Link.ln_Pri");
  lua_rawseti(L, -2, 63);
  lua_pushstring(L, "LayerInfo.Lock.ss_Link.ln_Name");
  lua_rawseti(L, -2, 64);
  lua_pushstring(L, "LayerInfo.Lock.ss_NestCount");
  lua_rawseti(L, -2, 65);
  lua_pushstring(L, "LayerInfo.Lock.ss_QueueCount");
  lua_rawseti(L, -2, 66);
  lua_pushstring(L, "LayerInfo.PrivateReserve3");
  lua_rawseti(L, -2, 67);
  lua_pushstring(L, "LayerInfo.Flags");
  lua_rawseti(L, -2, 68);
  lua_pushstring(L, "LayerInfo.res_count");
  lua_rawseti(L, -2, 69);
  lua_pushstring(L, "LayerInfo.LockLayersCount");
  lua_rawseti(L, -2, 70);
  lua_pushstring(L, "LayerInfo.PrivateReserve5");
  lua_rawseti(L, -2, 71);
  lua_pushstring(L, "LayerInfo.UserClipRectsCount");
  lua_rawseti(L, -2, 72);
  lua_pushstring(L, "DetailPen");
  lua_rawseti(L, -2, 73);
  lua_pushstring(L, "BlockPen");
  lua_rawseti(L, -2, 74);
  lua_pushstring(L, "SaveColor0");
  lua_rawseti(L, -2, 75);
  lua_pushstring(L, "ExtData");
  lua_rawseti(L, -2, 76);
  lua_pushstring(L, "UserData");
  lua_rawseti(L, -2, 77);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_Screen(lua_State *L) {
  if (luaL_newmetatable(L, "Screen")) {
    lua_pushcfunction(L, _lua_gen_Screen_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_Screen_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_Screen_constructor);
    lua_setglobal(L, "Screen");
    _lua_gen_Screen_install_keys(L);
    lua_pushstring(L, "Screen");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_TextAttr_newindex(lua_State *L)
{
  struct TextAttr *obj = *(struct TextAttr **)luaL_checkudata(L, 1, "TextAttr");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "ta_Name") == 0) {
    obj->ta_Name = (STRPTR)amiga_checkNullableString(L, 3);
    return 0;
  }
  if (strcmp(key, "ta_YSize") == 0) {
    obj->ta_YSize = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ta_Style") == 0) {
    obj->ta_Style = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ta_Flags") == 0) {
    obj->ta_Flags = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_TextAttr_constructor(lua_State *L)
{
  // Allocate pointer-to-struct TextAttr in userdata
  struct TextAttr **objp = lua_newuserdata(L, sizeof(struct TextAttr *));
  *objp = malloc(sizeof(struct TextAttr));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct TextAttr));

  // Set metatable
  luaL_getmetatable(L, "TextAttr");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_TextAttr_index(lua_State *L)
{
  struct TextAttr *obj = *(struct TextAttr **)luaL_checkudata(L, 1, "TextAttr");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "ta_Name") == 0) {
    lua_pushstring(L, obj->ta_Name);
    return 1;
  }
  if (strcmp(key, "ta_YSize") == 0) {
    lua_pushinteger(L, obj->ta_YSize);
    return 1;
  }
  if (strcmp(key, "ta_Style") == 0) {
    lua_pushinteger(L, obj->ta_Style);
    return 1;
  }
  if (strcmp(key, "ta_Flags") == 0) {
    lua_pushinteger(L, obj->ta_Flags);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct TextAttr));
    return 1;
}

  return 0;
}

static void
_lua_gen_TextAttr_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "ta_Name");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "ta_YSize");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "ta_Style");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "ta_Flags");
  lua_rawseti(L, -2, 4);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_TextAttr(lua_State *L) {
  if (luaL_newmetatable(L, "TextAttr")) {
    lua_pushcfunction(L, _lua_gen_TextAttr_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_TextAttr_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_TextAttr_constructor);
    lua_setglobal(L, "TextAttr");
    _lua_gen_TextAttr_install_keys(L);
    lua_pushstring(L, "TextAttr");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_TextFont_newindex(lua_State *L)
{
  struct TextFont *obj = *(struct TextFont **)luaL_checkudata(L, 1, "TextFont");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  // Unsupported type tf_Message.mn_Node.ln_Succ struct Node
  if (strcmp(key, "tf_Message.mn_Node.ln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field tf_Message.mn_Node.ln_Succ");
  }
  // Unsupported type tf_Message.mn_Node.ln_Pred struct Node
  if (strcmp(key, "tf_Message.mn_Node.ln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field tf_Message.mn_Node.ln_Pred");
  }
  if (strcmp(key, "tf_Message.mn_Node.ln_Type") == 0) {
    obj->tf_Message.mn_Node.ln_Type = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_Message.mn_Node.ln_Pri") == 0) {
    obj->tf_Message.mn_Node.ln_Pri = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_Message.mn_Node.ln_Name") == 0) {
    obj->tf_Message.mn_Node.ln_Name = (char *)luaL_checkstring(L, 3);
    return 0;
  }
  // Unsupported type tf_Message.mn_Node struct Node
  if (strcmp(key, "tf_Message.mn_Node") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field tf_Message.mn_Node");
  }
  if (strcmp(key, "tf_Message.mn_ReplyPort") == 0) {
    // finder 1
    //obj->tf_Message.mn_ReplyPort = *(struct MsgPort **)luaL_checkudata(L, 3, "MsgPort");
    obj->tf_Message.mn_ReplyPort = (struct MsgPort *)_lua_gen_checkMsgPort(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_Message.mn_Length") == 0) {
    obj->tf_Message.mn_Length = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_Message") == 0) {
    // finder 0
    struct Message *val = *(struct Message **)luaL_checkudata(L, 3, "Message");
    obj->tf_Message = *val;
    return 0;
  }
  if (strcmp(key, "tf_YSize") == 0) {
    obj->tf_YSize = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_Style") == 0) {
    obj->tf_Style = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_Flags") == 0) {
    obj->tf_Flags = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_XSize") == 0) {
    obj->tf_XSize = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_Baseline") == 0) {
    obj->tf_Baseline = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_BoldSmear") == 0) {
    obj->tf_BoldSmear = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_Accessors") == 0) {
    obj->tf_Accessors = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_LoChar") == 0) {
    obj->tf_LoChar = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_HiChar") == 0) {
    obj->tf_HiChar = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_CharData") == 0) {
    obj->tf_CharData = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_Modulo") == 0) {
    obj->tf_Modulo = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_CharLoc") == 0) {
    obj->tf_CharLoc = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_CharSpace") == 0) {
    obj->tf_CharSpace = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "tf_CharKern") == 0) {
    obj->tf_CharKern = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_TextFont_constructor(lua_State *L)
{
  // Allocate pointer-to-struct TextFont in userdata
  struct TextFont **objp = lua_newuserdata(L, sizeof(struct TextFont *));
  *objp = malloc(sizeof(struct TextFont));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct TextFont));

  // Set metatable
  luaL_getmetatable(L, "TextFont");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_TextFont_index(lua_State *L)
{
  struct TextFont *obj = *(struct TextFont **)luaL_checkudata(L, 1, "TextFont");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  // Unsupported tf_Message.mn_Node.ln_Succ struct Node *
  if (strcmp(key, "tf_Message.mn_Node.ln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field tf_Message.mn_Node.ln_Succ");
  }
  // Unsupported tf_Message.mn_Node.ln_Pred struct Node *
  if (strcmp(key, "tf_Message.mn_Node.ln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field tf_Message.mn_Node.ln_Pred");
  }
  if (strcmp(key, "tf_Message.mn_Node.ln_Type") == 0) {
    lua_pushinteger(L, obj->tf_Message.mn_Node.ln_Type);
    return 1;
  }
  if (strcmp(key, "tf_Message.mn_Node.ln_Pri") == 0) {
    lua_pushinteger(L, obj->tf_Message.mn_Node.ln_Pri);
    return 1;
  }
  if (strcmp(key, "tf_Message.mn_Node.ln_Name") == 0) {
    lua_pushstring(L, obj->tf_Message.mn_Node.ln_Name);
    return 1;
  }
  // Unsupported tf_Message.mn_Node struct Node
  if (strcmp(key, "tf_Message.mn_Node") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field tf_Message.mn_Node");
  }
  if (strcmp(key, "tf_Message.mn_ReplyPort") == 0) {
    struct MsgPort **ud = (struct MsgPort **)lua_newuserdata(L, sizeof(struct MsgPort *));
    *ud = (struct MsgPort*)obj->tf_Message.mn_ReplyPort;
    luaL_getmetatable(L, "MsgPort");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "tf_Message.mn_Length") == 0) {
    lua_pushinteger(L, obj->tf_Message.mn_Length);
    return 1;
  }
  if (strcmp(key, "tf_Message") == 0) {
    struct Message **ud = (struct Message **)lua_newuserdata(L, sizeof(struct Message *));
    *ud = (struct Message*)&obj->tf_Message;
    luaL_getmetatable(L, "Message");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "tf_YSize") == 0) {
    lua_pushinteger(L, obj->tf_YSize);
    return 1;
  }
  if (strcmp(key, "tf_Style") == 0) {
    lua_pushinteger(L, obj->tf_Style);
    return 1;
  }
  if (strcmp(key, "tf_Flags") == 0) {
    lua_pushinteger(L, obj->tf_Flags);
    return 1;
  }
  if (strcmp(key, "tf_XSize") == 0) {
    lua_pushinteger(L, obj->tf_XSize);
    return 1;
  }
  if (strcmp(key, "tf_Baseline") == 0) {
    lua_pushinteger(L, obj->tf_Baseline);
    return 1;
  }
  if (strcmp(key, "tf_BoldSmear") == 0) {
    lua_pushinteger(L, obj->tf_BoldSmear);
    return 1;
  }
  if (strcmp(key, "tf_Accessors") == 0) {
    lua_pushinteger(L, obj->tf_Accessors);
    return 1;
  }
  if (strcmp(key, "tf_LoChar") == 0) {
    lua_pushinteger(L, obj->tf_LoChar);
    return 1;
  }
  if (strcmp(key, "tf_HiChar") == 0) {
    lua_pushinteger(L, obj->tf_HiChar);
    return 1;
  }
  if (strcmp(key, "tf_CharData") == 0) {
    lua_pushlightuserdata(L, obj->tf_CharData);
    return 1;
  }
  if (strcmp(key, "tf_Modulo") == 0) {
    lua_pushinteger(L, obj->tf_Modulo);
    return 1;
  }
  if (strcmp(key, "tf_CharLoc") == 0) {
    lua_pushlightuserdata(L, obj->tf_CharLoc);
    return 1;
  }
  if (strcmp(key, "tf_CharSpace") == 0) {
    lua_pushlightuserdata(L, obj->tf_CharSpace);
    return 1;
  }
  if (strcmp(key, "tf_CharKern") == 0) {
    lua_pushlightuserdata(L, obj->tf_CharKern);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct TextFont));
    return 1;
}

  return 0;
}

static void
_lua_gen_TextFont_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "tf_Message.mn_Node.ln_Type");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "tf_Message.mn_Node.ln_Pri");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "tf_Message.mn_Node.ln_Name");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "tf_Message.mn_Length");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "tf_YSize");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "tf_Style");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "tf_Flags");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "tf_XSize");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "tf_Baseline");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "tf_BoldSmear");
  lua_rawseti(L, -2, 10);
  lua_pushstring(L, "tf_Accessors");
  lua_rawseti(L, -2, 11);
  lua_pushstring(L, "tf_LoChar");
  lua_rawseti(L, -2, 12);
  lua_pushstring(L, "tf_HiChar");
  lua_rawseti(L, -2, 13);
  lua_pushstring(L, "tf_CharData");
  lua_rawseti(L, -2, 14);
  lua_pushstring(L, "tf_Modulo");
  lua_rawseti(L, -2, 15);
  lua_pushstring(L, "tf_CharLoc");
  lua_rawseti(L, -2, 16);
  lua_pushstring(L, "tf_CharSpace");
  lua_rawseti(L, -2, 17);
  lua_pushstring(L, "tf_CharKern");
  lua_rawseti(L, -2, 18);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_TextFont(lua_State *L) {
  if (luaL_newmetatable(L, "TextFont")) {
    lua_pushcfunction(L, _lua_gen_TextFont_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_TextFont_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_TextFont_constructor);
    lua_setglobal(L, "TextFont");
    _lua_gen_TextFont_install_keys(L);
    lua_pushstring(L, "TextFont");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_Window_newindex(lua_State *L)
{
  struct Window *obj = *(struct Window **)luaL_checkudata(L, 1, "Window");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "NextWindow") == 0) {
    // finder 1
    //obj->NextWindow = *(struct Window **)luaL_checkudata(L, 3, "Window");
    obj->NextWindow = (struct Window *)_lua_gen_checkWindow(L, 3);
    return 0;
  }
  if (strcmp(key, "LeftEdge") == 0) {
    obj->LeftEdge = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "TopEdge") == 0) {
    obj->TopEdge = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Width") == 0) {
    obj->Width = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Height") == 0) {
    obj->Height = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "MouseY") == 0) {
    obj->MouseY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "MouseX") == 0) {
    obj->MouseX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "MinWidth") == 0) {
    obj->MinWidth = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "MinHeight") == 0) {
    obj->MinHeight = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "MaxWidth") == 0) {
    obj->MaxWidth = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "MaxHeight") == 0) {
    obj->MaxHeight = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Flags") == 0) {
    obj->Flags = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "MenuStrip") == 0) {
    // finder 1
    //obj->MenuStrip = *(struct Menu **)luaL_checkudata(L, 3, "Menu");
    obj->MenuStrip = (struct Menu *)_lua_gen_checkMenu(L, 3);
    return 0;
  }
  if (strcmp(key, "Title") == 0) {
    obj->Title = (STRPTR)amiga_checkNullableString(L, 3);
    return 0;
  }
  if (strcmp(key, "FirstRequest") == 0) {
    // finder 1
    //obj->FirstRequest = *(struct Requester **)luaL_checkudata(L, 3, "Requester");
    obj->FirstRequest = (struct Requester *)_lua_gen_checkRequester(L, 3);
    return 0;
  }
  if (strcmp(key, "DMRequest") == 0) {
    // finder 1
    //obj->DMRequest = *(struct Requester **)luaL_checkudata(L, 3, "Requester");
    obj->DMRequest = (struct Requester *)_lua_gen_checkRequester(L, 3);
    return 0;
  }
  if (strcmp(key, "ReqCount") == 0) {
    obj->ReqCount = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "WScreen") == 0) {
    // finder 1
    //obj->WScreen = *(struct Screen **)luaL_checkudata(L, 3, "Screen");
    obj->WScreen = (struct Screen *)_lua_gen_checkScreen(L, 3);
    return 0;
  }
  if (strcmp(key, "RPort") == 0) {
    // finder 1
    //obj->RPort = *(struct RastPort **)luaL_checkudata(L, 3, "RastPort");
    obj->RPort = (struct RastPort *)_lua_gen_checkRastPort(L, 3);
    return 0;
  }
  if (strcmp(key, "BorderLeft") == 0) {
    obj->BorderLeft = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "BorderTop") == 0) {
    obj->BorderTop = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "BorderRight") == 0) {
    obj->BorderRight = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "BorderBottom") == 0) {
    obj->BorderBottom = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "BorderRPort") == 0) {
    // finder 1
    //obj->BorderRPort = *(struct RastPort **)luaL_checkudata(L, 3, "RastPort");
    obj->BorderRPort = (struct RastPort *)_lua_gen_checkRastPort(L, 3);
    return 0;
  }
  if (strcmp(key, "FirstGadget") == 0) {
    // finder 1
    //obj->FirstGadget = *(struct Gadget **)luaL_checkudata(L, 3, "Gadget");
    obj->FirstGadget = (struct Gadget *)_lua_gen_checkGadget(L, 3);
    return 0;
  }
  if (strcmp(key, "Parent") == 0) {
    // finder 1
    //obj->Parent = *(struct Window **)luaL_checkudata(L, 3, "Window");
    obj->Parent = (struct Window *)_lua_gen_checkWindow(L, 3);
    return 0;
  }
  if (strcmp(key, "Descendant") == 0) {
    // finder 1
    //obj->Descendant = *(struct Window **)luaL_checkudata(L, 3, "Window");
    obj->Descendant = (struct Window *)_lua_gen_checkWindow(L, 3);
    return 0;
  }
  if (strcmp(key, "Pointer") == 0) {
    obj->Pointer = (UWORD *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "PtrHeight") == 0) {
    obj->PtrHeight = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "PtrWidth") == 0) {
    obj->PtrWidth = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "XOffset") == 0) {
    obj->XOffset = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "YOffset") == 0) {
    obj->YOffset = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "IDCMPFlags") == 0) {
    obj->IDCMPFlags = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "UserPort") == 0) {
    // finder 1
    //obj->UserPort = *(struct MsgPort **)luaL_checkudata(L, 3, "MsgPort");
    obj->UserPort = (struct MsgPort *)_lua_gen_checkMsgPort(L, 3);
    return 0;
  }
  if (strcmp(key, "WindowPort") == 0) {
    // finder 1
    //obj->WindowPort = *(struct MsgPort **)luaL_checkudata(L, 3, "MsgPort");
    obj->WindowPort = (struct MsgPort *)_lua_gen_checkMsgPort(L, 3);
    return 0;
  }
  if (strcmp(key, "MessageKey") == 0) {
    // finder 1
    //obj->MessageKey = *(struct IntuiMessage **)luaL_checkudata(L, 3, "IntuiMessage");
    obj->MessageKey = (struct IntuiMessage *)_lua_gen_checkIntuiMessage(L, 3);
    return 0;
  }
  if (strcmp(key, "DetailPen") == 0) {
    obj->DetailPen = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "BlockPen") == 0) {
    obj->BlockPen = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "CheckMark") == 0) {
    // finder 1
    //obj->CheckMark = *(struct Image **)luaL_checkudata(L, 3, "Image");
    obj->CheckMark = (struct Image *)_lua_gen_checkImage(L, 3);
    return 0;
  }
  if (strcmp(key, "ScreenTitle") == 0) {
    obj->ScreenTitle = (STRPTR)amiga_checkNullableString(L, 3);
    return 0;
  }
  if (strcmp(key, "GZZMouseX") == 0) {
    obj->GZZMouseX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "GZZMouseY") == 0) {
    obj->GZZMouseY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "GZZWidth") == 0) {
    obj->GZZWidth = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "GZZHeight") == 0) {
    obj->GZZHeight = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ExtData") == 0) {
    obj->ExtData = (UBYTE *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "UserData") == 0) {
    obj->UserData = (BYTE *)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "WLayer") == 0) {
    // finder 1
    //obj->WLayer = *(struct Layer **)luaL_checkudata(L, 3, "Layer");
    obj->WLayer = (struct Layer *)_lua_gen_checkLayer(L, 3);
    return 0;
  }
  if (strcmp(key, "IFont") == 0) {
    // finder 1
    //obj->IFont = *(struct TextFont **)luaL_checkudata(L, 3, "TextFont");
    obj->IFont = (struct TextFont *)_lua_gen_checkTextFont(L, 3);
    return 0;
  }
  if (strcmp(key, "MoreFlags") == 0) {
    obj->MoreFlags = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_Window_constructor(lua_State *L)
{
  // Allocate pointer-to-struct Window in userdata
  struct Window **objp = lua_newuserdata(L, sizeof(struct Window *));
  *objp = malloc(sizeof(struct Window));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct Window));

  // Set metatable
  luaL_getmetatable(L, "Window");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_Window_index(lua_State *L)
{
  struct Window *obj = *(struct Window **)luaL_checkudata(L, 1, "Window");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "NextWindow") == 0) {
    struct Window **ud = (struct Window **)lua_newuserdata(L, sizeof(struct Window *));
    *ud = (struct Window*)obj->NextWindow;
    luaL_getmetatable(L, "Window");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "LeftEdge") == 0) {
    lua_pushinteger(L, obj->LeftEdge);
    return 1;
  }
  if (strcmp(key, "TopEdge") == 0) {
    lua_pushinteger(L, obj->TopEdge);
    return 1;
  }
  if (strcmp(key, "Width") == 0) {
    lua_pushinteger(L, obj->Width);
    return 1;
  }
  if (strcmp(key, "Height") == 0) {
    lua_pushinteger(L, obj->Height);
    return 1;
  }
  if (strcmp(key, "MouseY") == 0) {
    lua_pushinteger(L, obj->MouseY);
    return 1;
  }
  if (strcmp(key, "MouseX") == 0) {
    lua_pushinteger(L, obj->MouseX);
    return 1;
  }
  if (strcmp(key, "MinWidth") == 0) {
    lua_pushinteger(L, obj->MinWidth);
    return 1;
  }
  if (strcmp(key, "MinHeight") == 0) {
    lua_pushinteger(L, obj->MinHeight);
    return 1;
  }
  if (strcmp(key, "MaxWidth") == 0) {
    lua_pushinteger(L, obj->MaxWidth);
    return 1;
  }
  if (strcmp(key, "MaxHeight") == 0) {
    lua_pushinteger(L, obj->MaxHeight);
    return 1;
  }
  if (strcmp(key, "Flags") == 0) {
    lua_pushinteger(L, obj->Flags);
    return 1;
  }
  if (strcmp(key, "MenuStrip") == 0) {
    struct Menu **ud = (struct Menu **)lua_newuserdata(L, sizeof(struct Menu *));
    *ud = (struct Menu*)obj->MenuStrip;
    luaL_getmetatable(L, "Menu");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "Title") == 0) {
    lua_pushstring(L, obj->Title);
    return 1;
  }
  if (strcmp(key, "FirstRequest") == 0) {
    struct Requester **ud = (struct Requester **)lua_newuserdata(L, sizeof(struct Requester *));
    *ud = (struct Requester*)obj->FirstRequest;
    luaL_getmetatable(L, "Requester");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "DMRequest") == 0) {
    struct Requester **ud = (struct Requester **)lua_newuserdata(L, sizeof(struct Requester *));
    *ud = (struct Requester*)obj->DMRequest;
    luaL_getmetatable(L, "Requester");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "ReqCount") == 0) {
    lua_pushinteger(L, obj->ReqCount);
    return 1;
  }
  if (strcmp(key, "WScreen") == 0) {
    struct Screen **ud = (struct Screen **)lua_newuserdata(L, sizeof(struct Screen *));
    *ud = (struct Screen*)obj->WScreen;
    luaL_getmetatable(L, "Screen");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "RPort") == 0) {
    struct RastPort **ud = (struct RastPort **)lua_newuserdata(L, sizeof(struct RastPort *));
    *ud = (struct RastPort*)obj->RPort;
    luaL_getmetatable(L, "RastPort");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "BorderLeft") == 0) {
    lua_pushinteger(L, obj->BorderLeft);
    return 1;
  }
  if (strcmp(key, "BorderTop") == 0) {
    lua_pushinteger(L, obj->BorderTop);
    return 1;
  }
  if (strcmp(key, "BorderRight") == 0) {
    lua_pushinteger(L, obj->BorderRight);
    return 1;
  }
  if (strcmp(key, "BorderBottom") == 0) {
    lua_pushinteger(L, obj->BorderBottom);
    return 1;
  }
  if (strcmp(key, "BorderRPort") == 0) {
    struct RastPort **ud = (struct RastPort **)lua_newuserdata(L, sizeof(struct RastPort *));
    *ud = (struct RastPort*)obj->BorderRPort;
    luaL_getmetatable(L, "RastPort");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "FirstGadget") == 0) {
    struct Gadget **ud = (struct Gadget **)lua_newuserdata(L, sizeof(struct Gadget *));
    *ud = (struct Gadget*)obj->FirstGadget;
    luaL_getmetatable(L, "Gadget");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "Parent") == 0) {
    struct Window **ud = (struct Window **)lua_newuserdata(L, sizeof(struct Window *));
    *ud = (struct Window*)obj->Parent;
    luaL_getmetatable(L, "Window");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "Descendant") == 0) {
    struct Window **ud = (struct Window **)lua_newuserdata(L, sizeof(struct Window *));
    *ud = (struct Window*)obj->Descendant;
    luaL_getmetatable(L, "Window");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "Pointer") == 0) {
    lua_pushlightuserdata(L, obj->Pointer);
    return 1;
  }
  if (strcmp(key, "PtrHeight") == 0) {
    lua_pushinteger(L, obj->PtrHeight);
    return 1;
  }
  if (strcmp(key, "PtrWidth") == 0) {
    lua_pushinteger(L, obj->PtrWidth);
    return 1;
  }
  if (strcmp(key, "XOffset") == 0) {
    lua_pushinteger(L, obj->XOffset);
    return 1;
  }
  if (strcmp(key, "YOffset") == 0) {
    lua_pushinteger(L, obj->YOffset);
    return 1;
  }
  if (strcmp(key, "IDCMPFlags") == 0) {
    lua_pushinteger(L, obj->IDCMPFlags);
    return 1;
  }
  if (strcmp(key, "UserPort") == 0) {
    struct MsgPort **ud = (struct MsgPort **)lua_newuserdata(L, sizeof(struct MsgPort *));
    *ud = (struct MsgPort*)obj->UserPort;
    luaL_getmetatable(L, "MsgPort");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "WindowPort") == 0) {
    struct MsgPort **ud = (struct MsgPort **)lua_newuserdata(L, sizeof(struct MsgPort *));
    *ud = (struct MsgPort*)obj->WindowPort;
    luaL_getmetatable(L, "MsgPort");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "MessageKey") == 0) {
    struct IntuiMessage **ud = (struct IntuiMessage **)lua_newuserdata(L, sizeof(struct IntuiMessage *));
    *ud = (struct IntuiMessage*)obj->MessageKey;
    luaL_getmetatable(L, "IntuiMessage");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "DetailPen") == 0) {
    lua_pushinteger(L, obj->DetailPen);
    return 1;
  }
  if (strcmp(key, "BlockPen") == 0) {
    lua_pushinteger(L, obj->BlockPen);
    return 1;
  }
  if (strcmp(key, "CheckMark") == 0) {
    struct Image **ud = (struct Image **)lua_newuserdata(L, sizeof(struct Image *));
    *ud = (struct Image*)obj->CheckMark;
    luaL_getmetatable(L, "Image");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "ScreenTitle") == 0) {
    lua_pushstring(L, obj->ScreenTitle);
    return 1;
  }
  if (strcmp(key, "GZZMouseX") == 0) {
    lua_pushinteger(L, obj->GZZMouseX);
    return 1;
  }
  if (strcmp(key, "GZZMouseY") == 0) {
    lua_pushinteger(L, obj->GZZMouseY);
    return 1;
  }
  if (strcmp(key, "GZZWidth") == 0) {
    lua_pushinteger(L, obj->GZZWidth);
    return 1;
  }
  if (strcmp(key, "GZZHeight") == 0) {
    lua_pushinteger(L, obj->GZZHeight);
    return 1;
  }
  if (strcmp(key, "ExtData") == 0) {
    lua_pushlightuserdata(L, obj->ExtData);
    return 1;
  }
  if (strcmp(key, "UserData") == 0) {
    lua_pushlightuserdata(L, obj->UserData);
    return 1;
  }
  if (strcmp(key, "WLayer") == 0) {
    struct Layer **ud = (struct Layer **)lua_newuserdata(L, sizeof(struct Layer *));
    *ud = (struct Layer*)obj->WLayer;
    luaL_getmetatable(L, "Layer");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "IFont") == 0) {
    struct TextFont **ud = (struct TextFont **)lua_newuserdata(L, sizeof(struct TextFont *));
    *ud = (struct TextFont*)obj->IFont;
    luaL_getmetatable(L, "TextFont");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "MoreFlags") == 0) {
    lua_pushinteger(L, obj->MoreFlags);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct Window));
    return 1;
}

  return 0;
}

static void
_lua_gen_Window_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "LeftEdge");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "TopEdge");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "Width");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "Height");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "MouseY");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "MouseX");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "MinWidth");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "MinHeight");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "MaxWidth");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "MaxHeight");
  lua_rawseti(L, -2, 10);
  lua_pushstring(L, "Flags");
  lua_rawseti(L, -2, 11);
  lua_pushstring(L, "Title");
  lua_rawseti(L, -2, 12);
  lua_pushstring(L, "ReqCount");
  lua_rawseti(L, -2, 13);
  lua_pushstring(L, "BorderLeft");
  lua_rawseti(L, -2, 14);
  lua_pushstring(L, "BorderTop");
  lua_rawseti(L, -2, 15);
  lua_pushstring(L, "BorderRight");
  lua_rawseti(L, -2, 16);
  lua_pushstring(L, "BorderBottom");
  lua_rawseti(L, -2, 17);
  lua_pushstring(L, "Pointer");
  lua_rawseti(L, -2, 18);
  lua_pushstring(L, "PtrHeight");
  lua_rawseti(L, -2, 19);
  lua_pushstring(L, "PtrWidth");
  lua_rawseti(L, -2, 20);
  lua_pushstring(L, "XOffset");
  lua_rawseti(L, -2, 21);
  lua_pushstring(L, "YOffset");
  lua_rawseti(L, -2, 22);
  lua_pushstring(L, "IDCMPFlags");
  lua_rawseti(L, -2, 23);
  lua_pushstring(L, "DetailPen");
  lua_rawseti(L, -2, 24);
  lua_pushstring(L, "BlockPen");
  lua_rawseti(L, -2, 25);
  lua_pushstring(L, "ScreenTitle");
  lua_rawseti(L, -2, 26);
  lua_pushstring(L, "GZZMouseX");
  lua_rawseti(L, -2, 27);
  lua_pushstring(L, "GZZMouseY");
  lua_rawseti(L, -2, 28);
  lua_pushstring(L, "GZZWidth");
  lua_rawseti(L, -2, 29);
  lua_pushstring(L, "GZZHeight");
  lua_rawseti(L, -2, 30);
  lua_pushstring(L, "ExtData");
  lua_rawseti(L, -2, 31);
  lua_pushstring(L, "UserData");
  lua_rawseti(L, -2, 32);
  lua_pushstring(L, "MoreFlags");
  lua_rawseti(L, -2, 33);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_Window(lua_State *L) {
  if (luaL_newmetatable(L, "Window")) {
    lua_pushcfunction(L, _lua_gen_Window_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_Window_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_Window_constructor);
    lua_setglobal(L, "Window");
    _lua_gen_Window_install_keys(L);
    lua_pushstring(L, "Window");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_StringInfo_newindex(lua_State *L)
{
  struct StringInfo *obj = *(struct StringInfo **)luaL_checkudata(L, 1, "StringInfo");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "Buffer") == 0) {
    obj->Buffer = (STRPTR)amiga_checkNullableString(L, 3);
    return 0;
  }
  if (strcmp(key, "UndoBuffer") == 0) {
    obj->UndoBuffer = (STRPTR)amiga_checkNullableString(L, 3);
    return 0;
  }
  if (strcmp(key, "BufferPos") == 0) {
    obj->BufferPos = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "MaxChars") == 0) {
    obj->MaxChars = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DispPos") == 0) {
    obj->DispPos = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "UndoPos") == 0) {
    obj->UndoPos = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "NumChars") == 0) {
    obj->NumChars = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "DispCount") == 0) {
    obj->DispCount = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "CLeft") == 0) {
    obj->CLeft = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "CTop") == 0) {
    obj->CTop = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Extension") == 0) {
    // finder 1
    //obj->Extension = *(struct StringExtend **)luaL_checkudata(L, 3, "StringExtend");
    obj->Extension = (struct StringExtend *)_lua_gen_checkStringExtend(L, 3);
    return 0;
  }
  if (strcmp(key, "LongInt") == 0) {
    obj->LongInt = (LONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "AltKeyMap") == 0) {
    // finder 1
    //obj->AltKeyMap = *(struct KeyMap **)luaL_checkudata(L, 3, "KeyMap");
    obj->AltKeyMap = (struct KeyMap *)_lua_gen_checkKeyMap(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_StringInfo_constructor(lua_State *L)
{
  // Allocate pointer-to-struct StringInfo in userdata
  struct StringInfo **objp = lua_newuserdata(L, sizeof(struct StringInfo *));
  *objp = malloc(sizeof(struct StringInfo));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct StringInfo));

  // Set metatable
  luaL_getmetatable(L, "StringInfo");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_StringInfo_index(lua_State *L)
{
  struct StringInfo *obj = *(struct StringInfo **)luaL_checkudata(L, 1, "StringInfo");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "Buffer") == 0) {
    lua_pushstring(L, obj->Buffer);
    return 1;
  }
  if (strcmp(key, "UndoBuffer") == 0) {
    lua_pushstring(L, obj->UndoBuffer);
    return 1;
  }
  if (strcmp(key, "BufferPos") == 0) {
    lua_pushinteger(L, obj->BufferPos);
    return 1;
  }
  if (strcmp(key, "MaxChars") == 0) {
    lua_pushinteger(L, obj->MaxChars);
    return 1;
  }
  if (strcmp(key, "DispPos") == 0) {
    lua_pushinteger(L, obj->DispPos);
    return 1;
  }
  if (strcmp(key, "UndoPos") == 0) {
    lua_pushinteger(L, obj->UndoPos);
    return 1;
  }
  if (strcmp(key, "NumChars") == 0) {
    lua_pushinteger(L, obj->NumChars);
    return 1;
  }
  if (strcmp(key, "DispCount") == 0) {
    lua_pushinteger(L, obj->DispCount);
    return 1;
  }
  if (strcmp(key, "CLeft") == 0) {
    lua_pushinteger(L, obj->CLeft);
    return 1;
  }
  if (strcmp(key, "CTop") == 0) {
    lua_pushinteger(L, obj->CTop);
    return 1;
  }
  if (strcmp(key, "Extension") == 0) {
    struct StringExtend **ud = (struct StringExtend **)lua_newuserdata(L, sizeof(struct StringExtend *));
    *ud = (struct StringExtend*)obj->Extension;
    luaL_getmetatable(L, "StringExtend");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "LongInt") == 0) {
    lua_pushinteger(L, obj->LongInt);
    return 1;
  }
  if (strcmp(key, "AltKeyMap") == 0) {
    struct KeyMap **ud = (struct KeyMap **)lua_newuserdata(L, sizeof(struct KeyMap *));
    *ud = (struct KeyMap*)obj->AltKeyMap;
    luaL_getmetatable(L, "KeyMap");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct StringInfo));
    return 1;
}

  return 0;
}

static void
_lua_gen_StringInfo_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "Buffer");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "UndoBuffer");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "BufferPos");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "MaxChars");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "DispPos");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "UndoPos");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "NumChars");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "DispCount");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "CLeft");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "CTop");
  lua_rawseti(L, -2, 10);
  lua_pushstring(L, "LongInt");
  lua_rawseti(L, -2, 11);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_StringInfo(lua_State *L) {
  if (luaL_newmetatable(L, "StringInfo")) {
    lua_pushcfunction(L, _lua_gen_StringInfo_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_StringInfo_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_StringInfo_constructor);
    lua_setglobal(L, "StringInfo");
    _lua_gen_StringInfo_install_keys(L);
    lua_pushstring(L, "StringInfo");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_StringExtend_newindex(lua_State *L)
{
  struct StringExtend *obj = *(struct StringExtend **)luaL_checkudata(L, 1, "StringExtend");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "Font") == 0) {
    // finder 1
    //obj->Font = *(struct TextFont **)luaL_checkudata(L, 3, "TextFont");
    obj->Font = (struct TextFont *)_lua_gen_checkTextFont(L, 3);
    return 0;
  }
  // Pens[2] proxied via the index
  // ActivePens[2] proxied via the index
  if (strcmp(key, "InitialModes") == 0) {
    obj->InitialModes = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "EditHook") == 0) {
    // finder 1
    //obj->EditHook = *(struct Hook **)luaL_checkudata(L, 3, "Hook");
    obj->EditHook = (struct Hook *)_lua_gen_checkHook(L, 3);
    return 0;
  }
  if (strcmp(key, "WorkBuffer") == 0) {
    obj->WorkBuffer = (STRPTR)amiga_checkNullableString(L, 3);
    return 0;
  }
  // Reserved[4] proxied via the index
  return 0;
}


static int
_lua_StringExtend_constructor(lua_State *L)
{
  // Allocate pointer-to-struct StringExtend in userdata
  struct StringExtend **objp = lua_newuserdata(L, sizeof(struct StringExtend *));
  *objp = malloc(sizeof(struct StringExtend));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct StringExtend));

  // Set metatable
  luaL_getmetatable(L, "StringExtend");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_StringExtend_index(lua_State *L)
{
  struct StringExtend *obj = *(struct StringExtend **)luaL_checkudata(L, 1, "StringExtend");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "Font") == 0) {
    struct TextFont **ud = (struct TextFont **)lua_newuserdata(L, sizeof(struct TextFont *));
    *ud = (struct TextFont*)obj->Font;
    luaL_getmetatable(L, "TextFont");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "Pens") == 0) {
    _lua_gen_push_UBYTE_array_proxy(L, obj->Pens, 2);
    return 1;
  }
  if (strcmp(key, "ActivePens") == 0) {
    _lua_gen_push_UBYTE_array_proxy(L, obj->ActivePens, 2);
    return 1;
  }
  if (strcmp(key, "InitialModes") == 0) {
    lua_pushinteger(L, obj->InitialModes);
    return 1;
  }
  if (strcmp(key, "EditHook") == 0) {
    struct Hook **ud = (struct Hook **)lua_newuserdata(L, sizeof(struct Hook *));
    *ud = (struct Hook*)obj->EditHook;
    luaL_getmetatable(L, "Hook");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "WorkBuffer") == 0) {
    lua_pushstring(L, obj->WorkBuffer);
    return 1;
  }
  if (strcmp(key, "Reserved") == 0) {
    _lua_gen_push_ULONG_array_proxy(L, obj->Reserved, 4);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct StringExtend));
    return 1;
}

  return 0;
}

static void
_lua_gen_StringExtend_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "Pens");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "ActivePens");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "InitialModes");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "WorkBuffer");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "Reserved");
  lua_rawseti(L, -2, 5);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_StringExtend(lua_State *L) {
  if (luaL_newmetatable(L, "StringExtend")) {
    lua_pushcfunction(L, _lua_gen_StringExtend_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_StringExtend_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_StringExtend_constructor);
    lua_setglobal(L, "StringExtend");
    _lua_gen_StringExtend_install_keys(L);
    lua_pushstring(L, "StringExtend");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_IntuiMessage_newindex(lua_State *L)
{
  struct IntuiMessage *obj = *(struct IntuiMessage **)luaL_checkudata(L, 1, "IntuiMessage");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  // Unsupported type ExecMessage.mn_Node.ln_Succ struct Node
  if (strcmp(key, "ExecMessage.mn_Node.ln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field ExecMessage.mn_Node.ln_Succ");
  }
  // Unsupported type ExecMessage.mn_Node.ln_Pred struct Node
  if (strcmp(key, "ExecMessage.mn_Node.ln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field ExecMessage.mn_Node.ln_Pred");
  }
  if (strcmp(key, "ExecMessage.mn_Node.ln_Type") == 0) {
    obj->ExecMessage.mn_Node.ln_Type = (UBYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ExecMessage.mn_Node.ln_Pri") == 0) {
    obj->ExecMessage.mn_Node.ln_Pri = (BYTE)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ExecMessage.mn_Node.ln_Name") == 0) {
    obj->ExecMessage.mn_Node.ln_Name = (char *)luaL_checkstring(L, 3);
    return 0;
  }
  // Unsupported type ExecMessage.mn_Node struct Node
  if (strcmp(key, "ExecMessage.mn_Node") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field ExecMessage.mn_Node");
  }
  if (strcmp(key, "ExecMessage.mn_ReplyPort") == 0) {
    // finder 1
    //obj->ExecMessage.mn_ReplyPort = *(struct MsgPort **)luaL_checkudata(L, 3, "MsgPort");
    obj->ExecMessage.mn_ReplyPort = (struct MsgPort *)_lua_gen_checkMsgPort(L, 3);
    return 0;
  }
  if (strcmp(key, "ExecMessage.mn_Length") == 0) {
    obj->ExecMessage.mn_Length = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "ExecMessage") == 0) {
    // finder 0
    struct Message *val = *(struct Message **)luaL_checkudata(L, 3, "Message");
    obj->ExecMessage = *val;
    return 0;
  }
  if (strcmp(key, "Class") == 0) {
    obj->Class = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Code") == 0) {
    obj->Code = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Qualifier") == 0) {
    obj->Qualifier = (UWORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "IAddress") == 0) {
    obj->IAddress = (APTR)lua_touserdata(L, 3);
    return 0;
  }
  if (strcmp(key, "MouseX") == 0) {
    obj->MouseX = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "MouseY") == 0) {
    obj->MouseY = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Seconds") == 0) {
    obj->Seconds = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Micros") == 0) {
    obj->Micros = (ULONG)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "IDCMPWindow") == 0) {
    // finder 1
    //obj->IDCMPWindow = *(struct Window **)luaL_checkudata(L, 3, "Window");
    obj->IDCMPWindow = (struct Window *)_lua_gen_checkWindow(L, 3);
    return 0;
  }
  if (strcmp(key, "SpecialLink") == 0) {
    // finder 1
    //obj->SpecialLink = *(struct IntuiMessage **)luaL_checkudata(L, 3, "IntuiMessage");
    obj->SpecialLink = (struct IntuiMessage *)_lua_gen_checkIntuiMessage(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_IntuiMessage_constructor(lua_State *L)
{
  // Allocate pointer-to-struct IntuiMessage in userdata
  struct IntuiMessage **objp = lua_newuserdata(L, sizeof(struct IntuiMessage *));
  *objp = malloc(sizeof(struct IntuiMessage));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct IntuiMessage));

  // Set metatable
  luaL_getmetatable(L, "IntuiMessage");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_IntuiMessage_index(lua_State *L)
{
  struct IntuiMessage *obj = *(struct IntuiMessage **)luaL_checkudata(L, 1, "IntuiMessage");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  // Unsupported ExecMessage.mn_Node.ln_Succ struct Node *
  if (strcmp(key, "ExecMessage.mn_Node.ln_Succ") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field ExecMessage.mn_Node.ln_Succ");
  }
  // Unsupported ExecMessage.mn_Node.ln_Pred struct Node *
  if (strcmp(key, "ExecMessage.mn_Node.ln_Pred") == 0) {
    return luaL_error(L, "Unsupported type struct Node * for field ExecMessage.mn_Node.ln_Pred");
  }
  if (strcmp(key, "ExecMessage.mn_Node.ln_Type") == 0) {
    lua_pushinteger(L, obj->ExecMessage.mn_Node.ln_Type);
    return 1;
  }
  if (strcmp(key, "ExecMessage.mn_Node.ln_Pri") == 0) {
    lua_pushinteger(L, obj->ExecMessage.mn_Node.ln_Pri);
    return 1;
  }
  if (strcmp(key, "ExecMessage.mn_Node.ln_Name") == 0) {
    lua_pushstring(L, obj->ExecMessage.mn_Node.ln_Name);
    return 1;
  }
  // Unsupported ExecMessage.mn_Node struct Node
  if (strcmp(key, "ExecMessage.mn_Node") == 0) {
    return luaL_error(L, "Unsupported type struct Node for field ExecMessage.mn_Node");
  }
  if (strcmp(key, "ExecMessage.mn_ReplyPort") == 0) {
    struct MsgPort **ud = (struct MsgPort **)lua_newuserdata(L, sizeof(struct MsgPort *));
    *ud = (struct MsgPort*)obj->ExecMessage.mn_ReplyPort;
    luaL_getmetatable(L, "MsgPort");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "ExecMessage.mn_Length") == 0) {
    lua_pushinteger(L, obj->ExecMessage.mn_Length);
    return 1;
  }
  if (strcmp(key, "ExecMessage") == 0) {
    struct Message **ud = (struct Message **)lua_newuserdata(L, sizeof(struct Message *));
    *ud = (struct Message*)&obj->ExecMessage;
    luaL_getmetatable(L, "Message");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "Class") == 0) {
    lua_pushinteger(L, obj->Class);
    return 1;
  }
  if (strcmp(key, "Code") == 0) {
    lua_pushinteger(L, obj->Code);
    return 1;
  }
  if (strcmp(key, "Qualifier") == 0) {
    lua_pushinteger(L, obj->Qualifier);
    return 1;
  }
  if (strcmp(key, "IAddress") == 0) {
    lua_pushlightuserdata(L, obj->IAddress);
    return 1;
  }
  if (strcmp(key, "MouseX") == 0) {
    lua_pushinteger(L, obj->MouseX);
    return 1;
  }
  if (strcmp(key, "MouseY") == 0) {
    lua_pushinteger(L, obj->MouseY);
    return 1;
  }
  if (strcmp(key, "Seconds") == 0) {
    lua_pushinteger(L, obj->Seconds);
    return 1;
  }
  if (strcmp(key, "Micros") == 0) {
    lua_pushinteger(L, obj->Micros);
    return 1;
  }
  if (strcmp(key, "IDCMPWindow") == 0) {
    struct Window **ud = (struct Window **)lua_newuserdata(L, sizeof(struct Window *));
    *ud = (struct Window*)obj->IDCMPWindow;
    luaL_getmetatable(L, "Window");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "SpecialLink") == 0) {
    struct IntuiMessage **ud = (struct IntuiMessage **)lua_newuserdata(L, sizeof(struct IntuiMessage *));
    *ud = (struct IntuiMessage*)obj->SpecialLink;
    luaL_getmetatable(L, "IntuiMessage");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct IntuiMessage));
    return 1;
}

  return 0;
}

static void
_lua_gen_IntuiMessage_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "ExecMessage.mn_Node.ln_Type");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "ExecMessage.mn_Node.ln_Pri");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "ExecMessage.mn_Node.ln_Name");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "ExecMessage.mn_Length");
  lua_rawseti(L, -2, 4);
  lua_pushstring(L, "Class");
  lua_rawseti(L, -2, 5);
  lua_pushstring(L, "Code");
  lua_rawseti(L, -2, 6);
  lua_pushstring(L, "Qualifier");
  lua_rawseti(L, -2, 7);
  lua_pushstring(L, "IAddress");
  lua_rawseti(L, -2, 8);
  lua_pushstring(L, "MouseX");
  lua_rawseti(L, -2, 9);
  lua_pushstring(L, "MouseY");
  lua_rawseti(L, -2, 10);
  lua_pushstring(L, "Seconds");
  lua_rawseti(L, -2, 11);
  lua_pushstring(L, "Micros");
  lua_rawseti(L, -2, 12);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_IntuiMessage(lua_State *L) {
  if (luaL_newmetatable(L, "IntuiMessage")) {
    lua_pushcfunction(L, _lua_gen_IntuiMessage_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_IntuiMessage_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_IntuiMessage_constructor);
    lua_setglobal(L, "IntuiMessage");
    _lua_gen_IntuiMessage_install_keys(L);
    lua_pushstring(L, "IntuiMessage");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_IBox_newindex(lua_State *L)
{
  struct IBox *obj = *(struct IBox **)luaL_checkudata(L, 1, "IBox");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "Left") == 0) {
    obj->Left = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Top") == 0) {
    obj->Top = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Width") == 0) {
    obj->Width = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  if (strcmp(key, "Height") == 0) {
    obj->Height = (WORD)luaL_checkinteger(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_IBox_constructor(lua_State *L)
{
  // Allocate pointer-to-struct IBox in userdata
  struct IBox **objp = lua_newuserdata(L, sizeof(struct IBox *));
  *objp = malloc(sizeof(struct IBox));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct IBox));

  // Set metatable
  luaL_getmetatable(L, "IBox");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_IBox_index(lua_State *L)
{
  struct IBox *obj = *(struct IBox **)luaL_checkudata(L, 1, "IBox");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "Left") == 0) {
    lua_pushinteger(L, obj->Left);
    return 1;
  }
  if (strcmp(key, "Top") == 0) {
    lua_pushinteger(L, obj->Top);
    return 1;
  }
  if (strcmp(key, "Width") == 0) {
    lua_pushinteger(L, obj->Width);
    return 1;
  }
  if (strcmp(key, "Height") == 0) {
    lua_pushinteger(L, obj->Height);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct IBox));
    return 1;
}

  return 0;
}

static void
_lua_gen_IBox_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_pushstring(L, "Left");
  lua_rawseti(L, -2, 1);
  lua_pushstring(L, "Top");
  lua_rawseti(L, -2, 2);
  lua_pushstring(L, "Width");
  lua_rawseti(L, -2, 3);
  lua_pushstring(L, "Height");
  lua_rawseti(L, -2, 4);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_IBox(lua_State *L) {
  if (luaL_newmetatable(L, "IBox")) {
    lua_pushcfunction(L, _lua_gen_IBox_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_IBox_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_IBox_constructor);
    lua_setglobal(L, "IBox");
    _lua_gen_IBox_install_keys(L);
    lua_pushstring(L, "IBox");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_gen_ScreenBuffer_newindex(lua_State *L)
{
  struct ScreenBuffer *obj = *(struct ScreenBuffer **)luaL_checkudata(L, 1, "ScreenBuffer");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "sb_BitMap") == 0) {
    // finder 1
    //obj->sb_BitMap = *(struct BitMap **)luaL_checkudata(L, 3, "BitMap");
    obj->sb_BitMap = (struct BitMap *)_lua_gen_checkBitMap(L, 3);
    return 0;
  }
  if (strcmp(key, "sb_DBufInfo") == 0) {
    // finder 1
    //obj->sb_DBufInfo = *(struct DBufInfo **)luaL_checkudata(L, 3, "DBufInfo");
    obj->sb_DBufInfo = (struct DBufInfo *)_lua_gen_checkDBufInfo(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_ScreenBuffer_constructor(lua_State *L)
{
  // Allocate pointer-to-struct ScreenBuffer in userdata
  struct ScreenBuffer **objp = lua_newuserdata(L, sizeof(struct ScreenBuffer *));
  *objp = malloc(sizeof(struct ScreenBuffer));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(struct ScreenBuffer));

  // Set metatable
  luaL_getmetatable(L, "ScreenBuffer");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_ScreenBuffer_index(lua_State *L)
{
  struct ScreenBuffer *obj = *(struct ScreenBuffer **)luaL_checkudata(L, 1, "ScreenBuffer");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "sb_BitMap") == 0) {
    struct BitMap **ud = (struct BitMap **)lua_newuserdata(L, sizeof(struct BitMap *));
    *ud = (struct BitMap*)obj->sb_BitMap;
    luaL_getmetatable(L, "BitMap");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "sb_DBufInfo") == 0) {
    struct DBufInfo **ud = (struct DBufInfo **)lua_newuserdata(L, sizeof(struct DBufInfo *));
    *ud = (struct DBufInfo*)obj->sb_DBufInfo;
    luaL_getmetatable(L, "DBufInfo");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(struct ScreenBuffer));
    return 1;
}

  return 0;
}

static void
_lua_gen_ScreenBuffer_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_ScreenBuffer(lua_State *L) {
  if (luaL_newmetatable(L, "ScreenBuffer")) {
    lua_pushcfunction(L, _lua_gen_ScreenBuffer_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_ScreenBuffer_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_ScreenBuffer_constructor);
    lua_setglobal(L, "ScreenBuffer");
    _lua_gen_ScreenBuffer_install_keys(L);
    lua_pushstring(L, "ScreenBuffer");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static int
_lua_OpenIntuition(lua_State* L)
{
  (void)L;
  OpenIntuition();
  return 0;
}

static int
_lua_Intuition(lua_State* L)
{
  (void)L;
  struct InputEvent * iEvent = _lua_gen_checkInputEvent(L, 1);
  Intuition(iEvent);
  return 0;
}

static int
_lua_ClearDMRequest(lua_State* L)
{
  (void)L;
  struct Window * window = _lua_gen_checkWindow(L, 1);
  BOOL _result = ClearDMRequest(window);
  lua_pushboolean(L, _result);
  return 1;
}

static int
_lua_ClearMenuStrip(lua_State* L)
{
  (void)L;
  struct Window * window = _lua_gen_checkWindow(L, 1);
  ClearMenuStrip(window);
  return 0;
}

static int
_lua_ClearPointer(lua_State* L)
{
  (void)L;
  struct Window * window = _lua_gen_checkWindow(L, 1);
  ClearPointer(window);
  return 0;
}

static int
_lua_CloseScreen(lua_State* L)
{
  (void)L;
  struct Screen * screen = _lua_gen_checkScreen(L, 1);
  BOOL _result = CloseScreen(screen);
  lua_pushboolean(L, _result);
  return 1;
}

static int
_lua_CloseWindow(lua_State* L)
{
  (void)L;
  struct Window * window = _lua_gen_checkWindow(L, 1);
  CloseWindow(window);
  return 0;
}

static int
_lua_CloseWorkBench(lua_State* L)
{
  (void)L;
  LONG _result = CloseWorkBench();
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_CurrentTime(lua_State* L)
{
  (void)L;
  ULONG * seconds = lua_touserdata(L, 1);
  ULONG * micros = lua_touserdata(L, 2);
  CurrentTime(seconds, micros);
  return 0;
}

static int
_lua_DisplayAlert(lua_State* L)
{
  (void)L;
  ULONG alertNumber = luaL_checkinteger(L, 1);
  CONST_STRPTR string = amiga_checkConstNullableString(L, 2);
  ULONG height = luaL_checkinteger(L, 3);
  BOOL _result = DisplayAlert(alertNumber, string, height);
  lua_pushboolean(L, _result);
  return 1;
}

static int
_lua_DisplayBeep(lua_State* L)
{
  (void)L;
  struct Screen * screen = _lua_gen_checkScreen(L, 1);
  DisplayBeep(screen);
  return 0;
}

static int
_lua_EndRequest(lua_State* L)
{
  (void)L;
  struct Requester * requester = _lua_gen_checkRequester(L, 1);
  struct Window * window = _lua_gen_checkWindow(L, 2);
  EndRequest(requester, window);
  return 0;
}

static int
_lua_InitRequester(lua_State* L)
{
  (void)L;
  struct Requester * requester = _lua_gen_checkRequester(L, 1);
  InitRequester(requester);
  return 0;
}

static int
_lua_ItemAddress(lua_State* L)
{
  (void)L;
  const struct Menu * menuStrip = _lua_gen_checkMenu(L, 1);
  ULONG menuNumber = luaL_checkinteger(L, 2);
  struct MenuItem * _result = ItemAddress(menuStrip, menuNumber);
  _lua_gen_pushMenuItem(L, _result);
  return 1;
}

static int
_lua_ModifyIDCMP(lua_State* L)
{
  (void)L;
  struct Window * window = _lua_gen_checkWindow(L, 1);
  ULONG flags = luaL_checkinteger(L, 2);
  BOOL _result = ModifyIDCMP(window, flags);
  lua_pushboolean(L, _result);
  return 1;
}

static int
_lua_MoveScreen(lua_State* L)
{
  (void)L;
  struct Screen * screen = _lua_gen_checkScreen(L, 1);
  LONG dx = luaL_checkinteger(L, 2);
  LONG dy = luaL_checkinteger(L, 3);
  MoveScreen(screen, dx, dy);
  return 0;
}

static int
_lua_MoveWindow(lua_State* L)
{
  (void)L;
  struct Window * window = _lua_gen_checkWindow(L, 1);
  LONG dx = luaL_checkinteger(L, 2);
  LONG dy = luaL_checkinteger(L, 3);
  MoveWindow(window, dx, dy);
  return 0;
}

static int
_lua_OffMenu(lua_State* L)
{
  (void)L;
  struct Window * window = _lua_gen_checkWindow(L, 1);
  ULONG menuNumber = luaL_checkinteger(L, 2);
  OffMenu(window, menuNumber);
  return 0;
}

static int
_lua_OnMenu(lua_State* L)
{
  (void)L;
  struct Window * window = _lua_gen_checkWindow(L, 1);
  ULONG menuNumber = luaL_checkinteger(L, 2);
  OnMenu(window, menuNumber);
  return 0;
}

static int
_lua_OpenScreen(lua_State* L)
{
  (void)L;
  const struct NewScreen * newScreen = _lua_gen_checkNewScreen(L, 1);
  struct Screen * _result = OpenScreen(newScreen);
  _lua_gen_pushScreen(L, _result);
  return 1;
}

static int
_lua_OpenWindow(lua_State* L)
{
  (void)L;
  const struct NewWindow * newWindow = _lua_gen_checkNewWindow(L, 1);
  struct Window * _result = OpenWindow(newWindow);
  _lua_gen_pushWindow(L, _result);
  return 1;
}

static int
_lua_OpenWorkBench(lua_State* L)
{
  (void)L;
  ULONG _result = OpenWorkBench();
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_RemoveGadget(lua_State* L)
{
  (void)L;
  struct Window * window = _lua_gen_checkWindow(L, 1);
  struct Gadget * gadget = _lua_gen_checkGadget(L, 2);
  UWORD _result = RemoveGadget(window, gadget);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_ReportMouse(lua_State* L)
{
  (void)L;
  LONG flag = luaL_checkinteger(L, 1);
  struct Window * window = _lua_gen_checkWindow(L, 2);
  ReportMouse(flag, window);
  return 0;
}

static int
_lua_ReportMouse1(lua_State* L)
{
  (void)L;
  struct Window * window = _lua_gen_checkWindow(L, 1);
  LONG flag = luaL_checkinteger(L, 2);
  ReportMouse1(window, flag);
  return 0;
}

static int
_lua_Request(lua_State* L)
{
  (void)L;
  struct Requester * requester = _lua_gen_checkRequester(L, 1);
  struct Window * window = _lua_gen_checkWindow(L, 2);
  BOOL _result = Request(requester, window);
  lua_pushboolean(L, _result);
  return 1;
}

static int
_lua_ScreenToBack(lua_State* L)
{
  (void)L;
  struct Screen * screen = _lua_gen_checkScreen(L, 1);
  ScreenToBack(screen);
  return 0;
}

static int
_lua_ScreenToFront(lua_State* L)
{
  (void)L;
  struct Screen * screen = _lua_gen_checkScreen(L, 1);
  ScreenToFront(screen);
  return 0;
}

static int
_lua_SetDMRequest(lua_State* L)
{
  (void)L;
  struct Window * window = _lua_gen_checkWindow(L, 1);
  struct Requester * requester = _lua_gen_checkRequester(L, 2);
  BOOL _result = SetDMRequest(window, requester);
  lua_pushboolean(L, _result);
  return 1;
}

static int
_lua_SetMenuStrip(lua_State* L)
{
  (void)L;
  struct Window * window = _lua_gen_checkWindow(L, 1);
  struct Menu * menu = _lua_gen_checkMenu(L, 2);
  BOOL _result = SetMenuStrip(window, menu);
  lua_pushboolean(L, _result);
  return 1;
}

static int
_lua_ShowTitle(lua_State* L)
{
  (void)L;
  struct Screen * screen = _lua_gen_checkScreen(L, 1);
  LONG showIt = luaL_checkinteger(L, 2);
  ShowTitle(screen, showIt);
  return 0;
}

static int
_lua_SizeWindow(lua_State* L)
{
  (void)L;
  struct Window * window = _lua_gen_checkWindow(L, 1);
  LONG dx = luaL_checkinteger(L, 2);
  LONG dy = luaL_checkinteger(L, 3);
  SizeWindow(window, dx, dy);
  return 0;
}

static int
_lua_ViewAddress(lua_State* L)
{
  (void)L;
  struct View * _result = ViewAddress();
  _lua_gen_pushView(L, _result);
  return 1;
}

static int
_lua_ViewPortAddress(lua_State* L)
{
  (void)L;
  const struct Window * window = _lua_gen_checkWindow(L, 1);
  struct ViewPort * _result = ViewPortAddress(window);
  _lua_gen_pushViewPort(L, _result);
  return 1;
}

static int
_lua_WindowToBack(lua_State* L)
{
  (void)L;
  struct Window * window = _lua_gen_checkWindow(L, 1);
  WindowToBack(window);
  return 0;
}

static int
_lua_WindowToFront(lua_State* L)
{
  (void)L;
  struct Window * window = _lua_gen_checkWindow(L, 1);
  WindowToFront(window);
  return 0;
}

static int
_lua_IntuiTextLength(lua_State* L)
{
  (void)L;
  const struct IntuiText * iText = _lua_gen_checkIntuiText(L, 1);
  LONG _result = IntuiTextLength(iText);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_WBenchToBack(lua_State* L)
{
  (void)L;
  BOOL _result = WBenchToBack();
  lua_pushboolean(L, _result);
  return 1;
}

static int
_lua_WBenchToFront(lua_State* L)
{
  (void)L;
  BOOL _result = WBenchToFront();
  lua_pushboolean(L, _result);
  return 1;
}

static int
_lua_BeginRefresh(lua_State* L)
{
  (void)L;
  struct Window * window = _lua_gen_checkWindow(L, 1);
  BeginRefresh(window);
  return 0;
}

static int
_lua_EndRefresh(lua_State* L)
{
  (void)L;
  struct Window * window = _lua_gen_checkWindow(L, 1);
  LONG complete = luaL_checkinteger(L, 2);
  EndRefresh(window, complete);
  return 0;
}

static int
_lua_FreeSysRequest(lua_State* L)
{
  (void)L;
  struct Window * window = _lua_gen_checkWindow(L, 1);
  FreeSysRequest(window);
  return 0;
}

static int
_lua_MakeScreen(lua_State* L)
{
  (void)L;
  struct Screen * screen = _lua_gen_checkScreen(L, 1);
  LONG _result = MakeScreen(screen);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_RemakeDisplay(lua_State* L)
{
  (void)L;
  LONG _result = RemakeDisplay();
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_RethinkDisplay(lua_State* L)
{
  (void)L;
  LONG _result = RethinkDisplay();
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_AlohaWorkbench(lua_State* L)
{
  (void)L;
  LONG wbport = luaL_checkinteger(L, 1);
  AlohaWorkbench(wbport);
  return 0;
}

static int
_lua_LockIBase(lua_State* L)
{
  (void)L;
  ULONG dontknow = luaL_checkinteger(L, 1);
  ULONG _result = LockIBase(dontknow);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_UnlockIBase(lua_State* L)
{
  (void)L;
  ULONG ibLock = luaL_checkinteger(L, 1);
  UnlockIBase(ibLock);
  return 0;
}

static int
_lua_ActivateWindow(lua_State* L)
{
  (void)L;
  struct Window * window = _lua_gen_checkWindow(L, 1);
  ActivateWindow(window);
  return 0;
}

static int
_lua_RefreshWindowFrame(lua_State* L)
{
  (void)L;
  struct Window * window = _lua_gen_checkWindow(L, 1);
  RefreshWindowFrame(window);
  return 0;
}

static int
_lua_SetEditHook(lua_State* L)
{
  (void)L;
  struct Hook * hook = _lua_gen_checkHook(L, 1);
  struct Hook * _result = SetEditHook(hook);
  _lua_gen_pushHook(L, _result);
  return 1;
}

static int
_lua_SetMouseQueue(lua_State* L)
{
  (void)L;
  struct Window * window = _lua_gen_checkWindow(L, 1);
  ULONG queueLength = luaL_checkinteger(L, 2);
  LONG _result = SetMouseQueue(window, queueLength);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_ZipWindow(lua_State* L)
{
  (void)L;
  struct Window * window = _lua_gen_checkWindow(L, 1);
  ZipWindow(window);
  return 0;
}

static int
_lua_LockPubScreen(lua_State* L)
{
  (void)L;
  CONST_STRPTR name = amiga_checkConstNullableString(L, 1);
  struct Screen * _result = LockPubScreen(name);
  _lua_gen_pushScreen(L, _result);
  return 1;
}

static int
_lua_UnlockPubScreen(lua_State* L)
{
  (void)L;
  CONST_STRPTR name = amiga_checkConstNullableString(L, 1);
  struct Screen * screen = _lua_gen_checkScreen(L, 2);
  UnlockPubScreen(name, screen);
  return 0;
}

static int
_lua_LockPubScreenList(lua_State* L)
{
  (void)L;
  struct List * _result = LockPubScreenList();
  _lua_gen_pushList(L, _result);
  return 1;
}

static int
_lua_UnlockPubScreenList(lua_State* L)
{
  (void)L;
  UnlockPubScreenList();
  return 0;
}

static int
_lua_NextPubScreen(lua_State* L)
{
  (void)L;
  const struct Screen * screen = _lua_gen_checkScreen(L, 1);
  STRPTR namebuf = amiga_checkNullableString(L, 2);
  STRPTR _result = NextPubScreen(screen, namebuf);
  lua_pushstring(L, _result);
  return 1;
}

static int
_lua_SetDefaultPubScreen(lua_State* L)
{
  (void)L;
  CONST_STRPTR name = amiga_checkConstNullableString(L, 1);
  SetDefaultPubScreen(name);
  return 0;
}

static int
_lua_SetPubScreenModes(lua_State* L)
{
  (void)L;
  ULONG modes = luaL_checkinteger(L, 1);
  UWORD _result = SetPubScreenModes(modes);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_PubScreenStatus(lua_State* L)
{
  (void)L;
  struct Screen * screen = _lua_gen_checkScreen(L, 1);
  ULONG statusFlags = luaL_checkinteger(L, 2);
  UWORD _result = PubScreenStatus(screen, statusFlags);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_ObtainGIRPort(lua_State* L)
{
  (void)L;
  struct GadgetInfo * gInfo = _lua_gen_checkGadgetInfo(L, 1);
  struct RastPort * _result = ObtainGIRPort(gInfo);
  _lua_gen_pushRastPort(L, _result);
  return 1;
}

static int
_lua_ReleaseGIRPort(lua_State* L)
{
  (void)L;
  struct RastPort * rp = _lua_gen_checkRastPort(L, 1);
  ReleaseGIRPort(rp);
  return 0;
}

static int
_lua_GetDefaultPubScreen(lua_State* L)
{
  (void)L;
  STRPTR nameBuffer = amiga_checkNullableString(L, 1);
  GetDefaultPubScreen(nameBuffer);
  return 0;
}

static int
_lua_OpenWindowTagList(lua_State* L)
{
  const struct NewWindow * newWindow = _lua_gen_checkNewWindow(L, 1);
  struct TagItem* tagList = NULL;
  if (!lua_isnoneornil(L, 2)) {
    struct TagItem _tags[32];
    amiga_doTagList(L, _tags, countof(_tags), 2);
    tagList = _tags;
  }
  struct Window * _result = OpenWindowTagList(newWindow, tagList);
  _lua_gen_pushWindow(L, _result);
  return 1;
}

static int
_lua_OpenWindowTags(lua_State* L)
{
  const struct NewWindow * newWindow = _lua_gen_checkNewWindow(L, 1);
  struct TagItem taglist[64];
  amiga_readVarTags(L, taglist, countof(taglist), 2);
  struct Window * _result = OpenWindowTagList(newWindow,  taglist);
  _lua_gen_pushWindow(L, _result);
  return 1;
}

static int
_lua_OpenScreenTagList(lua_State* L)
{
  const struct NewScreen * newScreen = _lua_gen_checkNewScreen(L, 1);
  struct TagItem* tagList = NULL;
  if (!lua_isnoneornil(L, 2)) {
    struct TagItem _tags[32];
    amiga_doTagList(L, _tags, countof(_tags), 2);
    tagList = _tags;
  }
  struct Screen * _result = OpenScreenTagList(newScreen, tagList);
  _lua_gen_pushScreen(L, _result);
  return 1;
}

static int
_lua_OpenScreenTags(lua_State* L)
{
  const struct NewScreen * newScreen = _lua_gen_checkNewScreen(L, 1);
  struct TagItem taglist[64];
  amiga_readVarTags(L, taglist, countof(taglist), 2);
  struct Screen * _result = OpenScreenTagList(newScreen,  taglist);
  _lua_gen_pushScreen(L, _result);
  return 1;
}

static int
_lua_PointInImage(lua_State* L)
{
  (void)L;
  ULONG point = luaL_checkinteger(L, 1);
  const struct Image * image = _lua_gen_checkImage(L, 2);
  BOOL _result = PointInImage(point, image);
  lua_pushboolean(L, _result);
  return 1;
}

static int
_lua_DisposeObject(lua_State* L)
{
  (void)L;
  APTR object = lua_touserdata(L, 1);
  DisposeObject(object);
  return 0;
}

static int
_lua_SetAttrsA(lua_State* L)
{
  APTR object = lua_touserdata(L, 1);
  struct TagItem* tagList = NULL;
  if (!lua_isnoneornil(L, 2)) {
    struct TagItem _tags[32];
    amiga_doTagList(L, _tags, countof(_tags), 2);
    tagList = _tags;
  }
  ULONG _result = SetAttrsA(object, tagList);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_SetAttrs(lua_State* L)
{
  APTR object = lua_touserdata(L, 1);
  struct TagItem taglist[64];
  amiga_readVarTags(L, taglist, countof(taglist), 2);
  ULONG _result = SetAttrsA(object,  taglist);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_GetAttr(lua_State* L)
{
  (void)L;
  ULONG attrID = luaL_checkinteger(L, 1);
  APTR object = lua_touserdata(L, 2);
  ULONG * storagePtr = lua_touserdata(L, 3);
  ULONG _result = GetAttr(attrID, object, storagePtr);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_NextObject(lua_State* L)
{
  (void)L;
  CONST_APTR objectPtrPtr = lua_touserdata(L, 1);
  APTR _result = NextObject(objectPtrPtr);
  lua_pushlightuserdata(L, _result);
  return 1;
}

static int
_lua_AddClass(lua_State* L)
{
  (void)L;
  struct IClass * classPtr = _lua_gen_checkIClass(L, 1);
  AddClass(classPtr);
  return 0;
}

static int
_lua_GetScreenDrawInfo(lua_State* L)
{
  (void)L;
  struct Screen * screen = _lua_gen_checkScreen(L, 1);
  struct DrawInfo * _result = GetScreenDrawInfo(screen);
  _lua_gen_pushDrawInfo(L, _result);
  return 1;
}

static int
_lua_ResetMenuStrip(lua_State* L)
{
  (void)L;
  struct Window * window = _lua_gen_checkWindow(L, 1);
  struct Menu * menu = _lua_gen_checkMenu(L, 2);
  BOOL _result = ResetMenuStrip(window, menu);
  lua_pushboolean(L, _result);
  return 1;
}

static int
_lua_RemoveClass(lua_State* L)
{
  (void)L;
  struct IClass * classPtr = _lua_gen_checkIClass(L, 1);
  RemoveClass(classPtr);
  return 0;
}

static int
_lua_FreeClass(lua_State* L)
{
  (void)L;
  struct IClass * classPtr = _lua_gen_checkIClass(L, 1);
  BOOL _result = FreeClass(classPtr);
  lua_pushboolean(L, _result);
  return 1;
}

static int
_lua_FreeScreenBuffer(lua_State* L)
{
  (void)L;
  struct Screen * sc = _lua_gen_checkScreen(L, 1);
  struct ScreenBuffer * sb = _lua_gen_checkScreenBuffer(L, 2);
  FreeScreenBuffer(sc, sb);
  return 0;
}

static int
_lua_ChangeScreenBuffer(lua_State* L)
{
  (void)L;
  struct Screen * sc = _lua_gen_checkScreen(L, 1);
  struct ScreenBuffer * sb = _lua_gen_checkScreenBuffer(L, 2);
  ULONG _result = ChangeScreenBuffer(sc, sb);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_ScreenDepth(lua_State* L)
{
  (void)L;
  struct Screen * screen = _lua_gen_checkScreen(L, 1);
  ULONG flags = luaL_checkinteger(L, 2);
  APTR reserved = lua_touserdata(L, 3);
  ScreenDepth(screen, flags, reserved);
  return 0;
}

static int
_lua_LendMenus(lua_State* L)
{
  (void)L;
  struct Window * fromwindow = _lua_gen_checkWindow(L, 1);
  struct Window * towindow = _lua_gen_checkWindow(L, 2);
  LendMenus(fromwindow, towindow);
  return 0;
}

static int
_lua_SetWindowPointerA(lua_State* L)
{
  struct Window * win = _lua_gen_checkWindow(L, 1);
  struct TagItem* taglist = NULL;
  if (!lua_isnoneornil(L, 2)) {
    struct TagItem _tags[32];
    amiga_doTagList(L, _tags, countof(_tags), 2);
    taglist = _tags;
  }
  SetWindowPointerA(win, taglist);
  return 0;
}

static int
_lua_SetWindowPointer(lua_State* L)
{
  struct Window * win = _lua_gen_checkWindow(L, 1);
  struct TagItem taglist[64];
  amiga_readVarTags(L, taglist, countof(taglist), 2);
  SetWindowPointerA(win,  taglist);
  return 0;
}

static int
_lua_TimedDisplayAlert(lua_State* L)
{
  (void)L;
  ULONG alertNumber = luaL_checkinteger(L, 1);
  CONST_STRPTR string = amiga_checkConstNullableString(L, 2);
  ULONG height = luaL_checkinteger(L, 3);
  ULONG time = luaL_checkinteger(L, 4);
  BOOL _result = TimedDisplayAlert(alertNumber, string, height, time);
  lua_pushboolean(L, _result);
  return 1;
}

static int
_lua_HelpControl(lua_State* L)
{
  (void)L;
  struct Window * win = _lua_gen_checkWindow(L, 1);
  ULONG flags = luaL_checkinteger(L, 2);
  HelpControl(win, flags);
  return 0;
}

static int
_lua_ShowWindow(lua_State* L)
{
  (void)L;
  struct Window * window = _lua_gen_checkWindow(L, 1);
  struct Window * other = _lua_gen_checkWindow(L, 2);
  BOOL _result = ShowWindow(window, other);
  lua_pushboolean(L, _result);
  return 1;
}

static int
_lua_HideWindow(lua_State* L)
{
  (void)L;
  struct Window * window = _lua_gen_checkWindow(L, 1);
  BOOL _result = HideWindow(window);
  lua_pushboolean(L, _result);
  return 1;
}

static int
_lua_IntuitionControlA(lua_State* L)
{
  APTR object = lua_touserdata(L, 1);
  struct TagItem* taglist = NULL;
  if (!lua_isnoneornil(L, 2)) {
    struct TagItem _tags[32];
    amiga_doTagList(L, _tags, countof(_tags), 2);
    taglist = _tags;
  }
  ULONG _result = IntuitionControlA(object, taglist);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_IntuitionControl(lua_State* L)
{
  APTR object = lua_touserdata(L, 1);
  struct TagItem taglist[64];
  amiga_readVarTags(L, taglist, countof(taglist), 2);
  ULONG _result = IntuitionControlA(object,  taglist);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_CreateGadgetA(lua_State* L)
{
  ULONG kind = luaL_checkinteger(L, 1);
  struct Gadget * gad = _lua_gen_checkGadget(L, 2);
  struct NewGadget * ng = _lua_gen_checkNewGadget(L, 3);
  struct TagItem* taglist = NULL;
  if (!lua_isnoneornil(L, 4)) {
    struct TagItem _tags[32];
    amiga_doTagList(L, _tags, countof(_tags), 4);
    taglist = _tags;
  }
  struct Gadget * _result = CreateGadgetA(kind, gad, ng, taglist);
  _lua_gen_pushGadget(L, _result);
  return 1;
}

static int
_lua_CreateGadget(lua_State* L)
{
  ULONG kind = luaL_checkinteger(L, 1);
  struct Gadget * gad = _lua_gen_checkGadget(L, 2);
  struct NewGadget * ng = _lua_gen_checkNewGadget(L, 3);
  struct TagItem taglist[64];
  amiga_readVarTags(L, taglist, countof(taglist), 4);
  struct Gadget * _result = CreateGadgetA(kind, gad, ng,  taglist);
  _lua_gen_pushGadget(L, _result);
  return 1;
}

static int
_lua_FreeGadgets(lua_State* L)
{
  (void)L;
  struct Gadget * gad = _lua_gen_checkGadget(L, 1);
  FreeGadgets(gad);
  return 0;
}

static int
_lua_GT_SetGadgetAttrsA(lua_State* L)
{
  struct Gadget * gad = _lua_gen_checkGadget(L, 1);
  struct Window * win = _lua_gen_checkWindow(L, 2);
  struct Requester * req = _lua_gen_checkRequester(L, 3);
  struct TagItem* taglist = NULL;
  if (!lua_isnoneornil(L, 4)) {
    struct TagItem _tags[32];
    amiga_doTagList(L, _tags, countof(_tags), 4);
    taglist = _tags;
  }
  GT_SetGadgetAttrsA(gad, win, req, taglist);
  return 0;
}

static int
_lua_GT_SetGadgetAttrs(lua_State* L)
{
  struct Gadget * gad = _lua_gen_checkGadget(L, 1);
  struct Window * win = _lua_gen_checkWindow(L, 2);
  struct Requester * req = _lua_gen_checkRequester(L, 3);
  struct TagItem taglist[64];
  amiga_readVarTags(L, taglist, countof(taglist), 4);
  GT_SetGadgetAttrsA(gad, win, req,  taglist);
  return 0;
}

static int
_lua_CreateMenusA(lua_State* L)
{
  const struct NewMenu * newmenu = _lua_gen_checkNewMenu(L, 1);
  struct TagItem* taglist = NULL;
  if (!lua_isnoneornil(L, 2)) {
    struct TagItem _tags[32];
    amiga_doTagList(L, _tags, countof(_tags), 2);
    taglist = _tags;
  }
  struct Menu * _result = CreateMenusA(newmenu, taglist);
  _lua_gen_pushMenu(L, _result);
  return 1;
}

static int
_lua_CreateMenus(lua_State* L)
{
  const struct NewMenu * newmenu = _lua_gen_checkNewMenu(L, 1);
  struct TagItem taglist[64];
  amiga_readVarTags(L, taglist, countof(taglist), 2);
  struct Menu * _result = CreateMenusA(newmenu,  taglist);
  _lua_gen_pushMenu(L, _result);
  return 1;
}

static int
_lua_FreeMenus(lua_State* L)
{
  (void)L;
  struct Menu * menu = _lua_gen_checkMenu(L, 1);
  FreeMenus(menu);
  return 0;
}

static int
_lua_LayoutMenuItemsA(lua_State* L)
{
  struct MenuItem * firstitem = _lua_gen_checkMenuItem(L, 1);
  APTR vi = lua_touserdata(L, 2);
  struct TagItem* taglist = NULL;
  if (!lua_isnoneornil(L, 3)) {
    struct TagItem _tags[32];
    amiga_doTagList(L, _tags, countof(_tags), 3);
    taglist = _tags;
  }
  BOOL _result = LayoutMenuItemsA(firstitem, vi, taglist);
  lua_pushboolean(L, _result);
  return 1;
}

static int
_lua_LayoutMenuItems(lua_State* L)
{
  struct MenuItem * firstitem = _lua_gen_checkMenuItem(L, 1);
  APTR vi = lua_touserdata(L, 2);
  struct TagItem taglist[64];
  amiga_readVarTags(L, taglist, countof(taglist), 3);
  BOOL _result = LayoutMenuItemsA(firstitem, vi,  taglist);
  lua_pushboolean(L, _result);
  return 1;
}

static int
_lua_LayoutMenusA(lua_State* L)
{
  struct Menu * firstmenu = _lua_gen_checkMenu(L, 1);
  APTR vi = lua_touserdata(L, 2);
  struct TagItem* taglist = NULL;
  if (!lua_isnoneornil(L, 3)) {
    struct TagItem _tags[32];
    amiga_doTagList(L, _tags, countof(_tags), 3);
    taglist = _tags;
  }
  BOOL _result = LayoutMenusA(firstmenu, vi, taglist);
  lua_pushboolean(L, _result);
  return 1;
}

static int
_lua_LayoutMenus(lua_State* L)
{
  struct Menu * firstmenu = _lua_gen_checkMenu(L, 1);
  APTR vi = lua_touserdata(L, 2);
  struct TagItem taglist[64];
  amiga_readVarTags(L, taglist, countof(taglist), 3);
  BOOL _result = LayoutMenusA(firstmenu, vi,  taglist);
  lua_pushboolean(L, _result);
  return 1;
}

static int
_lua_GT_GetIMsg(lua_State* L)
{
  (void)L;
  struct MsgPort * iport = _lua_gen_checkMsgPort(L, 1);
  struct IntuiMessage * _result = GT_GetIMsg(iport);
  _lua_gen_pushIntuiMessage(L, _result);
  return 1;
}

static int
_lua_GT_ReplyIMsg(lua_State* L)
{
  (void)L;
  struct IntuiMessage * imsg = _lua_gen_checkIntuiMessage(L, 1);
  GT_ReplyIMsg(imsg);
  return 0;
}

static int
_lua_GT_RefreshWindow(lua_State* L)
{
  (void)L;
  struct Window * win = _lua_gen_checkWindow(L, 1);
  struct Requester * req = _lua_gen_checkRequester(L, 2);
  GT_RefreshWindow(win, req);
  return 0;
}

static int
_lua_GT_BeginRefresh(lua_State* L)
{
  (void)L;
  struct Window * win = _lua_gen_checkWindow(L, 1);
  GT_BeginRefresh(win);
  return 0;
}

static int
_lua_GT_EndRefresh(lua_State* L)
{
  (void)L;
  struct Window * win = _lua_gen_checkWindow(L, 1);
  LONG complete = luaL_checkinteger(L, 2);
  GT_EndRefresh(win, complete);
  return 0;
}

static int
_lua_GT_FilterIMsg(lua_State* L)
{
  (void)L;
  const struct IntuiMessage * imsg = _lua_gen_checkIntuiMessage(L, 1);
  struct IntuiMessage * _result = GT_FilterIMsg(imsg);
  _lua_gen_pushIntuiMessage(L, _result);
  return 1;
}

static int
_lua_GT_PostFilterIMsg(lua_State* L)
{
  (void)L;
  struct IntuiMessage * imsg = _lua_gen_checkIntuiMessage(L, 1);
  struct IntuiMessage * _result = GT_PostFilterIMsg(imsg);
  _lua_gen_pushIntuiMessage(L, _result);
  return 1;
}

static int
_lua_CreateContext(lua_State* L)
{
  (void)L;
  struct Gadget ** glistptr = amiga_checkGadgetPtr(L, 1);
  struct Gadget * _result = CreateContext(glistptr);
  _lua_gen_pushGadget(L, _result);
  return 1;
}

static int
_lua_DrawBevelBoxA(lua_State* L)
{
  struct RastPort * rport = _lua_gen_checkRastPort(L, 1);
  LONG left = luaL_checkinteger(L, 2);
  LONG top = luaL_checkinteger(L, 3);
  LONG width = luaL_checkinteger(L, 4);
  LONG height = luaL_checkinteger(L, 5);
  struct TagItem* taglist = NULL;
  if (!lua_isnoneornil(L, 6)) {
    struct TagItem _tags[32];
    amiga_doTagList(L, _tags, countof(_tags), 6);
    taglist = _tags;
  }
  DrawBevelBoxA(rport, left, top, width, height, taglist);
  return 0;
}

static int
_lua_DrawBevelBox(lua_State* L)
{
  struct RastPort * rport = _lua_gen_checkRastPort(L, 1);
  LONG left = luaL_checkinteger(L, 2);
  LONG top = luaL_checkinteger(L, 3);
  LONG width = luaL_checkinteger(L, 4);
  LONG height = luaL_checkinteger(L, 5);
  struct TagItem taglist[64];
  amiga_readVarTags(L, taglist, countof(taglist), 6);
  DrawBevelBoxA(rport, left, top, width, height,  taglist);
  return 0;
}

static int
_lua_GetVisualInfoA(lua_State* L)
{
  struct Screen * screen = _lua_gen_checkScreen(L, 1);
  struct TagItem* taglist = NULL;
  if (!lua_isnoneornil(L, 2)) {
    struct TagItem _tags[32];
    amiga_doTagList(L, _tags, countof(_tags), 2);
    taglist = _tags;
  }
  APTR _result = GetVisualInfoA(screen, taglist);
  lua_pushlightuserdata(L, _result);
  return 1;
}

static int
_lua_GetVisualInfo(lua_State* L)
{
  struct Screen * screen = _lua_gen_checkScreen(L, 1);
  struct TagItem taglist[64];
  amiga_readVarTags(L, taglist, countof(taglist), 2);
  APTR _result = GetVisualInfoA(screen,  taglist);
  lua_pushlightuserdata(L, _result);
  return 1;
}

static int
_lua_FreeVisualInfo(lua_State* L)
{
  (void)L;
  APTR vi = lua_touserdata(L, 1);
  FreeVisualInfo(vi);
  return 0;
}

static int
_lua_SetDesignFontA(lua_State* L)
{
  APTR vi = lua_touserdata(L, 1);
  struct TextAttr * tattr = _lua_gen_checkTextAttr(L, 2);
  struct TagItem* tags = NULL;
  if (!lua_isnoneornil(L, 3)) {
    struct TagItem _tags[32];
    amiga_doTagList(L, _tags, countof(_tags), 3);
    tags = _tags;
  }
  LONG _result = SetDesignFontA(vi, tattr, tags);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_SetDesignFont(lua_State* L)
{
  APTR vi = lua_touserdata(L, 1);
  struct TextAttr * tattr = _lua_gen_checkTextAttr(L, 2);
  struct TagItem taglist[64];
  amiga_readVarTags(L, taglist, countof(taglist), 3);
  LONG _result = SetDesignFontA(vi, tattr,  taglist);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_ScaleGadgetRectA(lua_State* L)
{
  struct NewGadget * ng = _lua_gen_checkNewGadget(L, 1);
  struct TagItem* tags = NULL;
  if (!lua_isnoneornil(L, 2)) {
    struct TagItem _tags[32];
    amiga_doTagList(L, _tags, countof(_tags), 2);
    tags = _tags;
  }
  LONG _result = ScaleGadgetRectA(ng, tags);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_ScaleGadgetRect(lua_State* L)
{
  struct NewGadget * ng = _lua_gen_checkNewGadget(L, 1);
  struct TagItem taglist[64];
  amiga_readVarTags(L, taglist, countof(taglist), 2);
  LONG _result = ScaleGadgetRectA(ng,  taglist);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_GT_GetGadgetAttrsA(lua_State* L)
{
  struct Gadget * gad = _lua_gen_checkGadget(L, 1);
  struct Window * win = _lua_gen_checkWindow(L, 2);
  struct Requester * req = _lua_gen_checkRequester(L, 3);
  struct TagItem* taglist = NULL;
  if (!lua_isnoneornil(L, 4)) {
    struct TagItem _tags[32];
    amiga_doTagList(L, _tags, countof(_tags), 4);
    taglist = _tags;
  }
  LONG _result = GT_GetGadgetAttrsA(gad, win, req, taglist);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_GT_GetGadgetAttrs(lua_State* L)
{
  struct Gadget * gad = _lua_gen_checkGadget(L, 1);
  struct Window * win = _lua_gen_checkWindow(L, 2);
  struct Requester * req = _lua_gen_checkRequester(L, 3);
  struct TagItem taglist[64];
  amiga_readVarTags(L, taglist, countof(taglist), 4);
  LONG _result = GT_GetGadgetAttrsA(gad, win, req,  taglist);
  lua_pushinteger(L, _result);
  return 1;
}

static int
_lua_gen_GadgetPtr_newindex(lua_State *L)
{
  GadgetPtr *obj = *(GadgetPtr **)luaL_checkudata(L, 1, "GadgetPtr");
  const char *key = luaL_checkstring(L, 2);
  (void)key;(void)obj;
  if (strcmp(key, "ptr") == 0) {
    // finder 1
    //obj->ptr = *(struct Gadget **)luaL_checkudata(L, 3, "Gadget");
    obj->ptr = (struct Gadget *)_lua_gen_checkGadget(L, 3);
    return 0;
  }
  return 0;
}


static int
_lua_GadgetPtr_constructor(lua_State *L)
{
  // Allocate pointer-to-GadgetPtr in userdata
  GadgetPtr **objp = lua_newuserdata(L, sizeof(GadgetPtr *));
  *objp = malloc(sizeof(GadgetPtr));
  if (!*objp) return luaL_error(L, "out of memory");
  memset(*objp, 0, sizeof(GadgetPtr));

  // Set metatable
  luaL_getmetatable(L, "GadgetPtr");
  lua_setmetatable(L, -2);

  // If a table is passed, use __newindex to copy fields
  if (lua_istable(L, 1)) {
    lua_insert(L, 1); // move userdata below table
    lua_pushnil(L); // first key
    while (lua_next(L, 2) != 0) {
      lua_pushvalue(L, -2); // copy key
      lua_pushvalue(L, -2); // copy value
      lua_settable(L, 1);   // userdata[key] = value (via __newindex)
      lua_pop(L, 1); // pop original value, keep key
    }
    lua_remove(L, 2); // remove table, leave userdata
  }

  return 1; // return userdata
}

static int
_lua_gen_GadgetPtr_index(lua_State *L)
{
  GadgetPtr *obj = *(GadgetPtr **)luaL_checkudata(L, 1, "GadgetPtr");
  (void)obj;
  const char *key = luaL_checkstring(L, 2);
  if (strcmp(key, "ptr") == 0) {
    struct Gadget **ud = (struct Gadget **)lua_newuserdata(L, sizeof(struct Gadget *));
    *ud = (struct Gadget*)obj->ptr;
    luaL_getmetatable(L, "Gadget");
    lua_setmetatable(L, -2);
    return 1;
  }
  if (strcmp(key, "__size") == 0) {
    lua_pushinteger(L, sizeof(GadgetPtr));
    return 1;
}

  return 0;
}

static void
_lua_gen_GadgetPtr_install_keys(lua_State *L)
{
  lua_newtable(L);
  lua_setfield(L, -2, "__keys");
}

static void
_lua_gen_install_meta_GadgetPtr(lua_State *L) {
  if (luaL_newmetatable(L, "GadgetPtr")) {
    lua_pushcfunction(L, _lua_gen_GadgetPtr_index);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, _lua_gen_GadgetPtr_newindex);
    lua_setfield(L, -2, "__newindex");
    lua_pushcfunction(L, _lua_GadgetPtr_constructor);
    lua_setglobal(L, "GadgetPtr");
    _lua_gen_GadgetPtr_install_keys(L);
    lua_pushstring(L, "GadgetPtr");
    lua_setfield(L, -2, "__name");
  }
  lua_pop(L, 1);
}

static void
_lua_gen_install_defines(lua_State *L)
{
  lua_pushinteger(L, TRUE);
  lua_setglobal(L, "TRUE");
  lua_pushinteger(L, ERROR_NO_FREE_STORE);
  lua_setglobal(L, "ERROR_NO_FREE_STORE");
  lua_pushinteger(L, RETURN_OK);
  lua_setglobal(L, "RETURN_OK");
  lua_pushinteger(L, MEMF_PUBLIC);
  lua_setglobal(L, "MEMF_PUBLIC");
  lua_pushinteger(L, MEMF_CLEAR);
  lua_setglobal(L, "MEMF_CLEAR");
  lua_pushinteger(L, MEMF_CHIP);
  lua_setglobal(L, "MEMF_CHIP");
  lua_pushinteger(L, MEMF_FAST);
  lua_setglobal(L, "MEMF_FAST");
  lua_pushinteger(L, MODE_OLDFILE);
  lua_setglobal(L, "MODE_OLDFILE");
  lua_pushinteger(L, MODE_NEWFILE);
  lua_setglobal(L, "MODE_NEWFILE");
  lua_pushinteger(L, MODE_READWRITE);
  lua_setglobal(L, "MODE_READWRITE");
  lua_pushinteger(L, DOSTRUE);
  lua_setglobal(L, "DOSTRUE");
  lua_pushinteger(L, DOSFALSE);
  lua_setglobal(L, "DOSFALSE");
  lua_pushinteger(L, WA_Left);
  lua_setglobal(L, "WA_Left");
  lua_pushinteger(L, WA_Top);
  lua_setglobal(L, "WA_Top");
  lua_pushinteger(L, WA_Width);
  lua_setglobal(L, "WA_Width");
  lua_pushinteger(L, WA_Height);
  lua_setglobal(L, "WA_Height");
  lua_pushinteger(L, WA_DetailPen);
  lua_setglobal(L, "WA_DetailPen");
  lua_pushinteger(L, WA_BlockPen);
  lua_setglobal(L, "WA_BlockPen");
  lua_pushinteger(L, WA_IDCMP);
  lua_setglobal(L, "WA_IDCMP");
  lua_pushinteger(L, WA_Flags);
  lua_setglobal(L, "WA_Flags");
  lua_pushinteger(L, WA_Gadgets);
  lua_setglobal(L, "WA_Gadgets");
  lua_pushinteger(L, WA_Checkmark);
  lua_setglobal(L, "WA_Checkmark");
  lua_pushinteger(L, WA_Title);
  lua_setglobal(L, "WA_Title");
  lua_pushinteger(L, WA_ScreenTitle);
  lua_setglobal(L, "WA_ScreenTitle");
  lua_pushinteger(L, WA_CustomScreen);
  lua_setglobal(L, "WA_CustomScreen");
  lua_pushinteger(L, WA_SuperBitMap);
  lua_setglobal(L, "WA_SuperBitMap");
  lua_pushinteger(L, WA_MinWidth);
  lua_setglobal(L, "WA_MinWidth");
  lua_pushinteger(L, WA_MinHeight);
  lua_setglobal(L, "WA_MinHeight");
  lua_pushinteger(L, WA_MaxWidth);
  lua_setglobal(L, "WA_MaxWidth");
  lua_pushinteger(L, WA_MaxHeight);
  lua_setglobal(L, "WA_MaxHeight");
  lua_pushinteger(L, WA_InnerWidth);
  lua_setglobal(L, "WA_InnerWidth");
  lua_pushinteger(L, WA_InnerHeight);
  lua_setglobal(L, "WA_InnerHeight");
  lua_pushinteger(L, WA_PubScreenName);
  lua_setglobal(L, "WA_PubScreenName");
  lua_pushinteger(L, WA_PubScreen);
  lua_setglobal(L, "WA_PubScreen");
  lua_pushinteger(L, WA_PubScreenFallBack);
  lua_setglobal(L, "WA_PubScreenFallBack");
  lua_pushinteger(L, WA_WindowName);
  lua_setglobal(L, "WA_WindowName");
  lua_pushinteger(L, WA_Colors);
  lua_setglobal(L, "WA_Colors");
  lua_pushinteger(L, WA_Zoom);
  lua_setglobal(L, "WA_Zoom");
  lua_pushinteger(L, WA_MouseQueue);
  lua_setglobal(L, "WA_MouseQueue");
  lua_pushinteger(L, WA_BackFill);
  lua_setglobal(L, "WA_BackFill");
  lua_pushinteger(L, WA_RptQueue);
  lua_setglobal(L, "WA_RptQueue");
  lua_pushinteger(L, WA_SizeGadget);
  lua_setglobal(L, "WA_SizeGadget");
  lua_pushinteger(L, WA_DragBar);
  lua_setglobal(L, "WA_DragBar");
  lua_pushinteger(L, WA_DepthGadget);
  lua_setglobal(L, "WA_DepthGadget");
  lua_pushinteger(L, WA_CloseGadget);
  lua_setglobal(L, "WA_CloseGadget");
  lua_pushinteger(L, WA_Backdrop);
  lua_setglobal(L, "WA_Backdrop");
  lua_pushinteger(L, WA_ReportMouse);
  lua_setglobal(L, "WA_ReportMouse");
  lua_pushinteger(L, WA_NoCareRefresh);
  lua_setglobal(L, "WA_NoCareRefresh");
  lua_pushinteger(L, WA_Borderless);
  lua_setglobal(L, "WA_Borderless");
  lua_pushinteger(L, WA_Activate);
  lua_setglobal(L, "WA_Activate");
  lua_pushinteger(L, WA_RMBTrap);
  lua_setglobal(L, "WA_RMBTrap");
  lua_pushinteger(L, WA_WBenchWindow);
  lua_setglobal(L, "WA_WBenchWindow");
  lua_pushinteger(L, WA_SimpleRefresh);
  lua_setglobal(L, "WA_SimpleRefresh");
  lua_pushinteger(L, WA_SmartRefresh);
  lua_setglobal(L, "WA_SmartRefresh");
  lua_pushinteger(L, WA_SizeBRight);
  lua_setglobal(L, "WA_SizeBRight");
  lua_pushinteger(L, WA_SizeBBottom);
  lua_setglobal(L, "WA_SizeBBottom");
  lua_pushinteger(L, WA_AutoAdjust);
  lua_setglobal(L, "WA_AutoAdjust");
  lua_pushinteger(L, WA_GimmeZeroZero);
  lua_setglobal(L, "WA_GimmeZeroZero");
  lua_pushinteger(L, WA_MenuHelp);
  lua_setglobal(L, "WA_MenuHelp");
  lua_pushinteger(L, WA_NewLookMenus);
  lua_setglobal(L, "WA_NewLookMenus");
  lua_pushinteger(L, WA_AmigaKey);
  lua_setglobal(L, "WA_AmigaKey");
  lua_pushinteger(L, WA_NotifyDepth);
  lua_setglobal(L, "WA_NotifyDepth");
  lua_pushinteger(L, WA_Pointer);
  lua_setglobal(L, "WA_Pointer");
  lua_pushinteger(L, WA_BusyPointer);
  lua_setglobal(L, "WA_BusyPointer");
  lua_pushinteger(L, WA_PointerDelay);
  lua_setglobal(L, "WA_PointerDelay");
  lua_pushinteger(L, WA_TabletMessages);
  lua_setglobal(L, "WA_TabletMessages");
  lua_pushinteger(L, WA_HelpGroup);
  lua_setglobal(L, "WA_HelpGroup");
  lua_pushinteger(L, WA_HelpGroupWindow);
  lua_setglobal(L, "WA_HelpGroupWindow");
  lua_pushinteger(L, WA_Hidden);
  lua_setglobal(L, "WA_Hidden");
  lua_pushinteger(L, WA_PointerType);
  lua_setglobal(L, "WA_PointerType");
  lua_pushinteger(L, WA_IconifyGadget);
  lua_setglobal(L, "WA_IconifyGadget");
  lua_pushinteger(L, TAG_END);
  lua_setglobal(L, "TAG_END");
  lua_pushinteger(L, IDCMP_SIZEVERIFY);
  lua_setglobal(L, "IDCMP_SIZEVERIFY");
  lua_pushinteger(L, IDCMP_NEWSIZE);
  lua_setglobal(L, "IDCMP_NEWSIZE");
  lua_pushinteger(L, IDCMP_REFRESHWINDOW);
  lua_setglobal(L, "IDCMP_REFRESHWINDOW");
  lua_pushinteger(L, IDCMP_MOUSEBUTTONS);
  lua_setglobal(L, "IDCMP_MOUSEBUTTONS");
  lua_pushinteger(L, IDCMP_MOUSEMOVE);
  lua_setglobal(L, "IDCMP_MOUSEMOVE");
  lua_pushinteger(L, IDCMP_GADGETDOWN);
  lua_setglobal(L, "IDCMP_GADGETDOWN");
  lua_pushinteger(L, IDCMP_GADGETUP);
  lua_setglobal(L, "IDCMP_GADGETUP");
  lua_pushinteger(L, IDCMP_REQSET);
  lua_setglobal(L, "IDCMP_REQSET");
  lua_pushinteger(L, IDCMP_MENUPICK);
  lua_setglobal(L, "IDCMP_MENUPICK");
  lua_pushinteger(L, IDCMP_CLOSEWINDOW);
  lua_setglobal(L, "IDCMP_CLOSEWINDOW");
  lua_pushinteger(L, IDCMP_RAWKEY);
  lua_setglobal(L, "IDCMP_RAWKEY");
  lua_pushinteger(L, IDCMP_REQVERIFY);
  lua_setglobal(L, "IDCMP_REQVERIFY");
  lua_pushinteger(L, IDCMP_REQCLEAR);
  lua_setglobal(L, "IDCMP_REQCLEAR");
  lua_pushinteger(L, IDCMP_MENUVERIFY);
  lua_setglobal(L, "IDCMP_MENUVERIFY");
  lua_pushinteger(L, IDCMP_NEWPREFS);
  lua_setglobal(L, "IDCMP_NEWPREFS");
  lua_pushinteger(L, IDCMP_DISKINSERTED);
  lua_setglobal(L, "IDCMP_DISKINSERTED");
  lua_pushinteger(L, IDCMP_DISKREMOVED);
  lua_setglobal(L, "IDCMP_DISKREMOVED");
  lua_pushinteger(L, IDCMP_WBENCHMESSAGE);
  lua_setglobal(L, "IDCMP_WBENCHMESSAGE");
  lua_pushinteger(L, IDCMP_ACTIVEWINDOW);
  lua_setglobal(L, "IDCMP_ACTIVEWINDOW");
  lua_pushinteger(L, IDCMP_INACTIVEWINDOW);
  lua_setglobal(L, "IDCMP_INACTIVEWINDOW");
  lua_pushinteger(L, IDCMP_DELTAMOVE);
  lua_setglobal(L, "IDCMP_DELTAMOVE");
  lua_pushinteger(L, IDCMP_VANILLAKEY);
  lua_setglobal(L, "IDCMP_VANILLAKEY");
  lua_pushinteger(L, IDCMP_INTUITICKS);
  lua_setglobal(L, "IDCMP_INTUITICKS");
  lua_pushinteger(L, IDCMP_IDCMPUPDATE);
  lua_setglobal(L, "IDCMP_IDCMPUPDATE");
  lua_pushinteger(L, IDCMP_MENUHELP);
  lua_setglobal(L, "IDCMP_MENUHELP");
  lua_pushinteger(L, IDCMP_CHANGEWINDOW);
  lua_setglobal(L, "IDCMP_CHANGEWINDOW");
  lua_pushinteger(L, IDCMP_GADGETHELP);
  lua_setglobal(L, "IDCMP_GADGETHELP");
  lua_pushinteger(L, IDCMP_EXTENDEDMOUSE);
  lua_setglobal(L, "IDCMP_EXTENDEDMOUSE");
  lua_pushinteger(L, IDCMP_LONELYMESSAGE);
  lua_setglobal(L, "IDCMP_LONELYMESSAGE");
  lua_pushinteger(L, GENERIC_KIND);
  lua_setglobal(L, "GENERIC_KIND");
  lua_pushinteger(L, BUTTON_KIND);
  lua_setglobal(L, "BUTTON_KIND");
  lua_pushinteger(L, CHECKBOX_KIND);
  lua_setglobal(L, "CHECKBOX_KIND");
  lua_pushinteger(L, INTEGER_KIND);
  lua_setglobal(L, "INTEGER_KIND");
  lua_pushinteger(L, LISTVIEW_KIND);
  lua_setglobal(L, "LISTVIEW_KIND");
  lua_pushinteger(L, MX_KIND);
  lua_setglobal(L, "MX_KIND");
  lua_pushinteger(L, NUMBER_KIND);
  lua_setglobal(L, "NUMBER_KIND");
  lua_pushinteger(L, CYCLE_KIND);
  lua_setglobal(L, "CYCLE_KIND");
  lua_pushinteger(L, PALETTE_KIND);
  lua_setglobal(L, "PALETTE_KIND");
  lua_pushinteger(L, SCROLLER_KIND);
  lua_setglobal(L, "SCROLLER_KIND");
  lua_pushinteger(L, SLIDER_KIND);
  lua_setglobal(L, "SLIDER_KIND");
  lua_pushinteger(L, STRING_KIND);
  lua_setglobal(L, "STRING_KIND");
  lua_pushinteger(L, TEXT_KIND);
  lua_setglobal(L, "TEXT_KIND");
  lua_pushinteger(L, NUM_KINDS);
  lua_setglobal(L, "NUM_KINDS");
  lua_pushinteger(L, ARROWIDCMP);
  lua_setglobal(L, "ARROWIDCMP");
  lua_pushinteger(L, BUTTONIDCMP);
  lua_setglobal(L, "BUTTONIDCMP");
  lua_pushinteger(L, CHECKBOXIDCMP);
  lua_setglobal(L, "CHECKBOXIDCMP");
  lua_pushinteger(L, INTEGERIDCMP);
  lua_setglobal(L, "INTEGERIDCMP");
  lua_pushinteger(L, LISTVIEWIDCMP);
  lua_setglobal(L, "LISTVIEWIDCMP");
  lua_pushinteger(L, MXIDCMP);
  lua_setglobal(L, "MXIDCMP");
  lua_pushinteger(L, NUMBERIDCMP);
  lua_setglobal(L, "NUMBERIDCMP");
  lua_pushinteger(L, CYCLEIDCMP);
  lua_setglobal(L, "CYCLEIDCMP");
  lua_pushinteger(L, PALETTEIDCMP);
  lua_setglobal(L, "PALETTEIDCMP");
  lua_pushinteger(L, SCROLLERIDCMP);
  lua_setglobal(L, "SCROLLERIDCMP");
  lua_pushinteger(L, SLIDERIDCMP);
  lua_setglobal(L, "SLIDERIDCMP");
  lua_pushinteger(L, STRINGIDCMP);
  lua_setglobal(L, "STRINGIDCMP");
  lua_pushinteger(L, TEXTIDCMP);
  lua_setglobal(L, "TEXTIDCMP");
  lua_pushinteger(L, PLACETEXT_LEFT);
  lua_setglobal(L, "PLACETEXT_LEFT");
  lua_pushinteger(L, PLACETEXT_RIGHT);
  lua_setglobal(L, "PLACETEXT_RIGHT");
  lua_pushinteger(L, PLACETEXT_ABOVE);
  lua_setglobal(L, "PLACETEXT_ABOVE");
  lua_pushinteger(L, PLACETEXT_BELOW);
  lua_setglobal(L, "PLACETEXT_BELOW");
  lua_pushinteger(L, PLACETEXT_IN);
  lua_setglobal(L, "PLACETEXT_IN");
  lua_pushinteger(L, NG_HIGHLABEL);
  lua_setglobal(L, "NG_HIGHLABEL");
  lua_pushinteger(L, NG_GRIDLAYOUT);
  lua_setglobal(L, "NG_GRIDLAYOUT");
  lua_pushinteger(L, MENU_IMAGE);
  lua_setglobal(L, "MENU_IMAGE");
  lua_pushinteger(L, NM_TITLE);
  lua_setglobal(L, "NM_TITLE");
  lua_pushinteger(L, NM_ITEM);
  lua_setglobal(L, "NM_ITEM");
  lua_pushinteger(L, NM_SUB);
  lua_setglobal(L, "NM_SUB");
  lua_pushinteger(L, IM_ITEM);
  lua_setglobal(L, "IM_ITEM");
  lua_pushinteger(L, IM_SUB);
  lua_setglobal(L, "IM_SUB");
  lua_pushinteger(L, NM_END);
  lua_setglobal(L, "NM_END");
  lua_pushinteger(L, NM_IGNORE);
  lua_setglobal(L, "NM_IGNORE");
  lua_pushinteger(L, NM_BARLABEL);
  lua_setglobal(L, "NM_BARLABEL");
  lua_pushinteger(L, NM_MENUDISABLED);
  lua_setglobal(L, "NM_MENUDISABLED");
  lua_pushinteger(L, NM_ITEMDISABLED);
  lua_setglobal(L, "NM_ITEMDISABLED");
  lua_pushinteger(L, NM_COMMANDSTRING);
  lua_setglobal(L, "NM_COMMANDSTRING");
  lua_pushinteger(L, NM_FLAGMASK);
  lua_setglobal(L, "NM_FLAGMASK");
  lua_pushinteger(L, NM_FLAGMASK_V39);
  lua_setglobal(L, "NM_FLAGMASK_V39");
  lua_pushinteger(L, GTMENU_TRIMMED);
  lua_setglobal(L, "GTMENU_TRIMMED");
  lua_pushinteger(L, GTMENU_INVALID);
  lua_setglobal(L, "GTMENU_INVALID");
  lua_pushinteger(L, GTMENU_NOMEM);
  lua_setglobal(L, "GTMENU_NOMEM");
  lua_pushinteger(L, MX_WIDTH);
  lua_setglobal(L, "MX_WIDTH");
  lua_pushinteger(L, MX_HEIGHT);
  lua_setglobal(L, "MX_HEIGHT");
  lua_pushinteger(L, CHECKBOX_WIDTH);
  lua_setglobal(L, "CHECKBOX_WIDTH");
  lua_pushinteger(L, CHECKBOX_HEIGHT);
  lua_setglobal(L, "CHECKBOX_HEIGHT");
  lua_pushinteger(L, GT_TagBase);
  lua_setglobal(L, "GT_TagBase");
  lua_pushinteger(L, GTVI_NewWindow);
  lua_setglobal(L, "GTVI_NewWindow");
  lua_pushinteger(L, GTVI_NWTags);
  lua_setglobal(L, "GTVI_NWTags");
  lua_pushinteger(L, GT_Private0);
  lua_setglobal(L, "GT_Private0");
  lua_pushinteger(L, GTCB_Checked);
  lua_setglobal(L, "GTCB_Checked");
  lua_pushinteger(L, GTLV_Top);
  lua_setglobal(L, "GTLV_Top");
  lua_pushinteger(L, GTLV_Labels);
  lua_setglobal(L, "GTLV_Labels");
  lua_pushinteger(L, GTLV_ReadOnly);
  lua_setglobal(L, "GTLV_ReadOnly");
  lua_pushinteger(L, GTLV_ScrollWidth);
  lua_setglobal(L, "GTLV_ScrollWidth");
  lua_pushinteger(L, GTMX_Labels);
  lua_setglobal(L, "GTMX_Labels");
  lua_pushinteger(L, GTMX_Active);
  lua_setglobal(L, "GTMX_Active");
  lua_pushinteger(L, GTTX_Text);
  lua_setglobal(L, "GTTX_Text");
  lua_pushinteger(L, GTTX_CopyText);
  lua_setglobal(L, "GTTX_CopyText");
  lua_pushinteger(L, GTNM_Number);
  lua_setglobal(L, "GTNM_Number");
  lua_pushinteger(L, GTCY_Labels);
  lua_setglobal(L, "GTCY_Labels");
  lua_pushinteger(L, GTCY_Active);
  lua_setglobal(L, "GTCY_Active");
  lua_pushinteger(L, GTPA_Depth);
  lua_setglobal(L, "GTPA_Depth");
  lua_pushinteger(L, GTPA_Color);
  lua_setglobal(L, "GTPA_Color");
  lua_pushinteger(L, GTPA_ColorOffset);
  lua_setglobal(L, "GTPA_ColorOffset");
  lua_pushinteger(L, GTPA_IndicatorWidth);
  lua_setglobal(L, "GTPA_IndicatorWidth");
  lua_pushinteger(L, GTPA_IndicatorHeight);
  lua_setglobal(L, "GTPA_IndicatorHeight");
  lua_pushinteger(L, GTSC_Top);
  lua_setglobal(L, "GTSC_Top");
  lua_pushinteger(L, GTSC_Total);
  lua_setglobal(L, "GTSC_Total");
  lua_pushinteger(L, GTSC_Visible);
  lua_setglobal(L, "GTSC_Visible");
  lua_pushinteger(L, GTSC_Overlap);
  lua_setglobal(L, "GTSC_Overlap");
  lua_pushinteger(L, GTSL_Min);
  lua_setglobal(L, "GTSL_Min");
  lua_pushinteger(L, GTSL_Max);
  lua_setglobal(L, "GTSL_Max");
  lua_pushinteger(L, GTSL_Level);
  lua_setglobal(L, "GTSL_Level");
  lua_pushinteger(L, GTSL_MaxLevelLen);
  lua_setglobal(L, "GTSL_MaxLevelLen");
  lua_pushinteger(L, GTSL_LevelFormat);
  lua_setglobal(L, "GTSL_LevelFormat");
  lua_pushinteger(L, GTSL_LevelPlace);
  lua_setglobal(L, "GTSL_LevelPlace");
  lua_pushinteger(L, GTSL_DispFunc);
  lua_setglobal(L, "GTSL_DispFunc");
  lua_pushinteger(L, GTST_String);
  lua_setglobal(L, "GTST_String");
  lua_pushinteger(L, GTST_MaxChars);
  lua_setglobal(L, "GTST_MaxChars");
  lua_pushinteger(L, GTIN_Number);
  lua_setglobal(L, "GTIN_Number");
  lua_pushinteger(L, GTIN_MaxChars);
  lua_setglobal(L, "GTIN_MaxChars");
  lua_pushinteger(L, GTMN_TextAttr);
  lua_setglobal(L, "GTMN_TextAttr");
  lua_pushinteger(L, GTMN_FrontPen);
  lua_setglobal(L, "GTMN_FrontPen");
  lua_pushinteger(L, GTBB_Recessed);
  lua_setglobal(L, "GTBB_Recessed");
  lua_pushinteger(L, GT_VisualInfo);
  lua_setglobal(L, "GT_VisualInfo");
  lua_pushinteger(L, GTLV_ShowSelected);
  lua_setglobal(L, "GTLV_ShowSelected");
  lua_pushinteger(L, GTLV_Selected);
  lua_setglobal(L, "GTLV_Selected");
  lua_pushinteger(L, GT_Reserved1);
  lua_setglobal(L, "GT_Reserved1");
  lua_pushinteger(L, GTTX_Border);
  lua_setglobal(L, "GTTX_Border");
  lua_pushinteger(L, GTNM_Border);
  lua_setglobal(L, "GTNM_Border");
  lua_pushinteger(L, GTSC_Arrows);
  lua_setglobal(L, "GTSC_Arrows");
  lua_pushinteger(L, GTMN_Menu);
  lua_setglobal(L, "GTMN_Menu");
  lua_pushinteger(L, GTMX_Spacing);
  lua_setglobal(L, "GTMX_Spacing");
  lua_pushinteger(L, GTMN_FullMenu);
  lua_setglobal(L, "GTMN_FullMenu");
  lua_pushinteger(L, GTMN_SecondaryError);
  lua_setglobal(L, "GTMN_SecondaryError");
  lua_pushinteger(L, GT_Underscore);
  lua_setglobal(L, "GT_Underscore");
  lua_pushinteger(L, GTST_EditHook);
  lua_setglobal(L, "GTST_EditHook");
  lua_pushinteger(L, GTIN_EditHook);
  lua_setglobal(L, "GTIN_EditHook");
  lua_pushinteger(L, GTMN_Checkmark);
  lua_setglobal(L, "GTMN_Checkmark");
  lua_pushinteger(L, GTMN_AmigaKey);
  lua_setglobal(L, "GTMN_AmigaKey");
  lua_pushinteger(L, GTMN_NewLookMenus);
  lua_setglobal(L, "GTMN_NewLookMenus");
  lua_pushinteger(L, GTCB_Scaled);
  lua_setglobal(L, "GTCB_Scaled");
  lua_pushinteger(L, GTMX_Scaled);
  lua_setglobal(L, "GTMX_Scaled");
  lua_pushinteger(L, GTPA_NumColors);
  lua_setglobal(L, "GTPA_NumColors");
  lua_pushinteger(L, GTMX_TitlePlace);
  lua_setglobal(L, "GTMX_TitlePlace");
  lua_pushinteger(L, GTTX_FrontPen);
  lua_setglobal(L, "GTTX_FrontPen");
  lua_pushinteger(L, GTTX_BackPen);
  lua_setglobal(L, "GTTX_BackPen");
  lua_pushinteger(L, GTTX_Justification);
  lua_setglobal(L, "GTTX_Justification");
  lua_pushinteger(L, GTNM_FrontPen);
  lua_setglobal(L, "GTNM_FrontPen");
  lua_pushinteger(L, GTNM_BackPen);
  lua_setglobal(L, "GTNM_BackPen");
  lua_pushinteger(L, GTNM_Justification);
  lua_setglobal(L, "GTNM_Justification");
  lua_pushinteger(L, GTNM_Format);
  lua_setglobal(L, "GTNM_Format");
  lua_pushinteger(L, GTNM_MaxNumberLen);
  lua_setglobal(L, "GTNM_MaxNumberLen");
  lua_pushinteger(L, GTBB_FrameType);
  lua_setglobal(L, "GTBB_FrameType");
  lua_pushinteger(L, GTLV_MakeVisible);
  lua_setglobal(L, "GTLV_MakeVisible");
  lua_pushinteger(L, GTLV_ItemHeight);
  lua_setglobal(L, "GTLV_ItemHeight");
  lua_pushinteger(L, GTSL_MaxPixelLen);
  lua_setglobal(L, "GTSL_MaxPixelLen");
  lua_pushinteger(L, GTSL_Justification);
  lua_setglobal(L, "GTSL_Justification");
  lua_pushinteger(L, GTPA_ColorTable);
  lua_setglobal(L, "GTPA_ColorTable");
  lua_pushinteger(L, GTLV_CallBack);
  lua_setglobal(L, "GTLV_CallBack");
  lua_pushinteger(L, GTLV_MaxPen);
  lua_setglobal(L, "GTLV_MaxPen");
  lua_pushinteger(L, GTTX_Clipped);
  lua_setglobal(L, "GTTX_Clipped");
  lua_pushinteger(L, GTNM_Clipped);
  lua_setglobal(L, "GTNM_Clipped");
  lua_pushinteger(L, GTBB_reserved1);
  lua_setglobal(L, "GTBB_reserved1");
  lua_pushinteger(L, GTMN_reserved1);
  lua_setglobal(L, "GTMN_reserved1");
  lua_pushinteger(L, GTLV_Total);
  lua_setglobal(L, "GTLV_Total");
  lua_pushinteger(L, GTLV_Visible);
  lua_setglobal(L, "GTLV_Visible");
  lua_pushinteger(L, GTBB_Scale);
  lua_setglobal(L, "GTBB_Scale");
  lua_pushinteger(L, GTBB_Headline);
  lua_setglobal(L, "GTBB_Headline");
  lua_pushinteger(L, GTBB_HeadlinePen);
  lua_setglobal(L, "GTBB_HeadlinePen");
  lua_pushinteger(L, GTBB_HeadlineFont);
  lua_setglobal(L, "GTBB_HeadlineFont");
  lua_pushinteger(L, GTVI_LeftBorder);
  lua_setglobal(L, "GTVI_LeftBorder");
  lua_pushinteger(L, GTVI_TopBorder);
  lua_setglobal(L, "GTVI_TopBorder");
  lua_pushinteger(L, GTVI_AlignRight);
  lua_setglobal(L, "GTVI_AlignRight");
  lua_pushinteger(L, GTVI_AlignBottom);
  lua_setglobal(L, "GTVI_AlignBottom");
  lua_pushinteger(L, GTVI_MinFontWidth);
  lua_setglobal(L, "GTVI_MinFontWidth");
  lua_pushinteger(L, GTVI_MinFontHeight);
  lua_setglobal(L, "GTVI_MinFontHeight");
  lua_pushinteger(L, GTMX_ScaledSpacing);
  lua_setglobal(L, "GTMX_ScaledSpacing");
  lua_pushinteger(L, GT_Reserved0);
  lua_setglobal(L, "GT_Reserved0");
  lua_pushinteger(L, GTJ_LEFT);
  lua_setglobal(L, "GTJ_LEFT");
  lua_pushinteger(L, GTJ_RIGHT);
  lua_setglobal(L, "GTJ_RIGHT");
  lua_pushinteger(L, GTJ_CENTER);
  lua_setglobal(L, "GTJ_CENTER");
  lua_pushinteger(L, BBFT_BUTTON);
  lua_setglobal(L, "BBFT_BUTTON");
  lua_pushinteger(L, BBFT_RIDGE);
  lua_setglobal(L, "BBFT_RIDGE");
  lua_pushinteger(L, BBFT_ICONDROPBOX);
  lua_setglobal(L, "BBFT_ICONDROPBOX");
  lua_pushinteger(L, BBFT_DISPLAY);
  lua_setglobal(L, "BBFT_DISPLAY");
  lua_pushinteger(L, BBFT_CTXTFRAME);
  lua_setglobal(L, "BBFT_CTXTFRAME");
  lua_pushinteger(L, INTERWIDTH);
  lua_setglobal(L, "INTERWIDTH");
  lua_pushinteger(L, INTERHEIGHT);
  lua_setglobal(L, "INTERHEIGHT");
  lua_pushinteger(L, NWAY_KIND);
  lua_setglobal(L, "NWAY_KIND");
  lua_pushinteger(L, NWAYIDCMP);
  lua_setglobal(L, "NWAYIDCMP");
  lua_pushinteger(L, GTNW_Labels);
  lua_setglobal(L, "GTNW_Labels");
  lua_pushinteger(L, GTNW_Active);
  lua_setglobal(L, "GTNW_Active");
  lua_pushinteger(L, GADTOOLBIT);
  lua_setglobal(L, "GADTOOLBIT");
  lua_pushinteger(L, GADTOOLMASK);
  lua_setglobal(L, "GADTOOLMASK");
  lua_pushinteger(L, LV_DRAW);
  lua_setglobal(L, "LV_DRAW");
  lua_pushinteger(L, LVCB_OK);
  lua_setglobal(L, "LVCB_OK");
  lua_pushinteger(L, LVCB_UNKNOWN);
  lua_setglobal(L, "LVCB_UNKNOWN");
  lua_pushinteger(L, LVR_NORMAL);
  lua_setglobal(L, "LVR_NORMAL");
  lua_pushinteger(L, LVR_SELECTED);
  lua_setglobal(L, "LVR_SELECTED");
  lua_pushinteger(L, LVR_NORMALDISABLED);
  lua_setglobal(L, "LVR_NORMALDISABLED");
  lua_pushinteger(L, LVR_SELECTEDDISABLED);
  lua_setglobal(L, "LVR_SELECTEDDISABLED");
  lua_pushinteger(L, GADGHIGHBITS);
  lua_setglobal(L, "GADGHIGHBITS");
  lua_pushinteger(L, GADGHCOMP);
  lua_setglobal(L, "GADGHCOMP");
  lua_pushinteger(L, GADGHBOX);
  lua_setglobal(L, "GADGHBOX");
  lua_pushinteger(L, GADGHIMAGE);
  lua_setglobal(L, "GADGHIMAGE");
  lua_pushinteger(L, GADGHNONE);
  lua_setglobal(L, "GADGHNONE");
  lua_pushinteger(L, GADGIMAGE);
  lua_setglobal(L, "GADGIMAGE");
  lua_pushinteger(L, GRELBOTTOM);
  lua_setglobal(L, "GRELBOTTOM");
  lua_pushinteger(L, GRELRIGHT);
  lua_setglobal(L, "GRELRIGHT");
  lua_pushinteger(L, GRELWIDTH);
  lua_setglobal(L, "GRELWIDTH");
  lua_pushinteger(L, GRELHEIGHT);
  lua_setglobal(L, "GRELHEIGHT");
  lua_pushinteger(L, SELECTED);
  lua_setglobal(L, "SELECTED");
  lua_pushinteger(L, GADGDISABLED);
  lua_setglobal(L, "GADGDISABLED");
  lua_pushinteger(L, LABELMASK);
  lua_setglobal(L, "LABELMASK");
  lua_pushinteger(L, LABELITEXT);
  lua_setglobal(L, "LABELITEXT");
  lua_pushinteger(L, LABELSTRING);
  lua_setglobal(L, "LABELSTRING");
  lua_pushinteger(L, LABELIMAGE);
  lua_setglobal(L, "LABELIMAGE");
  lua_pushinteger(L, RELVERIFY);
  lua_setglobal(L, "RELVERIFY");
  lua_pushinteger(L, GADGIMMEDIATE);
  lua_setglobal(L, "GADGIMMEDIATE");
  lua_pushinteger(L, ENDGADGET);
  lua_setglobal(L, "ENDGADGET");
  lua_pushinteger(L, FOLLOWMOUSE);
  lua_setglobal(L, "FOLLOWMOUSE");
  lua_pushinteger(L, RIGHTBORDER);
  lua_setglobal(L, "RIGHTBORDER");
  lua_pushinteger(L, LEFTBORDER);
  lua_setglobal(L, "LEFTBORDER");
  lua_pushinteger(L, TOPBORDER);
  lua_setglobal(L, "TOPBORDER");
  lua_pushinteger(L, BOTTOMBORDER);
  lua_setglobal(L, "BOTTOMBORDER");
  lua_pushinteger(L, BORDERSNIFF);
  lua_setglobal(L, "BORDERSNIFF");
  lua_pushinteger(L, TOGGLESELECT);
  lua_setglobal(L, "TOGGLESELECT");
  lua_pushinteger(L, BOOLEXTEND);
  lua_setglobal(L, "BOOLEXTEND");
  lua_pushinteger(L, STRINGLEFT);
  lua_setglobal(L, "STRINGLEFT");
  lua_pushinteger(L, STRINGCENTER);
  lua_setglobal(L, "STRINGCENTER");
  lua_pushinteger(L, STRINGRIGHT);
  lua_setglobal(L, "STRINGRIGHT");
  lua_pushinteger(L, LONGINT);
  lua_setglobal(L, "LONGINT");
  lua_pushinteger(L, ALTKEYMAP);
  lua_setglobal(L, "ALTKEYMAP");
  lua_pushinteger(L, STRINGEXTEND);
  lua_setglobal(L, "STRINGEXTEND");
  lua_pushinteger(L, ACTIVEGADGET);
  lua_setglobal(L, "ACTIVEGADGET");
  lua_pushinteger(L, GADGETTYPE);
  lua_setglobal(L, "GADGETTYPE");
  lua_pushinteger(L, SYSGADGET);
  lua_setglobal(L, "SYSGADGET");
  lua_pushinteger(L, SCRGADGET);
  lua_setglobal(L, "SCRGADGET");
  lua_pushinteger(L, GZZGADGET);
  lua_setglobal(L, "GZZGADGET");
  lua_pushinteger(L, REQGADGET);
  lua_setglobal(L, "REQGADGET");
  lua_pushinteger(L, SIZING);
  lua_setglobal(L, "SIZING");
  lua_pushinteger(L, WDRAGGING);
  lua_setglobal(L, "WDRAGGING");
  lua_pushinteger(L, SDRAGGING);
  lua_setglobal(L, "SDRAGGING");
  lua_pushinteger(L, WUPFRONT);
  lua_setglobal(L, "WUPFRONT");
  lua_pushinteger(L, SUPFRONT);
  lua_setglobal(L, "SUPFRONT");
  lua_pushinteger(L, WDOWNBACK);
  lua_setglobal(L, "WDOWNBACK");
  lua_pushinteger(L, SDOWNBACK);
  lua_setglobal(L, "SDOWNBACK");
  lua_pushinteger(L, CLOSE);
  lua_setglobal(L, "CLOSE");
  lua_pushinteger(L, BOOLGADGET);
  lua_setglobal(L, "BOOLGADGET");
  lua_pushinteger(L, GADGET0002);
  lua_setglobal(L, "GADGET0002");
  lua_pushinteger(L, PROPGADGET);
  lua_setglobal(L, "PROPGADGET");
  lua_pushinteger(L, STRGADGET);
  lua_setglobal(L, "STRGADGET");
  lua_pushinteger(L, CUSTOMGADGET);
  lua_setglobal(L, "CUSTOMGADGET");
  lua_pushinteger(L, GTYPEMASK);
  lua_setglobal(L, "GTYPEMASK");
  lua_pushinteger(L, SIZEVERIFY);
  lua_setglobal(L, "SIZEVERIFY");
  lua_pushinteger(L, NEWSIZE);
  lua_setglobal(L, "NEWSIZE");
  lua_pushinteger(L, REFRESHWINDOW);
  lua_setglobal(L, "REFRESHWINDOW");
  lua_pushinteger(L, MOUSEBUTTONS);
  lua_setglobal(L, "MOUSEBUTTONS");
  lua_pushinteger(L, MOUSEMOVE);
  lua_setglobal(L, "MOUSEMOVE");
  lua_pushinteger(L, GADGETDOWN);
  lua_setglobal(L, "GADGETDOWN");
  lua_pushinteger(L, GADGETUP);
  lua_setglobal(L, "GADGETUP");
  lua_pushinteger(L, REQSET);
  lua_setglobal(L, "REQSET");
  lua_pushinteger(L, MENUPICK);
  lua_setglobal(L, "MENUPICK");
  lua_pushinteger(L, CLOSEWINDOW);
  lua_setglobal(L, "CLOSEWINDOW");
  lua_pushinteger(L, RAWKEY);
  lua_setglobal(L, "RAWKEY");
  lua_pushinteger(L, REQVERIFY);
  lua_setglobal(L, "REQVERIFY");
  lua_pushinteger(L, REQCLEAR);
  lua_setglobal(L, "REQCLEAR");
  lua_pushinteger(L, MENUVERIFY);
  lua_setglobal(L, "MENUVERIFY");
  lua_pushinteger(L, NEWPREFS);
  lua_setglobal(L, "NEWPREFS");
  lua_pushinteger(L, DISKINSERTED);
  lua_setglobal(L, "DISKINSERTED");
  lua_pushinteger(L, DISKREMOVED);
  lua_setglobal(L, "DISKREMOVED");
  lua_pushinteger(L, WBENCHMESSAGE);
  lua_setglobal(L, "WBENCHMESSAGE");
  lua_pushinteger(L, ACTIVEWINDOW);
  lua_setglobal(L, "ACTIVEWINDOW");
  lua_pushinteger(L, INACTIVEWINDOW);
  lua_setglobal(L, "INACTIVEWINDOW");
  lua_pushinteger(L, DELTAMOVE);
  lua_setglobal(L, "DELTAMOVE");
  lua_pushinteger(L, VANILLAKEY);
  lua_setglobal(L, "VANILLAKEY");
  lua_pushinteger(L, INTUITICKS);
  lua_setglobal(L, "INTUITICKS");
  lua_pushinteger(L, IDCMPUPDATE);
  lua_setglobal(L, "IDCMPUPDATE");
  lua_pushinteger(L, MENUHELP);
  lua_setglobal(L, "MENUHELP");
  lua_pushinteger(L, CHANGEWINDOW);
  lua_setglobal(L, "CHANGEWINDOW");
  lua_pushinteger(L, LONELYMESSAGE);
  lua_setglobal(L, "LONELYMESSAGE");
  lua_pushinteger(L, WINDOWSIZING);
  lua_setglobal(L, "WINDOWSIZING");
  lua_pushinteger(L, WINDOWDRAG);
  lua_setglobal(L, "WINDOWDRAG");
  lua_pushinteger(L, WINDOWDEPTH);
  lua_setglobal(L, "WINDOWDEPTH");
  lua_pushinteger(L, WINDOWCLOSE);
  lua_setglobal(L, "WINDOWCLOSE");
  lua_pushinteger(L, SIZEBRIGHT);
  lua_setglobal(L, "SIZEBRIGHT");
  lua_pushinteger(L, SIZEBBOTTOM);
  lua_setglobal(L, "SIZEBBOTTOM");
  lua_pushinteger(L, REFRESHBITS);
  lua_setglobal(L, "REFRESHBITS");
  lua_pushinteger(L, SMART_REFRESH);
  lua_setglobal(L, "SMART_REFRESH");
  lua_pushinteger(L, SIMPLE_REFRESH);
  lua_setglobal(L, "SIMPLE_REFRESH");
  lua_pushinteger(L, SUPER_BITMAP);
  lua_setglobal(L, "SUPER_BITMAP");
  lua_pushinteger(L, OTHER_REFRESH);
  lua_setglobal(L, "OTHER_REFRESH");
  lua_pushinteger(L, BACKDROP);
  lua_setglobal(L, "BACKDROP");
  lua_pushinteger(L, REPORTMOUSE);
  lua_setglobal(L, "REPORTMOUSE");
  lua_pushinteger(L, GIMMEZEROZERO);
  lua_setglobal(L, "GIMMEZEROZERO");
  lua_pushinteger(L, BORDERLESS);
  lua_setglobal(L, "BORDERLESS");
  lua_pushinteger(L, ACTIVATE);
  lua_setglobal(L, "ACTIVATE");
  lua_pushinteger(L, WINDOWACTIVE);
  lua_setglobal(L, "WINDOWACTIVE");
  lua_pushinteger(L, INREQUEST);
  lua_setglobal(L, "INREQUEST");
  lua_pushinteger(L, MENUSTATE);
  lua_setglobal(L, "MENUSTATE");
  lua_pushinteger(L, RMBTRAP);
  lua_setglobal(L, "RMBTRAP");
  lua_pushinteger(L, NOCAREREFRESH);
  lua_setglobal(L, "NOCAREREFRESH");
  lua_pushinteger(L, WINDOWREFRESH);
  lua_setglobal(L, "WINDOWREFRESH");
  lua_pushinteger(L, WBENCHWINDOW);
  lua_setglobal(L, "WBENCHWINDOW");
  lua_pushinteger(L, WINDOWTICKED);
  lua_setglobal(L, "WINDOWTICKED");
  lua_pushinteger(L, NW_EXTENDED);
  lua_setglobal(L, "NW_EXTENDED");
  lua_pushinteger(L, VISITOR);
  lua_setglobal(L, "VISITOR");
  lua_pushinteger(L, ZOOMED);
  lua_setglobal(L, "ZOOMED");
  lua_pushinteger(L, HASZOOM);
  lua_setglobal(L, "HASZOOM");
  lua_pushinteger(L, GA_LEFT);
  lua_setglobal(L, "GA_LEFT");
  lua_pushinteger(L, GA_RELRIGHT);
  lua_setglobal(L, "GA_RELRIGHT");
  lua_pushinteger(L, GA_TOP);
  lua_setglobal(L, "GA_TOP");
  lua_pushinteger(L, GA_RELBOTTOM);
  lua_setglobal(L, "GA_RELBOTTOM");
  lua_pushinteger(L, GA_WIDTH);
  lua_setglobal(L, "GA_WIDTH");
  lua_pushinteger(L, GA_RELWIDTH);
  lua_setglobal(L, "GA_RELWIDTH");
  lua_pushinteger(L, GA_HEIGHT);
  lua_setglobal(L, "GA_HEIGHT");
  lua_pushinteger(L, GA_RELHEIGHT);
  lua_setglobal(L, "GA_RELHEIGHT");
  lua_pushinteger(L, GA_TEXT);
  lua_setglobal(L, "GA_TEXT");
  lua_pushinteger(L, GA_IMAGE);
  lua_setglobal(L, "GA_IMAGE");
  lua_pushinteger(L, GA_BORDER);
  lua_setglobal(L, "GA_BORDER");
  lua_pushinteger(L, GA_SELECTRENDER);
  lua_setglobal(L, "GA_SELECTRENDER");
  lua_pushinteger(L, GA_HIGHLIGHT);
  lua_setglobal(L, "GA_HIGHLIGHT");
  lua_pushinteger(L, GA_DISABLED);
  lua_setglobal(L, "GA_DISABLED");
  lua_pushinteger(L, GA_GZZGADGET);
  lua_setglobal(L, "GA_GZZGADGET");
  lua_pushinteger(L, GA_USERDATA);
  lua_setglobal(L, "GA_USERDATA");
  lua_pushinteger(L, GA_SPECIALINFO);
  lua_setglobal(L, "GA_SPECIALINFO");
  lua_pushinteger(L, GA_SELECTED);
  lua_setglobal(L, "GA_SELECTED");
  lua_pushinteger(L, GA_ENDGADGET);
  lua_setglobal(L, "GA_ENDGADGET");
  lua_pushinteger(L, GA_IMMEDIATE);
  lua_setglobal(L, "GA_IMMEDIATE");
  lua_pushinteger(L, GA_RELVERIFY);
  lua_setglobal(L, "GA_RELVERIFY");
  lua_pushinteger(L, GA_FOLLOWMOUSE);
  lua_setglobal(L, "GA_FOLLOWMOUSE");
  lua_pushinteger(L, GA_RIGHTBORDER);
  lua_setglobal(L, "GA_RIGHTBORDER");
  lua_pushinteger(L, GA_LEFTBORDER);
  lua_setglobal(L, "GA_LEFTBORDER");
  lua_pushinteger(L, GA_TOPBORDER);
  lua_setglobal(L, "GA_TOPBORDER");
  lua_pushinteger(L, GA_BOTTOMBORDER);
  lua_setglobal(L, "GA_BOTTOMBORDER");
  lua_pushinteger(L, GA_TOGGLESELECT);
  lua_setglobal(L, "GA_TOGGLESELECT");
  lua_pushinteger(L, GA_SYSGADGET);
  lua_setglobal(L, "GA_SYSGADGET");
  lua_pushinteger(L, GA_SYSGTYPE);
  lua_setglobal(L, "GA_SYSGTYPE");
  lua_pushinteger(L, GA_PREVIOUS);
  lua_setglobal(L, "GA_PREVIOUS");
  lua_pushinteger(L, GA_NEXT);
  lua_setglobal(L, "GA_NEXT");
  lua_pushinteger(L, GA_DRAWINFO);
  lua_setglobal(L, "GA_DRAWINFO");
  lua_pushinteger(L, GA_INTUITEXT);
  lua_setglobal(L, "GA_INTUITEXT");
  lua_pushinteger(L, GA_LABELIMAGE);
  lua_setglobal(L, "GA_LABELIMAGE");
  lua_pushinteger(L, PGA_FREEDOM);
  lua_setglobal(L, "PGA_FREEDOM");
  lua_pushinteger(L, PGA_BORDERLESS);
  lua_setglobal(L, "PGA_BORDERLESS");
  lua_pushinteger(L, PGA_HORIZPOT);
  lua_setglobal(L, "PGA_HORIZPOT");
  lua_pushinteger(L, PGA_HORIZBODY);
  lua_setglobal(L, "PGA_HORIZBODY");
  lua_pushinteger(L, PGA_VERTPOT);
  lua_setglobal(L, "PGA_VERTPOT");
  lua_pushinteger(L, PGA_VERTBODY);
  lua_setglobal(L, "PGA_VERTBODY");
  lua_pushinteger(L, PGA_TOTAL);
  lua_setglobal(L, "PGA_TOTAL");
  lua_pushinteger(L, PGA_VISIBLE);
  lua_setglobal(L, "PGA_VISIBLE");
  lua_pushinteger(L, PGA_TOP);
  lua_setglobal(L, "PGA_TOP");
  lua_pushinteger(L, LAYOUTA_LAYOUTOBJ);
  lua_setglobal(L, "LAYOUTA_LAYOUTOBJ");
  lua_pushinteger(L, LAYOUTA_SPACING);
  lua_setglobal(L, "LAYOUTA_SPACING");
  lua_pushinteger(L, LAYOUTA_ORIENTATION);
  lua_setglobal(L, "LAYOUTA_ORIENTATION");
  lua_pushinteger(L, IMAGE_ATTRIBUTES);
  lua_setglobal(L, "IMAGE_ATTRIBUTES");
  lua_pushinteger(L, IA_LEFT);
  lua_setglobal(L, "IA_LEFT");
  lua_pushinteger(L, IA_TOP);
  lua_setglobal(L, "IA_TOP");
  lua_pushinteger(L, IA_WIDTH);
  lua_setglobal(L, "IA_WIDTH");
  lua_pushinteger(L, IA_HEIGHT);
  lua_setglobal(L, "IA_HEIGHT");
  lua_pushinteger(L, IA_FGPEN);
  lua_setglobal(L, "IA_FGPEN");
  lua_pushinteger(L, IA_BGPEN);
  lua_setglobal(L, "IA_BGPEN");
  lua_pushinteger(L, IA_DATA);
  lua_setglobal(L, "IA_DATA");
  lua_pushinteger(L, IA_LINEWIDTH);
  lua_setglobal(L, "IA_LINEWIDTH");
  lua_pushinteger(L, IA_PENS);
  lua_setglobal(L, "IA_PENS");
  lua_pushinteger(L, IA_RESOLUTION);
  lua_setglobal(L, "IA_RESOLUTION");
  lua_pushinteger(L, IA_APATTERN);
  lua_setglobal(L, "IA_APATTERN");
  lua_pushinteger(L, IA_APATSIZE);
  lua_setglobal(L, "IA_APATSIZE");
  lua_pushinteger(L, IA_MODE);
  lua_setglobal(L, "IA_MODE");
  lua_pushinteger(L, IA_FONT);
  lua_setglobal(L, "IA_FONT");
  lua_pushinteger(L, IA_OUTLINE);
  lua_setglobal(L, "IA_OUTLINE");
  lua_pushinteger(L, IA_RECESSED);
  lua_setglobal(L, "IA_RECESSED");
  lua_pushinteger(L, IA_DOUBLEEMBOSS);
  lua_setglobal(L, "IA_DOUBLEEMBOSS");
  lua_pushinteger(L, IA_EDGESONLY);
  lua_setglobal(L, "IA_EDGESONLY");
  lua_pushinteger(L, IA_SHADOWPEN);
  lua_setglobal(L, "IA_SHADOWPEN");
  lua_pushinteger(L, IA_HIGHLIGHTPEN);
  lua_setglobal(L, "IA_HIGHLIGHTPEN");
  lua_pushinteger(L, detailPen);
  lua_setglobal(L, "detailPen");
  lua_pushinteger(L, blockPen);
  lua_setglobal(L, "blockPen");
  lua_pushinteger(L, textPen);
  lua_setglobal(L, "textPen");
  lua_pushinteger(L, shinePen);
  lua_setglobal(L, "shinePen");
  lua_pushinteger(L, shadowPen);
  lua_setglobal(L, "shadowPen");
  lua_pushinteger(L, hifillPen);
  lua_setglobal(L, "hifillPen");
  lua_pushinteger(L, hifilltextPen);
  lua_setglobal(L, "hifilltextPen");
  lua_pushinteger(L, backgroundPen);
  lua_setglobal(L, "backgroundPen");
  lua_pushinteger(L, hilighttextPen);
  lua_setglobal(L, "hilighttextPen");
  lua_pushinteger(L, numDrIPens);
  lua_setglobal(L, "numDrIPens");
}

static void
_lua_gen_installGeneratedMetaTables(lua_State *L)
{
  _lua_gen_install_meta_Hook(L);
  _lua_gen_install_meta_GadgetInfo(L);
  _lua_gen_install_meta_IClass(L);
  _lua_gen_install_meta_Point(L);
  _lua_gen_install_meta_BitMap(L);
  _lua_gen_install_meta_ViewPort(L);
  _lua_gen_install_meta_View(L);
  _lua_gen_install_meta_ColorMap(L);
  _lua_gen_install_meta_RasInfo(L);
  _lua_gen_install_meta_ViewPortExtra(L);
  _lua_gen_install_meta_DBufInfo(L);
  _lua_gen_install_meta_Border(L);
  _lua_gen_install_meta_ClipRect(L);
  _lua_gen_install_meta_DrawInfo(L);
  _lua_gen_install_meta_Gadget(L);
  _lua_gen_install_meta_Image(L);
  _lua_gen_install_meta_IntuiText(L);
  _lua_gen_install_meta_KeyMap(L);
  _lua_gen_install_meta_Layer(L);
  _lua_gen_install_meta_Layer_Info(L);
  _lua_gen_install_meta_Menu(L);
  _lua_gen_install_meta_MenuItem(L);
  _lua_gen_install_meta_NewGadget(L);
  _lua_gen_install_meta_NewMenu(L);
  _lua_gen_install_meta_NewScreen(L);
  _lua_gen_install_meta_NewWindow(L);
  _lua_gen_install_meta_RastPort(L);
  _lua_gen_install_meta_Requester(L);
  _lua_gen_install_meta_Screen(L);
  _lua_gen_install_meta_TextAttr(L);
  _lua_gen_install_meta_TextFont(L);
  _lua_gen_install_meta_Window(L);
  _lua_gen_install_meta_StringInfo(L);
  _lua_gen_install_meta_StringExtend(L);
  _lua_gen_install_meta_IntuiMessage(L);
  _lua_gen_install_meta_IBox(L);
  _lua_gen_install_meta_ScreenBuffer(L);
  _lua_gen_install_meta_GadgetPtr(L);
}

static void
_lua_gen_installGeneratedEnums(lua_State *L)
{
  (void)L;
}

static void
_lua_gen_installGeneratedFunctions(lua_State *L)
{(void)L;

  lua_register(L, "OpenIntuition", _lua_OpenIntuition);
  lua_register(L, "Intuition", _lua_Intuition);
  lua_register(L, "ClearDMRequest", _lua_ClearDMRequest);
  lua_register(L, "ClearMenuStrip", _lua_ClearMenuStrip);
  lua_register(L, "ClearPointer", _lua_ClearPointer);
  lua_register(L, "CloseScreen", _lua_CloseScreen);
  lua_register(L, "CloseWindow", _lua_CloseWindow);
  lua_register(L, "CloseWorkBench", _lua_CloseWorkBench);
  lua_register(L, "CurrentTime", _lua_CurrentTime);
  lua_register(L, "DisplayAlert", _lua_DisplayAlert);
  lua_register(L, "DisplayBeep", _lua_DisplayBeep);
  lua_register(L, "EndRequest", _lua_EndRequest);
  lua_register(L, "InitRequester", _lua_InitRequester);
  lua_register(L, "ItemAddress", _lua_ItemAddress);
  lua_register(L, "ModifyIDCMP", _lua_ModifyIDCMP);
  lua_register(L, "MoveScreen", _lua_MoveScreen);
  lua_register(L, "MoveWindow", _lua_MoveWindow);
  lua_register(L, "OffMenu", _lua_OffMenu);
  lua_register(L, "OnMenu", _lua_OnMenu);
  lua_register(L, "OpenScreen", _lua_OpenScreen);
  lua_register(L, "OpenWindow", _lua_OpenWindow);
  lua_register(L, "OpenWorkBench", _lua_OpenWorkBench);
  lua_register(L, "RemoveGadget", _lua_RemoveGadget);
  lua_register(L, "ReportMouse", _lua_ReportMouse);
  lua_register(L, "ReportMouse1", _lua_ReportMouse1);
  lua_register(L, "Request", _lua_Request);
  lua_register(L, "ScreenToBack", _lua_ScreenToBack);
  lua_register(L, "ScreenToFront", _lua_ScreenToFront);
  lua_register(L, "SetDMRequest", _lua_SetDMRequest);
  lua_register(L, "SetMenuStrip", _lua_SetMenuStrip);
  lua_register(L, "ShowTitle", _lua_ShowTitle);
  lua_register(L, "SizeWindow", _lua_SizeWindow);
  lua_register(L, "ViewAddress", _lua_ViewAddress);
  lua_register(L, "ViewPortAddress", _lua_ViewPortAddress);
  lua_register(L, "WindowToBack", _lua_WindowToBack);
  lua_register(L, "WindowToFront", _lua_WindowToFront);
  lua_register(L, "IntuiTextLength", _lua_IntuiTextLength);
  lua_register(L, "WBenchToBack", _lua_WBenchToBack);
  lua_register(L, "WBenchToFront", _lua_WBenchToFront);
  lua_register(L, "BeginRefresh", _lua_BeginRefresh);
  lua_register(L, "EndRefresh", _lua_EndRefresh);
  lua_register(L, "FreeSysRequest", _lua_FreeSysRequest);
  lua_register(L, "MakeScreen", _lua_MakeScreen);
  lua_register(L, "RemakeDisplay", _lua_RemakeDisplay);
  lua_register(L, "RethinkDisplay", _lua_RethinkDisplay);
  lua_register(L, "AlohaWorkbench", _lua_AlohaWorkbench);
  lua_register(L, "LockIBase", _lua_LockIBase);
  lua_register(L, "UnlockIBase", _lua_UnlockIBase);
  lua_register(L, "ActivateWindow", _lua_ActivateWindow);
  lua_register(L, "RefreshWindowFrame", _lua_RefreshWindowFrame);
  lua_register(L, "SetEditHook", _lua_SetEditHook);
  lua_register(L, "SetMouseQueue", _lua_SetMouseQueue);
  lua_register(L, "ZipWindow", _lua_ZipWindow);
  lua_register(L, "LockPubScreen", _lua_LockPubScreen);
  lua_register(L, "UnlockPubScreen", _lua_UnlockPubScreen);
  lua_register(L, "LockPubScreenList", _lua_LockPubScreenList);
  lua_register(L, "UnlockPubScreenList", _lua_UnlockPubScreenList);
  lua_register(L, "NextPubScreen", _lua_NextPubScreen);
  lua_register(L, "SetDefaultPubScreen", _lua_SetDefaultPubScreen);
  lua_register(L, "SetPubScreenModes", _lua_SetPubScreenModes);
  lua_register(L, "PubScreenStatus", _lua_PubScreenStatus);
  lua_register(L, "ObtainGIRPort", _lua_ObtainGIRPort);
  lua_register(L, "ReleaseGIRPort", _lua_ReleaseGIRPort);
  lua_register(L, "GetDefaultPubScreen", _lua_GetDefaultPubScreen);
  lua_register(L, "OpenWindowTagList", _lua_OpenWindowTagList);
  lua_register(L, "OpenWindowTags", _lua_OpenWindowTags);
  lua_register(L, "OpenScreenTagList", _lua_OpenScreenTagList);
  lua_register(L, "OpenScreenTags", _lua_OpenScreenTags);
  lua_register(L, "PointInImage", _lua_PointInImage);
  lua_register(L, "DisposeObject", _lua_DisposeObject);
  lua_register(L, "SetAttrsA", _lua_SetAttrsA);
  lua_register(L, "SetAttrs", _lua_SetAttrs);
  lua_register(L, "GetAttr", _lua_GetAttr);
  lua_register(L, "NextObject", _lua_NextObject);
  lua_register(L, "AddClass", _lua_AddClass);
  lua_register(L, "GetScreenDrawInfo", _lua_GetScreenDrawInfo);
  lua_register(L, "ResetMenuStrip", _lua_ResetMenuStrip);
  lua_register(L, "RemoveClass", _lua_RemoveClass);
  lua_register(L, "FreeClass", _lua_FreeClass);
  lua_register(L, "FreeScreenBuffer", _lua_FreeScreenBuffer);
  lua_register(L, "ChangeScreenBuffer", _lua_ChangeScreenBuffer);
  lua_register(L, "ScreenDepth", _lua_ScreenDepth);
  lua_register(L, "LendMenus", _lua_LendMenus);
  lua_register(L, "SetWindowPointerA", _lua_SetWindowPointerA);
  lua_register(L, "SetWindowPointer", _lua_SetWindowPointer);
  lua_register(L, "TimedDisplayAlert", _lua_TimedDisplayAlert);
  lua_register(L, "HelpControl", _lua_HelpControl);
  lua_register(L, "ShowWindow", _lua_ShowWindow);
  lua_register(L, "HideWindow", _lua_HideWindow);
  lua_register(L, "IntuitionControlA", _lua_IntuitionControlA);
  lua_register(L, "IntuitionControl", _lua_IntuitionControl);
  lua_register(L, "CreateGadgetA", _lua_CreateGadgetA);
  lua_register(L, "CreateGadget", _lua_CreateGadget);
  lua_register(L, "FreeGadgets", _lua_FreeGadgets);
  lua_register(L, "GT_SetGadgetAttrsA", _lua_GT_SetGadgetAttrsA);
  lua_register(L, "GT_SetGadgetAttrs", _lua_GT_SetGadgetAttrs);
  lua_register(L, "CreateMenusA", _lua_CreateMenusA);
  lua_register(L, "CreateMenus", _lua_CreateMenus);
  lua_register(L, "FreeMenus", _lua_FreeMenus);
  lua_register(L, "LayoutMenuItemsA", _lua_LayoutMenuItemsA);
  lua_register(L, "LayoutMenuItems", _lua_LayoutMenuItems);
  lua_register(L, "LayoutMenusA", _lua_LayoutMenusA);
  lua_register(L, "LayoutMenus", _lua_LayoutMenus);
  lua_register(L, "GT_GetIMsg", _lua_GT_GetIMsg);
  lua_register(L, "GT_ReplyIMsg", _lua_GT_ReplyIMsg);
  lua_register(L, "GT_RefreshWindow", _lua_GT_RefreshWindow);
  lua_register(L, "GT_BeginRefresh", _lua_GT_BeginRefresh);
  lua_register(L, "GT_EndRefresh", _lua_GT_EndRefresh);
  lua_register(L, "GT_FilterIMsg", _lua_GT_FilterIMsg);
  lua_register(L, "GT_PostFilterIMsg", _lua_GT_PostFilterIMsg);
  lua_register(L, "CreateContext", _lua_CreateContext);
  lua_register(L, "DrawBevelBoxA", _lua_DrawBevelBoxA);
  lua_register(L, "DrawBevelBox", _lua_DrawBevelBox);
  lua_register(L, "GetVisualInfoA", _lua_GetVisualInfoA);
  lua_register(L, "GetVisualInfo", _lua_GetVisualInfo);
  lua_register(L, "FreeVisualInfo", _lua_FreeVisualInfo);
  lua_register(L, "SetDesignFontA", _lua_SetDesignFontA);
  lua_register(L, "SetDesignFont", _lua_SetDesignFont);
  lua_register(L, "ScaleGadgetRectA", _lua_ScaleGadgetRectA);
  lua_register(L, "ScaleGadgetRect", _lua_ScaleGadgetRect);
  lua_register(L, "GT_GetGadgetAttrsA", _lua_GT_GetGadgetAttrsA);
  lua_register(L, "GT_GetGadgetAttrs", _lua_GT_GetGadgetAttrs);
}

static void
_lua_gen_installGeneratedFunctionCallers(lua_State *L)
{
  (void)L;
}

void
lua_gen_install(lua_State *L) {
  _lua_gen_install_defines(L);

  _lua_gen_installGeneratedMetaTables(L);
  _lua_gen_installGeneratedEnums(L);
  _lua_gen_installGeneratedFunctions(L);
  _lua_gen_installGeneratedFunctionCallers(L);
}

